// Generated by Haxe 4.1.4
(function ($global) { "use strict";
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var CheckstyleVersion = function() { };
$hxClasses["CheckstyleVersion"] = CheckstyleVersion;
CheckstyleVersion.__name__ = "CheckstyleVersion";
var CompileTime = function() { };
$hxClasses["CompileTime"] = CompileTime;
CompileTime.__name__ = "CompileTime";
var CompileTimeClassList = function() { };
$hxClasses["CompileTimeClassList"] = CompileTimeClassList;
CompileTimeClassList.__name__ = "CompileTimeClassList";
CompileTimeClassList.get = function(id) {
	if(CompileTimeClassList.lists == null) {
		CompileTimeClassList.initialise();
	}
	return CompileTimeClassList.lists.h[id];
};
CompileTimeClassList.getTyped = function(id,type) {
	return CompileTimeClassList.get(id);
};
CompileTimeClassList.initialise = function() {
	CompileTimeClassList.lists = new haxe_ds_StringMap();
	var m = haxe_rtti_Meta.getType(CompileTimeClassList);
	if(m.classLists != null) {
		var _g = 0;
		var _g1 = m.classLists;
		while(_g < _g1.length) {
			var item = _g1[_g];
			++_g;
			var array = item;
			var listID = array[0];
			var list = new haxe_ds_List();
			var _g2 = 0;
			var _g3 = array[1].split(",");
			while(_g2 < _g3.length) {
				var typeName = _g3[_g2];
				++_g2;
				var type = $hxClasses[typeName];
				if(type != null) {
					list.push(type);
				}
			}
			CompileTimeClassList.lists.h[listID] = list;
		}
	}
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = "EReg";
EReg.prototype = {
	r: null
	,match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedRight: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = "Lambda";
Lambda.has = function(it,elt) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(x1 == elt) {
			return true;
		}
	}
	return false;
};
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Lambda.fold = function(it,f,first) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		first = f(x1,first);
	}
	return first;
};
Math.__name__ = "Math";
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	b: null
	,__class__: StringBuf
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b += s == null ? "null" : "" + s;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var Sys = function() { };
$hxClasses["Sys"] = Sys;
Sys.__name__ = "Sys";
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		var other = _g;
		return other;
	}
};
var haxe_io_Output = function() { };
$hxClasses["haxe.io.Output"] = haxe_io_Output;
haxe_io_Output.__name__ = "haxe.io.Output";
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
	,__class__: haxe_io_Output
};
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
$hxClasses["_Sys.FileOutput"] = _$Sys_FileOutput;
_$Sys_FileOutput.__name__ = "_Sys.FileOutput";
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	fd: null
	,writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,flush: function() {
		js_node_Fs.fsyncSync(this.fd);
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,__class__: _$Sys_FileOutput
});
var haxe_io_Input = function() { };
$hxClasses["haxe.io.Input"] = haxe_io_Input;
haxe_io_Input.__name__ = "haxe.io.Input";
var _$Sys_FileInput = function(fd) {
	this.fd = fd;
};
$hxClasses["_Sys.FileInput"] = _$Sys_FileInput;
_$Sys_FileInput.__name__ = "_Sys.FileInput";
_$Sys_FileInput.__super__ = haxe_io_Input;
_$Sys_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	fd: null
	,readByte: function() {
		var buf = js_node_buffer_Buffer.alloc(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,__class__: _$Sys_FileInput
});
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
Type.createInstance = function(cl,args) {
	var ctor = Function.prototype.bind.apply(cl,[null].concat(args));
	return new (ctor);
};
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	HxOverrides.remove(a,"__class__");
	HxOverrides.remove(a,"__properties__");
	return a;
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var ctorName = enm.__constructs__[a._hx_index];
		var params = enm[ctorName].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return false;
	}
	return true;
};
var byte_ByteData = {};
byte_ByteData.get_length = function(this1) {
	return this1.length;
};
byte_ByteData.readByte = function(this1,i) {
	return this1.b[i];
};
byte_ByteData._new = function(data) {
	var this1 = data;
	return this1;
};
byte_ByteData.ofString = function(s) {
	var this1 = haxe_io_Bytes.ofString(s);
	return this1;
};
byte_ByteData.ofBytes = function(b) {
	var this1 = b;
	return this1;
};
byte_ByteData.readString = function(this1,pos,len) {
	return this1.getString(pos,len);
};
var checkstyle_Checker = function(allowFailingAST) {
	if(allowFailingAST == null) {
		allowFailingAST = false;
	}
	this.checks = [];
	this.baseDefines = [];
	this.defineCombinations = [];
	this.linesIdx = [];
	this.allowFailingAST = allowFailingAST;
};
$hxClasses["checkstyle.Checker"] = checkstyle_Checker;
checkstyle_Checker.__name__ = "checkstyle.Checker";
checkstyle_Checker.prototype = {
	file: null
	,lines: null
	,tokens: null
	,ast: null
	,checks: null
	,baseDefines: null
	,defineCombinations: null
	,linesIdx: null
	,lineSeparator: null
	,tokenTree: null
	,allowFailingAST: null
	,asts: null
	,excludesRanges: null
	,addCheck: function(check) {
		this.checks.push(check);
	}
	,getTokenTree: function() {
		if(this.tokens == null) {
			return null;
		}
		if(this.tokenTree == null) {
			this.tokenTree = tokentree_TokenTreeBuilder.buildTokenTree(this.tokens,this.file.content);
		}
		return this.tokenTree;
	}
	,makePosIndices: function() {
		var code = this.file.content;
		this.linesIdx = [];
		var last = 0;
		var left = false;
		var _g = 0;
		var _g1 = code.length;
		while(_g < _g1) {
			var i = _g++;
			if(code.b[i] == 10) {
				this.linesIdx.push({ l : last, r : i});
				last = i + 1;
				left = false;
			}
			left = true;
		}
		if(left) {
			this.linesIdx.push({ l : last, r : code.length});
		}
	}
	,getLinePos: function(off) {
		var lowerBound = 0;
		var upperBound = this.linesIdx.length - 1;
		if(this.linesIdx.length <= 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off < 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off > this.linesIdx[upperBound].r) {
			throw haxe_Exception.thrown("Bad offset");
		}
		while(true) {
			if(lowerBound > upperBound) {
				throw haxe_Exception.thrown("Bad offset");
			}
			var center = lowerBound + Math.floor((upperBound - lowerBound) / 2);
			var matchLeft = this.linesIdx[center].l <= off;
			var matchRight = this.linesIdx[center].r >= off;
			if(matchLeft && matchRight) {
				return { line : center, ofs : off - this.linesIdx[center].l};
			}
			if(matchLeft) {
				lowerBound = center + 1;
				continue;
			}
			if(matchRight) {
				upperBound = center - 1;
				continue;
			}
		}
	}
	,getString: function(off,off2) {
		var code = this.file.content;
		var len = off2 - off;
		if(off >= code.length || off + len > code.length) {
			return "";
		}
		return code.sub(off,off2 - off).toString();
	}
	,findLineSeparator: function() {
		var codeBytes = this.file.content;
		var code = codeBytes.toString();
		var _g = 0;
		var _g1 = code.length;
		while(_g < _g1) {
			var i = _g++;
			var char = code.charAt(i);
			if(char == "\r" || char == "\n") {
				this.lineSeparator = char;
				if(char == "\r" && i + 1 < code.length) {
					char = code.charAt(i + 1);
					if(char == "\n") {
						this.lineSeparator += char;
					}
				}
				return;
			}
		}
		this.lineSeparator = "\n";
	}
	,makeLines: function() {
		var code = this.file.content;
		var textCode = code.toString();
		this.lines = textCode.split(this.lineSeparator);
	}
	,makeTokens: function() {
		try {
			this.tokens = [];
			this.tokenTree = null;
			var lexer = new haxeparser_HaxeLexer(this.file.content,this.file.name);
			var t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				this.tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var e = haxe_Exception.caught(_g).unwrap();
			checkstyle_utils_ErrorUtils.handleException(e,this.file,"makeTokens");
		}
	}
	,makeASTs: function() {
		this.asts = [];
		var res = this.makeAST(this.baseDefines);
		if(res != null) {
			this.asts.push(res);
		}
		var _g = 0;
		var _g1 = this.defineCombinations;
		while(_g < _g1.length) {
			var combination = _g1[_g];
			++_g;
			var res = this.makeAST(combination.concat(this.baseDefines));
			if(res != null) {
				this.asts.push(res);
			}
		}
	}
	,makeAST: function(defines) {
		var parser = new haxeparser_HaxeParser(this.file.content,this.file.name);
		parser.define("cross");
		parser.define("scriptable");
		parser.define("unsafe");
		var _g = 0;
		while(_g < defines.length) {
			var define = defines[_g];
			++_g;
			var flagValue = define.split("=");
			parser.define(flagValue[0],flagValue[1]);
		}
		try {
			return parser.parse();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var e = haxe_Exception.caught(_g).unwrap();
			if(!this.allowFailingAST) {
				checkstyle_utils_ErrorUtils.handleException(e,this.file,"makeAST [" + defines.join(",") + "]");
			}
		}
		return null;
	}
	,process: function(files) {
		var advanceFrame = function() {
		};
		checkstyle_reporter_ReporterManager.INSTANCE.start();
		var _g = 0;
		while(_g < files.length) {
			var checkFile = files[_g];
			++_g;
			this.loadFileContent(checkFile);
			if(this.createContext(checkFile)) {
				this.run();
			}
			this.unloadFileContent(checkFile);
			advanceFrame();
		}
		advanceFrame();
		checkstyle_reporter_ReporterManager.INSTANCE.finish();
		advanceFrame();
	}
	,loadFileContent: function(checkFile) {
		if(checkFile.content == null) {
			checkFile.content = js_node_buffer__$Buffer_Helper.bytesOfBuffer(js_node_Fs.readFileSync(checkFile.name));
		}
	}
	,unloadFileContent: function(checkFile) {
		checkFile.content = null;
	}
	,createContext: function(checkFile) {
		this.file = checkFile;
		checkstyle_reporter_ReporterManager.INSTANCE.fileStart(this.file);
		try {
			this.findLineSeparator();
			this.makeLines();
			this.makePosIndices();
			this.makeTokens();
			this.makeASTs();
			this.getTokenTree();
			this.excludesRanges = checkstyle_config_ExcludeManager.INSTANCE.getPosExcludes(this);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var e = haxe_Exception.caught(_g).unwrap();
			checkstyle_utils_ErrorUtils.handleException(e,this.file,"createContext");
			return false;
		}
		return true;
	}
	,run: function() {
		var _g = 0;
		var _g1 = this.checks;
		while(_g < _g1.length) {
			var check = _g1[_g];
			++_g;
			var messages = [];
			if(check.type == checkstyle_checks_CheckType.AST) {
				var _g2 = 0;
				var _g3 = this.asts;
				while(_g2 < _g3.length) {
					var ast = _g3[_g2];
					++_g2;
					this.ast = ast;
					messages = messages.concat(this.runCheck(check));
				}
			} else {
				this.ast = this.asts[0];
				messages = messages.concat(this.runCheck(check));
			}
			checkstyle_reporter_ReporterManager.INSTANCE.addMessages(messages);
		}
		checkstyle_reporter_ReporterManager.INSTANCE.fileFinish(this.file);
	}
	,runCheck: function(check) {
		try {
			if(checkstyle_config_ExcludeManager.isExcludedFromCheck(this.file.name,check.getModuleName())) {
				return [];
			}
			return check.run(this);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var e = haxe_Exception.caught(_g).unwrap();
			checkstyle_utils_ErrorUtils.handleException(e,this.file,check.getModuleName());
			return [];
		}
	}
	,__class__: checkstyle_Checker
};
var checkstyle_ChecksInfo = function() {
	this.checkInfos = new haxe_ds_StringMap();
	var checksClasses = CompileTimeClassList.get("null,true,checkstyle.checks.Check");
	var _g_head = checksClasses.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var cl = val;
		if(checkstyle_ChecksInfo.ignoreClass(cl)) {
			continue;
		}
		var names = checkstyle_ChecksInfo.getCheckNameFromClass(cl);
		var _g = 0;
		var _g1 = names.length;
		while(_g < _g1) {
			var i = _g++;
			var desc = this.getCheckDescription(cl);
			var v = { name : names[i], clazz : cl, isAlias : i > 0, description : i == 0 ? desc : desc + " [DEPRECATED, use " + Std.string(names[0]) + " instead]"};
			this.checkInfos.h[names[i]] = v;
		}
	}
};
$hxClasses["checkstyle.ChecksInfo"] = checkstyle_ChecksInfo;
checkstyle_ChecksInfo.__name__ = "checkstyle.ChecksInfo";
checkstyle_ChecksInfo.ignoreClass = function(cl) {
	var meta = haxe_rtti_Meta.getType(cl);
	return meta.ignore != null;
};
checkstyle_ChecksInfo.getCheckNameFromClass = function(cl) {
	var meta = haxe_rtti_Meta.getType(cl);
	if(meta.name == null) {
		throw haxe_Exception.thrown("" + cl.__name__ + " has no @name meta.");
	}
	return meta.name;
};
checkstyle_ChecksInfo.getCheckName = function(check) {
	return checkstyle_ChecksInfo.getCheckNameFromClass(js_Boot.getClass(check))[0];
};
checkstyle_ChecksInfo.prototype = {
	checkInfos: null
	,getCheckDescription: function(cl) {
		return haxe_rtti_Meta.getType(cl).desc[0];
	}
	,checks: function() {
		return haxe_ds_StringMap.valueIterator(this.checkInfos.h);
	}
	,build: function(name) {
		if(!Object.prototype.hasOwnProperty.call(this.checkInfos.h,name)) {
			return null;
		}
		var cl = this.checkInfos.h[name].clazz;
		return Type.createInstance(cl,[]);
	}
	,__class__: checkstyle_ChecksInfo
};
var checkstyle_Main = function() {
	checkstyle_Main.exitCode = 0;
	this.configPath = null;
	this.excludePath = null;
	this.detectConfig = null;
	this.configParser = new checkstyle_config_ConfigParser($bind(this,this.failWith));
	this.checker = this.configParser.checker;
};
$hxClasses["checkstyle.Main"] = checkstyle_Main;
checkstyle_Main.__name__ = "checkstyle.Main";
checkstyle_Main.setExitCode = function(newExitCode) {
	checkstyle_Main.exitCode = newExitCode;
};
checkstyle_Main.main = function() {
	var args;
	var cwd;
	var oldCwd = null;
	try {
		args = process.argv.slice(2);
		cwd = process.cwd();
		if(process.env["HAXELIB_RUN"] != null) {
			cwd = args.pop();
			oldCwd = process.cwd();
		}
		if(oldCwd != null) {
			process.chdir(cwd);
		}
		new checkstyle_Main().run(args);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var e = haxe_Exception.caught(_g).unwrap();
		new _$Sys_FileOutput(2).writeString((e == null ? "null" : Std.string(e)) + "\n");
		new _$Sys_FileOutput(2).writeString(haxe_CallStack.toString(haxe_CallStack.exceptionStack()) + "\n");
	}
	if(oldCwd != null) {
		process.chdir(oldCwd);
	}
	var code = checkstyle_Main.exitCode;
	process.exit(code);
};
checkstyle_Main.prototype = {
	checker: null
	,configPath: null
	,excludePath: null
	,disableThreads: null
	,detectConfig: null
	,configParser: null
	,run: function(args) {
		var _gthis = this;
		var argHandler_getDoc = function() {
			return "[-s | --source] <path>    : Set source path to process (multiple allowed)\n[-c | --config] <path>    : Set config file (default: checkstyle.json)\n[-e | --exclude] <path>   : Set exclude file (default: checkstyle-exclude.json)\n[-r | --reporter] <name>  : Set reporter (xml, json or text, default: text)\n[-p | --path] <path>      : Set reporter output path\n[-x | --xslt] <style>     : Set reporter style (XSLT)\n[--checkerthreads] <num>  : Sets the number of checker threads\n[--default-config] <path> : Generate a default config and exit\n[--detect] <path>         : Try to detect your coding style (experimental)\n[--exitcode]              : Return number of failed checks in exitcode\n[--list-checks]           : List all available checks and exit\n[--list-reporters]        : List all available reporters and exit\n[--nostyle]               : Omit styling in output summary\n[--nothreads]             : Do not use checker threads\n[--progress]              : Show percentage progress\n[--show-missing-checks]   : Show checks missing from active config\n[--show-parser-errors]    : Adds error messages for files that checkstyle fails to parse";
		};
		var argHandler_parse = function(__args) {
			var __index = 0;
			while(__index < __args.length) {
				var _g = __args[__index++];
				switch(_g) {
				case "--checkerthreads":
					if(__index + 1 > __args.length) {
						if(![false][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
						}
					}
					_gthis.configParser.overrideCheckerThreads = Std.parseInt(__args[__index]);
					++__index;
					break;
				case "--default-config":
					if(__index + 1 > __args.length) {
						if(![false][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
						}
					}
					_gthis.generateDefaultConfig(__args[__index]);
					++__index;
					break;
				case "--detect":
					if(__index + 1 > __args.length) {
						if(![false][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
						}
					}
					_gthis.detectCodingStyle(__args[__index]);
					++__index;
					break;
				case "--exitcode":
					if(__index > __args.length) {
						if(![][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
						}
					}
					checkstyle_Main.EXIT_CODE = true;
					__index += 0;
					break;
				case "--list-checks":
					if(__index > __args.length) {
						if(![][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
						}
					}
					_gthis.listChecks();
					__index += 0;
					break;
				case "--list-reporters":
					if(__index > __args.length) {
						if(![][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
						}
					}
					_gthis.listReporters();
					__index += 0;
					break;
				case "--nostyle":
					if(__index > __args.length) {
						if(![][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
						}
					}
					checkstyle_Main.NO_STYLE = true;
					__index += 0;
					break;
				case "--nothreads":
					if(__index > __args.length) {
						if(![][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
						}
					}
					_gthis.disableThreads = true;
					__index += 0;
					break;
				case "--progress":
					if(__index > __args.length) {
						if(![][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
						}
					}
					checkstyle_Main.SHOW_PROGRESS = true;
					__index += 0;
					break;
				case "--reporter":case "-r":
					if(__index + 1 > __args.length) {
						if(![false][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
						}
					}
					checkstyle_Main.REPORT_TYPE = __args[__index];
					++__index;
					break;
				case "--show-missing-checks":
					if(__index > __args.length) {
						if(![][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
						}
					}
					checkstyle_Main.SHOW_MISSING_CHECKS = true;
					__index += 0;
					break;
				case "--show-parser-errors":
					if(__index > __args.length) {
						if(![][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
						}
					}
					checkstyle_reporter_ReporterManager.SHOW_PARSE_ERRORS = true;
					__index += 0;
					break;
				case "--xslt":case "-x":
					if(__index + 1 > __args.length) {
						if(![false][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
						}
					}
					checkstyle_Main.STYLE = __args[__index];
					++__index;
					break;
				case "--config":case "-c":
					if(__index + 1 > __args.length) {
						if(![false][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
						}
					}
					_gthis.configPath = __args[__index];
					++__index;
					break;
				case "--exclude":case "-e":
					if(__index + 1 > __args.length) {
						if(![false][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
						}
					}
					_gthis.excludePath = __args[__index];
					++__index;
					break;
				case "--path":case "-p":
					if(__index + 1 > __args.length) {
						if(![false][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
						}
					}
					var path = __args[__index];
					checkstyle_Main.XML_PATH = path;
					checkstyle_Main.JSON_PATH = path;
					checkstyle_Main.TEXT_PATH = path;
					++__index;
					break;
				case "--source":case "-s":
					if(__index + 1 > __args.length) {
						if(![false][__args.length - 1]) {
							throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
						}
					}
					_gthis.configParser.paths.push(__args[__index]);
					++__index;
					break;
				default:
					var arg = _g;
					_gthis.failWith("Unknown command: " + arg);
				}
			}
		};
		if(args.length == 0) {
			var version = "2.7.0";
			process.stdout.write(Std.string("Haxe Checkstyle v" + version));
			process.stdout.write("\n");
			var v = argHandler_getDoc();
			process.stdout.write(Std.string(v));
			process.stdout.write("\n");
			process.exit(0);
		}
		argHandler_parse(args);
		if(checkstyle_Main.REPORT_TYPE == checkstyle_Main.CODE_CLIMATE_REPORTER) {
			var defaultConfig = JSON.parse(js_node_Fs.readFileSync("/config.json",{ encoding : "utf8"}));
			if(defaultConfig.include_paths != null && defaultConfig.include_paths.length > 0) {
				var _g = 0;
				var _g1 = defaultConfig.include_paths;
				while(_g < _g1.length) {
					var s = _g1[_g];
					++_g;
					if(s != ".codeclimate.yml") {
						this.configParser.paths.push("/code/" + s);
					}
				}
			} else {
				this.configParser.paths.push("/code");
			}
			this.configParser.validateMode = checkstyle_config_ConfigValidateMode.RELAXED;
			if(defaultConfig.config != null) {
				this.configPath = defaultConfig.config;
			}
			if(defaultConfig.exclude != null) {
				this.excludePath = defaultConfig.exclude;
			}
			if(this.configParser.paths.length > 0) {
				this.processArgs();
			}
		} else {
			this.processArgs();
		}
	}
	,processArgs: function() {
		if(this.configPath == null && sys_FileSystem.exists(checkstyle_Main.DEFAULT_CONFIG) && !sys_FileSystem.isDirectory(checkstyle_Main.DEFAULT_CONFIG)) {
			this.configPath = checkstyle_Main.DEFAULT_CONFIG;
		}
		if(this.excludePath == null && sys_FileSystem.exists(checkstyle_Main.DEFAULT_EXCLUDE_CONFIG) && !sys_FileSystem.isDirectory(checkstyle_Main.DEFAULT_EXCLUDE_CONFIG)) {
			this.excludePath = checkstyle_Main.DEFAULT_EXCLUDE_CONFIG;
		}
		this.configParser.loadConfig(this.configPath);
		if(this.excludePath != null) {
			this.configParser.loadExcludeConfig(this.excludePath);
		}
		this.start();
	}
	,createReporter: function(numFiles) {
		var totalChecks = this.configParser.getCheckCount();
		var checksUsed = this.configParser.getUsedCheckCount();
		switch(checkstyle_Main.REPORT_TYPE) {
		case "codeclimate":
			return new checkstyle_reporter_CodeClimateReporter(numFiles,totalChecks,checksUsed,null,checkstyle_Main.NO_STYLE);
		case "json":
			return new checkstyle_reporter_JSONReporter(numFiles,totalChecks,checksUsed,checkstyle_Main.JSON_PATH,checkstyle_Main.NO_STYLE);
		case "text":
			return new checkstyle_reporter_TextReporter(numFiles,totalChecks,checksUsed,checkstyle_Main.TEXT_PATH,checkstyle_Main.NO_STYLE);
		case "xml":
			return new checkstyle_reporter_XMLReporter(numFiles,totalChecks,checksUsed,checkstyle_Main.XML_PATH,checkstyle_Main.STYLE,checkstyle_Main.NO_STYLE);
		default:
			this.failWith("Unknown reporter: " + checkstyle_Main.REPORT_TYPE);
			return null;
		}
	}
	,listChecks: function() {
		var count = 0;
		var maxLength = 0;
		var checkList = this.configParser.getSortedCheckInfos();
		var _g = 0;
		while(_g < checkList.length) {
			var check = checkList[_g];
			++_g;
			if(check.name.length > maxLength) {
				maxLength = check.name.length;
			}
		}
		var _g = 0;
		while(_g < checkList.length) {
			var check = checkList[_g];
			++_g;
			var v = StringTools.rpad(check.name," ",maxLength + 2) + "- " + check.description;
			process.stdout.write(Std.string(v));
			process.stdout.write("\n");
			if(new EReg("\\[DEPRECATED","").match(check.description)) {
				continue;
			}
			++count;
		}
		process.stdout.write(Std.string("Total: " + count + " checks"));
		process.stdout.write("\n");
		process.exit(0);
	}
	,listReporters: function() {
		process.stdout.write("text - Text reporter (default)");
		process.stdout.write("\n");
		process.stdout.write("xml - XML reporter");
		process.stdout.write("\n");
		process.stdout.write("json - JSON reporter");
		process.stdout.write("\n");
		process.exit(0);
	}
	,generateDefaultConfig: function(path) {
		this.configParser.addAllChecks();
		checkstyle_utils_ConfigUtils.saveConfig(this.checker,path);
		process.exit(0);
	}
	,detectCodingStyle: function(path) {
		var checks = [];
		var checkInfo = this.configParser.info.checks();
		while(checkInfo.hasNext()) {
			var checkInfo1 = checkInfo.next();
			if(checkInfo1.isAlias) {
				continue;
			}
			var check = this.configParser.info.build(checkInfo1.name);
			checks.push(check);
		}
		var detectedChecks = checkstyle_detect_DetectCodingStyle.detectCodingStyle(checks,this.buildFileList());
		if(detectedChecks.length > 0) {
			checkstyle_utils_ConfigUtils.saveCheckConfigList(detectedChecks,path);
		}
		process.exit(0);
	}
	,start: function() {
		if(checkstyle_Main.SHOW_MISSING_CHECKS) {
			this.showMissingChecks();
			process.exit(0);
		}
		var toProcess = this.buildFileList();
		checkstyle_reporter_ReporterManager.INSTANCE.addReporter(this.createReporter(toProcess.length));
		if(checkstyle_Main.SHOW_PROGRESS) {
			checkstyle_reporter_ReporterManager.INSTANCE.addReporter(new checkstyle_reporter_ProgressReporter(toProcess.length));
		}
		if(checkstyle_Main.EXIT_CODE) {
			checkstyle_reporter_ReporterManager.INSTANCE.addReporter(new checkstyle_reporter_ExitCodeReporter());
		}
		this.checker.process(toProcess);
	}
	,buildFileList: function() {
		var files = [];
		var _g = 0;
		var _g1 = this.configParser.paths;
		while(_g < _g1.length) {
			var path = _g1[_g];
			++_g;
			this.traverse(path,files);
		}
		haxe_ds_ArraySort.sort(files,function(a,b) {
			if(a > b) {
				return 1;
			}
			if(a < b) {
				return -1;
			}
			return 0;
		});
		var i = 0;
		var _g = [];
		var _g1 = 0;
		while(_g1 < files.length) {
			var file = files[_g1];
			++_g1;
			_g.push({ name : file, content : null, index : i++});
		}
		return _g;
	}
	,traverse: function(path,files) {
		try {
			if(sys_FileSystem.isDirectory(path) && !checkstyle_config_ExcludeManager.isExcludedFromAll(path)) {
				var nodes = js_node_Fs.readdirSync(path);
				var _g = 0;
				while(_g < nodes.length) {
					var child = nodes[_g];
					++_g;
					this.traverse(haxe_io_Path.join([path,child]),files);
				}
			} else if(new EReg("(.hx)$","i").match(path) && !checkstyle_config_ExcludeManager.isExcludedFromAll(path)) {
				files.push(path);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			process.stdout.write(Std.string("\nPath " + path + " not found."));
			process.stdout.write("\n");
		}
	}
	,failWith: function(message) {
		if(checkstyle_Main.REPORT_TYPE == checkstyle_Main.CODE_CLIMATE_REPORTER) {
			return;
		}
		new _$Sys_FileOutput(2).writeString(message + "\n");
		process.exit(1);
	}
	,showMissingChecks: function() {
		var configuredChecks = [];
		var missingChecks = [];
		var _g = 0;
		var _g1 = this.checker.checks;
		while(_g < _g1.length) {
			var check = _g1[_g];
			++_g;
			configuredChecks.push(check.getModuleName());
		}
		var check = this.configParser.info.checks();
		while(check.hasNext()) {
			var check1 = check.next();
			if(configuredChecks.indexOf(check1.name) >= 0) {
				continue;
			}
			if(new EReg("\\[DEPRECATED","").match(check1.description)) {
				continue;
			}
			missingChecks.push(check1);
		}
		if(missingChecks.length <= 0) {
			process.stdout.write("You have no checks missing from your configuration");
			process.stdout.write("\n");
		} else {
			process.stdout.write("The following checks are missing from your configuration:");
			process.stdout.write("\n");
			var _g = 0;
			while(_g < missingChecks.length) {
				var check = missingChecks[_g];
				++_g;
				var v = check.name + " - " + check.description;
				process.stdout.write(Std.string(v));
				process.stdout.write("\n");
			}
		}
	}
	,__class__: checkstyle_Main
};
var checkstyle_checks_Check = function(type) {
	this.type = type;
	this.severity = "INFO";
	this.categories = ["Style"];
	this.points = 1;
	this.desc = haxe_rtti_Meta.getType(js_Boot.getClass(this)).desc[0];
};
$hxClasses["checkstyle.checks.Check"] = checkstyle_checks_Check;
checkstyle_checks_Check.__name__ = "checkstyle.checks.Check";
checkstyle_checks_Check.prototype = {
	severity: null
	,type: null
	,categories: null
	,points: null
	,desc: null
	,messages: null
	,moduleName: null
	,checker: null
	,reset: function() {
		this.messages = [];
	}
	,configureProperty: function(name,value) {
		this[name] = value;
	}
	,run: function(checker) {
		this.reset();
		this.checker = checker;
		if(this.severity != "IGNORE") {
			try {
				this.actualRun();
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				var _g1 = haxe_Exception.caught(_g).unwrap();
				if(typeof(_g1) == "string") {
					var e = _g1;
					checkstyle_utils_ErrorUtils.handleException(e,checker.file,this.getModuleName());
				} else {
					throw _g;
				}
			}
		}
		return this.messages;
	}
	,actualRun: function() {
		throw haxe_Exception.thrown("Unimplemented");
	}
	,logPos: function(msg,pos,code,sev) {
		this.logRange(msg,pos.min,pos.max,code,sev);
	}
	,logRange: function(msg,startPos,endPos,code,sev) {
		var lpStart = this.checker.getLinePos(startPos);
		var lpEnd = this.checker.getLinePos(endPos);
		var startColumn = this.offsetToColumn(lpStart);
		var endColumn = this.offsetToColumn(lpEnd);
		this.log(msg,lpStart.line + 1,startColumn,lpEnd.line + 1,endColumn,code,sev);
	}
	,offsetToColumn: function(lp) {
		if(this.checker.lines.length <= lp.line) {
			return lp.ofs;
		}
		var line = haxe_io_Bytes.ofString(this.checker.lines[lp.line]);
		return line.getString(0,lp.ofs).length;
	}
	,log: function(msg,startLine,startColumn,endLine,endColumn,code,sev) {
		if(sev == null) {
			sev = this.severity;
		}
		this.messages.push({ fileName : this.checker.file.name, message : msg, code : code, desc : this.desc, startLine : startLine, endLine : endLine, startColumn : startColumn, endColumn : endColumn, severity : sev, moduleName : this.getModuleName(), categories : this.categories, points : this.points});
	}
	,getModuleName: function() {
		if(this.moduleName == null) {
			this.moduleName = checkstyle_ChecksInfo.getCheckName(this);
		}
		return this.moduleName;
	}
	,forEachField: function(cb) {
		if(this.checker.ast == null) {
			return;
		}
		if(this.checker.ast.decls == null) {
			return;
		}
		var _g = 0;
		var _g1 = this.checker.ast.decls;
		while(_g < _g1.length) {
			var td = _g1[_g];
			++_g;
			var fields;
			var _g2 = td.decl;
			switch(_g2._hx_index) {
			case 0:
				var d = _g2.d;
				fields = d.data;
				break;
			case 3:
				var a = _g2.a;
				fields = a.data;
				break;
			default:
				fields = null;
			}
			if(fields == null) {
				continue;
			}
			var _g3 = 0;
			while(_g3 < fields.length) {
				var field = fields[_g3];
				++_g3;
				if(!this.isCheckSuppressed(field)) {
					cb(field,checkstyle_utils_FieldUtils.toParentType(td.decl));
				}
			}
		}
	}
	,isCheckSuppressed: function(f) {
		if(f == null) {
			return false;
		}
		return this.isPosSuppressed(f.pos);
	}
	,isLineSuppressed: function(i) {
		if(this.checker.linesIdx.length <= i) {
			return false;
		}
		return this.isCharPosSuppressed(this.checker.linesIdx[i].l);
	}
	,isPosExtern: function(pos) {
		return this.isCharPosExtern(pos.min);
	}
	,isPosSuppressed: function(pos) {
		return this.isCharPosSuppressed(pos.min);
	}
	,isCharPosSuppressed: function(pos) {
		var this1 = this.checker.excludesRanges;
		var key = this.getModuleName();
		var ranges = this1.h[key];
		if(ranges == null) {
			return false;
		}
		if(ranges.length <= 0) {
			return false;
		}
		var _g = 0;
		while(_g < ranges.length) {
			var range = ranges[_g];
			++_g;
			if(range.charPosStart <= pos && range.charPosEnd >= pos) {
				return true;
			}
		}
		return false;
	}
	,isCharPosExtern: function(pos) {
		if(this.checker.ast == null) {
			return false;
		}
		if(this.checker.ast.decls == null) {
			return false;
		}
		var _g = 0;
		var _g1 = this.checker.ast.decls;
		while(_g < _g1.length) {
			var td = _g1[_g];
			++_g;
			var _g2 = td.decl;
			switch(_g2._hx_index) {
			case 0:
				var d = _g2.d;
				if(pos <= td.pos.max && pos >= td.pos.min) {
					return d.flags.indexOf(haxeparser_ClassFlag.HExtern) != -1;
				}
				break;
			case 1:
				var d1 = _g2.d;
				if(pos <= td.pos.max && pos >= td.pos.min) {
					return d1.flags.indexOf(haxeparser_EnumFlag.EExtern) != -1;
				}
				break;
			case 2:
				var d2 = _g2.d;
				if(pos <= td.pos.max && pos >= td.pos.min) {
					return d2.flags.indexOf(haxeparser_EnumFlag.EExtern) != -1;
				}
				var _g3 = d2.data;
				if(_g3._hx_index == 2) {
					var fields = _g3.fields;
					var _g4 = 0;
					while(_g4 < fields.length) {
						var field = fields[_g4];
						++_g4;
						if(pos > field.pos.max) {
							continue;
						}
						if(pos < field.pos.min) {
							continue;
						}
						return d2.flags.indexOf(haxeparser_EnumFlag.EExtern) != -1;
					}
				}
				break;
			case 3:
				var d3 = _g2.a;
				break;
			default:
			}
		}
		return false;
	}
	,checkSuppressionConst: function(e,search) {
		var _g = e.expr;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			if(c._hx_index == 2) {
				var _g1 = c.kind;
				var s = c.s;
				if(s == search) {
					return true;
				}
			}
			break;
		case 6:
			var a = _g.values;
			var _g = 0;
			while(_g < a.length) {
				var e1 = a[_g];
				++_g;
				if(this.checkSuppressionConst(e1,search)) {
					return true;
				}
			}
			break;
		default:
		}
		return false;
	}
	,detectableInstances: function() {
		return [];
	}
	,__class__: checkstyle_checks_Check
};
var checkstyle_checks_CheckType = $hxEnums["checkstyle.checks.CheckType"] = { __ename__ : true, __constructs__ : ["AST","TOKEN","LINE"]
	,AST: {_hx_index:0,__enum__:"checkstyle.checks.CheckType",toString:$estr}
	,TOKEN: {_hx_index:1,__enum__:"checkstyle.checks.CheckType",toString:$estr}
	,LINE: {_hx_index:2,__enum__:"checkstyle.checks.CheckType",toString:$estr}
};
var checkstyle_checks_block_BlockBreakingConditionalCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
};
$hxClasses["checkstyle.checks.block.BlockBreakingConditionalCheck"] = checkstyle_checks_block_BlockBreakingConditionalCheck;
checkstyle_checks_block_BlockBreakingConditionalCheck.__name__ = "checkstyle.checks.block.BlockBreakingConditionalCheck";
checkstyle_checks_block_BlockBreakingConditionalCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_block_BlockBreakingConditionalCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var root = this.checker.getTokenTree();
		var allBrs = root.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 17:case 18:
				return tokentree_FilterResult.FoundGoDeeper;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allBrs.length) {
			var br = allBrs[_g];
			++_g;
			if(this.isPosSuppressed(br.pos)) {
				continue;
			}
			switch(br.tok._hx_index) {
			case 17:
				if(tokentree_TokenTreeAccessHelper.firstOf(br,tokentree_TokenTreeDef.BrClose) != null) {
					continue;
				}
				this.logPos("Left curly has no matching right curly",br.pos);
				break;
			case 18:
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(br),tokentree_TokenTreeDef.BrOpen) != null) {
					continue;
				}
				this.logPos("Right curly has no matching left curly",br.pos);
				break;
			default:
				continue;
			}
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_block_BlockBreakingConditionalCheck
});
var checkstyle_checks_block_ConditionalCompilationCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.policy = "aligned";
	this.allowSingleline = true;
};
$hxClasses["checkstyle.checks.block.ConditionalCompilationCheck"] = checkstyle_checks_block_ConditionalCompilationCheck;
checkstyle_checks_block_ConditionalCompilationCheck.__name__ = "checkstyle.checks.block.ConditionalCompilationCheck";
checkstyle_checks_block_ConditionalCompilationCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_block_ConditionalCompilationCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	policy: null
	,allowSingleline: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		this.checkSharpIf(root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		}));
	}
	,checkSharpIf: function(tokens) {
		var _g = 0;
		while(_g < tokens.length) {
			var tok = tokens[_g];
			++_g;
			if(this.isPosSuppressed(tok.pos)) {
				continue;
			}
			var linePos = this.checker.getLinePos(tok.pos.min);
			if(this.checkSingleLine(tok,linePos.line)) {
				continue;
			}
			this.checkMultiLine(tok,linePos);
		}
	}
	,checkSingleLine: function(tok,line) {
		var endTok = null;
		var _g = 0;
		var _g1 = tok.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 3) {
				if(_g2.s == "end") {
					endTok = child;
					break;
				}
			}
		}
		if(endTok == null) {
			return true;
		}
		var endPos = this.checker.getLinePos(endTok.pos.min);
		var singleLine = endPos.line == line;
		if(!singleLine) {
			return false;
		}
		if(singleLine && this.allowSingleline) {
			return true;
		}
		this.logPos("Single line #if…(#else/#elseif)…#end not allowed",tok.pos);
		return true;
	}
	,checkMultiLine: function(tok,linePos) {
		var line = haxe_io_Bytes.ofString(this.checker.lines[linePos.line]);
		var prefix = line.sub(0,linePos.ofs).toString();
		if(this.checkLine(tok,linePos,line)) {
			return;
		}
		switch(this.policy) {
		case "aligned":
			if(this.checkIndentation(tok,linePos)) {
				return;
			}
			break;
		case "startOfLine":
			if(linePos.ofs != 0) {
				this.logPos("#if should start at beginning of line",tok.pos);
				return;
			}
			break;
		}
		var _g = 0;
		var _g1 = tok.children;
		while(_g < _g1.length) {
			var childTok = _g1[_g];
			++_g;
			var _g2 = childTok.tok;
			if(_g2._hx_index == 3) {
				switch(_g2.s) {
				case "else":case "elseif":case "end":
					var childLinePos = this.checker.getLinePos(childTok.pos.min);
					var childLine = haxe_io_Bytes.ofString(this.checker.lines[childLinePos.line]);
					var childPrefix = childLine.sub(0,childLinePos.ofs).toString();
					if(this.checkLine(childTok,childLinePos,childLine)) {
						continue;
					}
					if(childPrefix == prefix) {
						continue;
					}
					this.logPos("Indentation of " + Std.string(childTok) + " must match corresponding #if",childTok.pos);
					break;
				default:
				}
			}
		}
	}
	,checkLine: function(tok,linePos,line) {
		var r = new EReg("^[ \t]*$","");
		var prefix = line.sub(0,linePos.ofs).toString();
		if(!r.match(prefix)) {
			this.logPos("only whitespace allowed before " + Std.string(tok),tok.pos);
			return true;
		}
		var expr = tok.getFirstChild();
		if(expr == null) {
			return false;
		}
		var linePosAfter = this.checker.getLinePos(expr.getPos().max);
		if(linePosAfter.line == linePos.line) {
			var postfix = line.sub(linePosAfter.ofs,line.length - linePosAfter.ofs).toString();
			if(!r.match(postfix)) {
				this.logPos("only whitespace allowed after " + Std.string(tok),tok.pos);
				return true;
			}
		}
		return false;
	}
	,checkIndentation: function(tok,linePos) {
		var prevLen = -1;
		var nextLen = -1;
		var lineIndex = linePos.line - 1;
		while(lineIndex >= 0) {
			var line = this.checker.lines[lineIndex];
			prevLen = this.getIndentLength(line);
			if(prevLen >= 0) {
				break;
			}
			--lineIndex;
		}
		var lineIndex = linePos.line + 1;
		while(lineIndex < this.checker.lines.length - 1) {
			var line = this.checker.lines[lineIndex];
			nextLen = this.getIndentLength(line);
			if(nextLen >= 0) {
				break;
			}
			++lineIndex;
		}
		if(prevLen < 0) {
			prevLen = linePos.ofs;
		}
		if(nextLen < 0) {
			nextLen = linePos.ofs;
		}
		if(linePos.ofs >= prevLen && linePos.ofs <= nextLen) {
			return false;
		}
		this.logPos("Indentation of " + Std.string(tok) + " should match surrounding lines",tok.pos);
		return true;
	}
	,getIndentLength: function(line) {
		if(new EReg("^[ \t]*$","").match(line)) {
			return -1;
		}
		var r = new EReg("^([ \t]*)","");
		if(r.match(line)) {
			var prefix = r.matched(1);
			return prefix.length;
		}
		return -1;
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "policy", values : ["startOfLine","aligned"]},{ propertyName : "allowSingleline", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_block_ConditionalCompilationCheck
});
var checkstyle_checks_block_EmptyBlockCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.tokens = ["CLASS_DEF","ENUM_DEF","ABSTRACT_DEF","TYPEDEF_DEF","INTERFACE_DEF","OBJECT_DECL","FUNCTION","FOR","IF","WHILE","SWITCH","TRY","CATCH"];
	this.option = "empty";
};
$hxClasses["checkstyle.checks.block.EmptyBlockCheck"] = checkstyle_checks_block_EmptyBlockCheck;
checkstyle_checks_block_EmptyBlockCheck.__name__ = "checkstyle.checks.block.EmptyBlockCheck";
checkstyle_checks_block_EmptyBlockCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_block_EmptyBlockCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	tokens: null
	,option: null
	,hasToken: function(token) {
		if(this.tokens.length != 0) {
			return this.tokens.indexOf(token) != -1;
		} else {
			return true;
		}
	}
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var allBrOpen = root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 17) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allBrOpen.length) {
			var brOpen = allBrOpen[_g];
			++_g;
			if(this.isPosSuppressed(brOpen.pos)) {
				continue;
			}
			if(this.filterParentToken(brOpen.parent)) {
				continue;
			}
			switch(this.option) {
			case "empty":
				this.checkForEmpty(brOpen);
				break;
			case "stmt":
				this.checkForStatement(brOpen);
				break;
			case "text":
				this.checkForText(brOpen);
				break;
			default:
				this.checkForText(brOpen);
			}
		}
	}
	,filterParentToken: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return !this.hasToken("FUNCTION");
			case 1:
				return !this.hasToken("CLASS_DEF");
			case 3:case 4:
				return !this.hasToken("IF");
			case 5:
				return !this.hasToken("WHILE");
			case 7:
				return !this.hasToken("FOR");
			case 10:
				return !this.hasToken("OBJECT_DECL");
			case 14:case 15:case 16:
				return !this.hasToken("SWITCH");
			case 20:
				return !this.hasToken("TRY");
			case 21:
				return !this.hasToken("CATCH");
			case 26:
				return !this.hasToken("ENUM_DEF");
			case 27:
				return !this.hasToken("INTERFACE_DEF");
			case 31:
				return !this.hasToken("TYPEDEF_DEF");
			case 39:
				return !this.hasToken("ABSTRACT_DEF");
			default:
				return this.filterParentToken(token.parent);
			}
			break;
		case 4:
			var _g1 = _g.s;
			return !this.hasToken("REIFICATION");
		case 6:
			if(_g.op._hx_index == 4) {
				if(token.parent != null && token.parent.parent != null) {
					var _g = token.parent.parent.tok;
					if(_g._hx_index == 1) {
						if(_g.k._hx_index == 31) {
							return !this.hasToken("TYPEDEF_DEF");
						}
					}
				}
				return !this.hasToken("OBJECT_DECL");
			} else {
				return this.filterParentToken(token.parent);
			}
			break;
		case 15:case 17:case 19:
			return !this.hasToken("OBJECT_DECL");
		default:
			return this.filterParentToken(token.parent);
		}
	}
	,checkForText: function(brOpen) {
		if(brOpen.children.length == 1) {
			this.logPos("Empty block should contain a comment or a statement",brOpen.getPos());
			return;
		}
		var lastChild = brOpen.getLastChild();
		if(brOpen.children.length == 2 && lastChild.matches(tokentree_TokenTreeDef.Semicolon)) {
			this.logPos("Empty block should contain a comment or a statement",brOpen.getPos());
			return;
		}
	}
	,checkForStatement: function(brOpen) {
		if(brOpen.children.length == 1) {
			this.logPos("Empty block should contain a statement",brOpen.getPos());
			return;
		}
		var lastChild = brOpen.getLastChild();
		if(brOpen.children.length == 2 && lastChild.matches(tokentree_TokenTreeDef.Semicolon)) {
			this.logPos("Empty block should contain a statement",brOpen.getPos());
			return;
		}
		var onlyComments = true;
		var _g = 0;
		var _g1 = brOpen.children;
		_hx_loop1: while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 7:
				var _g3 = _g2.s;
				break;
			case 8:
				var _g4 = _g2.s;
				break;
			case 18:
				break _hx_loop1;
			default:
				onlyComments = false;
				break _hx_loop1;
			}
		}
		if(onlyComments) {
			this.logPos("Block should contain a statement",brOpen.getPos());
		}
	}
	,checkForEmpty: function(brOpen) {
		if(brOpen.children == null) {
			return;
		}
		if(brOpen.children.length <= 0) {
			return;
		}
		var lastChild = brOpen.getLastChild();
		if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(brOpen),tokentree_TokenTreeDef.Semicolon) != null) {
			if(brOpen.children.length > 2) {
				return;
			}
		} else if(brOpen.children.length > 1) {
			return;
		}
		var brClose = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(brOpen),tokentree_TokenTreeDef.BrClose);
		if(brClose == null) {
			return;
		}
		if(brOpen.pos.max != brClose.pos.min) {
			this.logPos("Empty block should be written as \"{}\"",brOpen.getPos());
		}
	}
	,__class__: checkstyle_checks_block_EmptyBlockCheck
});
var checkstyle_checks_block_LeftCurlyCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.tokens = ["CLASS_DEF","ENUM_DEF","ABSTRACT_DEF","TYPEDEF_DEF","INTERFACE_DEF","FUNCTION","FOR","IF","WHILE","SWITCH","TRY","CATCH"];
	this.option = "eol";
	this.ignoreEmptySingleline = true;
	this.ignoreSingleline = false;
};
$hxClasses["checkstyle.checks.block.LeftCurlyCheck"] = checkstyle_checks_block_LeftCurlyCheck;
checkstyle_checks_block_LeftCurlyCheck.__name__ = "checkstyle.checks.block.LeftCurlyCheck";
checkstyle_checks_block_LeftCurlyCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_block_LeftCurlyCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	tokens: null
	,option: null
	,ignoreEmptySingleline: null
	,ignoreSingleline: null
	,hasToken: function(token) {
		if(this.tokens.length != 0) {
			return this.tokens.indexOf(token) != -1;
		} else {
			return true;
		}
	}
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var allBrOpen = root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 17) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allBrOpen.length) {
			var brOpen = allBrOpen[_g];
			++_g;
			if(this.isPosSuppressed(brOpen.pos)) {
				continue;
			}
			if(this.skipSingleLine(brOpen)) {
				continue;
			}
			var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				if(!this.hasToken("TYPEDEF_DEF")) {
					continue;
				}
				break;
			case 2:
				if(!this.hasToken("OBJECT_DECL")) {
					continue;
				}
				break;
			case 3:
				if(!this.hasToken("ANON_TYPE")) {
					continue;
				}
				break;
			case 4:
				break;
			}
			var parent = this.findParentToken(brOpen.parent);
			if(!parent.hasToken) {
				continue;
			}
			this.check(brOpen,this.isParentWrapped(parent.token,brOpen));
		}
	}
	,skipSingleLine: function(brOpen) {
		var brClose = tokentree_TokenTreeAccessHelper.firstOf(brOpen,tokentree_TokenTreeDef.BrClose);
		if(brClose == null) {
			return false;
		}
		if(this.ignoreEmptySingleline && brOpen.pos.max == brClose.pos.min) {
			return true;
		}
		var lStart = this.checker.getLinePos(brOpen.pos.min).line;
		var lEnd = this.checker.getLinePos(brClose.pos.min).line;
		if(this.ignoreSingleline && lStart == lEnd) {
			return true;
		}
		return false;
	}
	,findParentToken: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return { token : token, hasToken : false};
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return { token : token, hasToken : this.hasToken("FUNCTION")};
			case 1:
				return { token : token, hasToken : this.hasToken("CLASS_DEF")};
			case 3:case 4:
				return { token : token, hasToken : this.hasToken("IF")};
			case 5:
				return { token : token, hasToken : this.hasToken("WHILE")};
			case 7:
				if(this.isArrayComprehension(token.parent)) {
					return { token : token, hasToken : this.hasToken("ARRAY_COMPREHENSION")};
				}
				return { token : token, hasToken : this.hasToken("FOR")};
			case 10:
				return { token : token, hasToken : this.hasToken("OBJECT_DECL")};
			case 15:
				return { token : token, hasToken : this.hasToken("OBJECT_DECL")};
			case 14:case 16:
				return { token : token, hasToken : this.hasToken("SWITCH")};
			case 20:
				return { token : token, hasToken : this.hasToken("TRY")};
			case 21:
				return { token : token, hasToken : this.hasToken("CATCH")};
			case 26:
				return { token : token, hasToken : this.hasToken("ENUM_DEF")};
			case 27:
				return { token : token, hasToken : this.hasToken("INTERFACE_DEF")};
			case 31:
				return { token : token, hasToken : this.hasToken("TYPEDEF_DEF")};
			case 39:
				return { token : token, hasToken : this.hasToken("ABSTRACT_DEF")};
			default:
				return this.findParentToken(token.parent);
			}
			break;
		case 4:
			var _g1 = _g.s;
			return { token : token, hasToken : this.hasToken("REIFICATION")};
		case 6:
			if(_g.op._hx_index == 4) {
				if(token.parent != null && token.parent.parent != null) {
					var _g = token.parent.parent.tok;
					if(_g._hx_index == 1 && _g.k._hx_index == 31) {
						return { token : token, hasToken : this.hasToken("TYPEDEF_DEF")};
					}
				}
				return { token : token, hasToken : this.hasToken("OBJECT_DECL")};
			} else {
				return this.findParentToken(token.parent);
			}
			break;
		case 12:
			return this.findParentTokenDblDot(token);
		case 15:case 17:case 19:
			return { token : token, hasToken : this.hasToken("OBJECT_DECL")};
		default:
			return this.findParentToken(token.parent);
		}
	}
	,findParentTokenDblDot: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return { token : token, hasToken : false};
		}
		var type = tokentree_utils_TokenTreeCheckUtils.getColonType(token);
		switch(type._hx_index) {
		case 0:
			return { token : token, hasToken : this.hasToken("SWITCH")};
		case 1:
			return { token : token, hasToken : this.hasToken("TYPEDEF_DEF")};
		case 2:
			return { token : token, hasToken : this.hasToken("TYPEDEF_DEF")};
		case 3:
			return { token : token, hasToken : false};
		case 4:
			return { token : token, hasToken : this.hasToken("OBJECT_DECL")};
		case 5:
			return { token : token, hasToken : false};
		case 6:
			return { token : token, hasToken : false};
		}
	}
	,isParentWrapped: function(parent,brOpen) {
		var lineNumStart = this.checker.getLinePos(parent.pos.min).line;
		var previous = brOpen.previousSibling;
		_hx_loop1: while(previous != null) {
			var _g = previous.tok;
			switch(_g._hx_index) {
			case 7:
				var _g1 = _g.s;
				previous = previous.previousSibling;
				break;
			case 8:
				var _g2 = _g.s;
				previous = previous.previousSibling;
				break;
			case 22:
				previous = previous.previousSibling;
				break;
			default:
				break _hx_loop1;
			}
		}
		var lineNumEnd;
		if(previous == null) {
			lineNumEnd = this.checker.getLinePos(brOpen.parent.pos.max).line;
		} else {
			lineNumEnd = this.checker.getLinePos(previous.getPos().max).line;
		}
		return lineNumStart != lineNumEnd;
	}
	,isArrayComprehension: function(token) {
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return false;
			case 2:
				return false;
			default:
				return this.isArrayComprehension(token.parent);
			}
			break;
		case 15:
			return true;
		default:
			return this.isArrayComprehension(token.parent);
		}
	}
	,check: function(token,wrapped) {
		var lineNum = this.checker.getLinePos(token.pos.min).line;
		var line = this.checker.lines[lineNum];
		this.checkLeftCurly(line,wrapped,token.pos);
	}
	,checkLeftCurly: function(line,wrapped,pos) {
		if(wrapped == null) {
			wrapped = false;
		}
		var curlyAtEOL = new EReg("^\\s*\\S.*\\{\\s*(|/\\*.*|//.*)$","").match(line);
		var curlyOnNL = new EReg("^\\s*\\{","").match(line);
		try {
			if(curlyAtEOL) {
				this.logErrorIf(this.option == "nl","Left curly should be on new line (only whitespace before curly)",pos);
				this.logErrorIf(this.option == "nlow" && wrapped,"Left curly should be on new line (previous expression is split over multiple lines)",pos);
				this.logErrorIf(this.option != "eol" && this.option != "nlow","Left curly unknown option ${option}",pos);
				return;
			}
			this.logErrorIf(this.option == "eol","Left curly should be at EOL (only line break or comment after curly)",pos);
			this.logErrorIf(!curlyOnNL,"Left curly should be on new line (only whitespace before curly)",pos);
			this.logErrorIf(this.option == "nlow" && !wrapped,"Left curly should be at EOL (previous expression is not split over multiple lines)",pos);
			this.logErrorIf(this.option != "nl" && this.option != "nlow","Left curly unknown option ${option}",pos);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(typeof(haxe_Exception.caught(_g).unwrap()) != "string") {
				throw _g;
			}
		}
	}
	,logErrorIf: function(condition,msg,pos) {
		if(condition) {
			this.logPos(msg,pos);
			throw haxe_Exception.thrown("exit");
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [{ propertyName : "tokens", value : ["CLASS_DEF","ENUM_DEF","ABSTRACT_DEF","INTERFACE_DEF","FUNCTION","FOR","IF","WHILE","SWITCH","TRY","CATCH"]}], properties : [{ propertyName : "option", values : ["eol","nlow","nl"]},{ propertyName : "ignoreEmptySingleline", values : [true,false]},{ propertyName : "ignoreSingleline", values : [true,false]}]},{ fixed : [{ propertyName : "tokens", value : ["TYPEDEF_DEF"]}], properties : [{ propertyName : "option", values : ["eol","nlow","nl"]},{ propertyName : "ignoreEmptySingleline", values : [true,false]},{ propertyName : "ignoreSingleline", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_block_LeftCurlyCheck
});
var checkstyle_checks_block_NeedBracesCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.tokens = ["FOR","IF","ELSE_IF","WHILE","DO_WHILE"];
	this.allowSingleLineStatement = true;
};
$hxClasses["checkstyle.checks.block.NeedBracesCheck"] = checkstyle_checks_block_NeedBracesCheck;
checkstyle_checks_block_NeedBracesCheck.__name__ = "checkstyle.checks.block.NeedBracesCheck";
checkstyle_checks_block_NeedBracesCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_block_NeedBracesCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	tokens: null
	,allowSingleLineStatement: null
	,hasToken: function(token) {
		if(this.tokens.length != 0) {
			return this.tokens.indexOf(token) != -1;
		} else {
			return true;
		}
	}
	,actualRun: function() {
		var wantFunction = this.hasToken("FUNCTION");
		var wantFor = this.hasToken("FOR");
		var wantIf = this.hasToken("IF");
		var wantWhile = this.hasToken("WHILE");
		var wantDoWhile = this.hasToken("DO_WHILE");
		var wantCatch = this.hasToken("CATCH");
		if(!(wantFunction || wantFor || wantIf || wantWhile || wantDoWhile || wantCatch)) {
			return;
		}
		var root = this.checker.getTokenTree();
		var allTokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					if(wantFunction) {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 3:case 4:
					if(wantIf) {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 5:
					if(wantWhile) {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 6:
					if(wantDoWhile) {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 7:
					if(wantFor) {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 21:
					if(wantCatch) {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allTokens.length) {
			var tok = allTokens[_g];
			++_g;
			if(this.isPosSuppressed(tok.pos)) {
				continue;
			}
			var _g1 = tok.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 0:
					this.checkFunctionChild(tok);
					break;
				case 3:
					this.checkIfChild(tok);
					break;
				case 4:
					var firstChild = tok.getFirstChild();
					if(firstChild == null) {
						continue;
					}
					if(firstChild.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf))) {
						this.checkIfChild(firstChild);
					} else {
						this.checkLastChild(tok);
					}
					break;
				case 5:
					this.checkWhileChild(tok);
					break;
				case 6:
					this.checkLastChild(tok);
					break;
				default:
					this.checkLastChild(tok);
				}
			} else {
				this.checkLastChild(tok);
			}
		}
	}
	,checkIfChild: function(token) {
		if(token == null || !token.hasChildren()) {
			return;
		}
		var lastChild = token.getLastChild();
		if(Type.enumEq(lastChild.tok,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse))) {
			lastChild = lastChild.previousSibling;
		}
		switch(lastChild.tok._hx_index) {
		case 17:case 19:
			return;
		default:
			this.checkNoBraces(token,lastChild);
		}
	}
	,checkFunctionChild: function(token) {
		if(token == null || !token.hasChildren()) {
			return;
		}
		var body = token;
		if(token.children.length == 1) {
			body = token.getFirstChild();
		}
		body = tokentree_TokenTreeAccessHelper.firstOf(body,tokentree_TokenTreeDef.POpen);
		if(body == null || body.nextSibling == null) {
			return;
		}
		body = body.nextSibling;
		if(body.matches(tokentree_TokenTreeDef.DblDot)) {
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild.matches(tokentree_TokenTreeDef.Semicolon)) {
				return;
			}
			body = body.nextSibling;
		}
		if(body == null || body.matches(tokentree_TokenTreeDef.BrOpen)) {
			return;
		}
		this.checkNoBraces(token,body);
	}
	,checkWhileChild: function(token) {
		if(token == null || !token.hasChildren() || Type.enumEq(token.parent.tok,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo))) {
			return;
		}
		this.checkLastChild(token);
	}
	,checkLastChild: function(token) {
		if(token == null || !token.hasChildren()) {
			return;
		}
		var lastChild = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BrOpen);
		if(lastChild != null) {
			return;
		}
		lastChild = tokentree_TokenTreeAccessHelper.lastChild(token);
		this.checkNoBraces(token,lastChild);
	}
	,checkNoBraces: function(parent,child) {
		if(parent == null || child == null) {
			return;
		}
		var minLine = this.checker.getLinePos(parent.pos.min);
		var maxLine = this.checker.getLinePos(child.getPos().max);
		var singleLine = minLine.line == maxLine.line;
		if(this.allowSingleLineStatement) {
			if(singleLine) {
				return;
			}
			if(this.checkIfElseSingleline(parent,child)) {
				return;
			}
		} else if(singleLine) {
			this.logPos("Body of \"" + Std.string(parent) + "\" on same line",child.getPos());
			return;
		}
		this.logPos("No braces used for body of \"" + Std.string(parent) + "\"",child.getPos());
	}
	,checkIfElseSingleline: function(parent,child) {
		if(!this.hasToken("ELSE_IF")) {
			return false;
		}
		var _g = parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index != 4) {
				return false;
			}
		} else {
			return false;
		}
		var _g = child.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index != 3) {
				return false;
			}
		} else {
			return false;
		}
		var minLine = this.checker.getLinePos(parent.pos.min);
		var maxLine = this.checker.getLinePos(child.getFirstChild().getPos().max);
		return minLine.line == maxLine.line;
	}
	,__class__: checkstyle_checks_block_NeedBracesCheck
});
var checkstyle_checks_block_RightCurlyCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.tokens = ["CLASS_DEF","ENUM_DEF","ABSTRACT_DEF","TYPEDEF_DEF","INTERFACE_DEF","OBJECT_DECL","FUNCTION","FOR","IF","WHILE","SWITCH","TRY","CATCH"];
	this.option = "aloneorsingle";
};
$hxClasses["checkstyle.checks.block.RightCurlyCheck"] = checkstyle_checks_block_RightCurlyCheck;
checkstyle_checks_block_RightCurlyCheck.__name__ = "checkstyle.checks.block.RightCurlyCheck";
checkstyle_checks_block_RightCurlyCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_block_RightCurlyCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	tokens: null
	,option: null
	,hasToken: function(token) {
		if(this.tokens.length != 0) {
			return this.tokens.indexOf(token) != -1;
		} else {
			return true;
		}
	}
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var allBrClose = root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 18) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allBrClose.length) {
			var brClose = allBrClose[_g];
			++_g;
			if(this.isPosSuppressed(brClose.pos)) {
				continue;
			}
			var brOpen = brClose.parent;
			if(brOpen == null || brOpen.pos == null) {
				continue;
			}
			var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				if(!this.hasToken("TYPEDEF_DEF")) {
					continue;
				}
				break;
			case 2:
				if(!this.hasToken("OBJECT_DECL")) {
					continue;
				}
				break;
			case 3:
				break;
			case 4:
				break;
			}
			if(this.filterParentToken(brOpen.parent)) {
				continue;
			}
			this.check(brClose,type,this.isSingleLine(brOpen.pos.min,brClose.pos.max));
		}
	}
	,filterParentToken: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return !this.hasToken("FUNCTION");
			case 1:
				return !this.hasToken("CLASS_DEF");
			case 3:case 4:
				return !this.hasToken("IF");
			case 5:
				return !this.hasToken("WHILE");
			case 7:
				if(this.isArrayComprehension(token.parent)) {
					return !this.hasToken("ARRAY_COMPREHENSION");
				}
				return !this.hasToken("FOR");
			case 10:
				return false;
			case 14:case 15:case 16:
				return !this.hasToken("SWITCH");
			case 20:
				return !this.hasToken("TRY");
			case 21:
				return !this.hasToken("CATCH");
			case 26:
				return !this.hasToken("ENUM_DEF");
			case 27:
				return !this.hasToken("INTERFACE_DEF");
			case 31:
				return false;
			case 39:
				return !this.hasToken("ABSTRACT_DEF");
			default:
				return this.filterParentToken(token.parent);
			}
			break;
		case 4:
			var _g1 = _g.s;
			return !this.hasToken("REIFICATION");
		case 6:
			if(_g.op._hx_index == 4) {
				return false;
			} else {
				return this.filterParentToken(token.parent);
			}
			break;
		case 15:case 17:case 19:
			return false;
		default:
			return this.filterParentToken(token.parent);
		}
	}
	,isArrayComprehension: function(token) {
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return false;
			case 2:
				return false;
			default:
				return this.isArrayComprehension(token.parent);
			}
			break;
		case 15:
			return true;
		default:
			return this.isArrayComprehension(token.parent);
		}
	}
	,check: function(token,type,singleLine) {
		var lineNum = this.checker.getLinePos(token.pos.min).line;
		var line = this.checker.lines[lineNum];
		this.checkRightCurly(line,type,singleLine,token.pos);
	}
	,isSingleLine: function(start,end) {
		var startLine = this.checker.getLinePos(start).line;
		if(end >= this.checker.file.content.length) {
			end = this.checker.file.content.length - 1;
		}
		var endLine = this.checker.getLinePos(end).line;
		return startLine == endLine;
	}
	,checkRightCurly: function(line,type,singleLine,pos) {
		try {
			var curlyPos = { file : pos.file, min : pos.min, max : pos.max};
			var eof = false;
			if(curlyPos.max >= this.checker.file.content.length) {
				curlyPos.max = this.checker.file.content.length - 1;
				eof = true;
			}
			var linePos = this.checker.getLinePos(curlyPos.max);
			var afterCurly = "";
			if(!eof) {
				var afterLine = haxe_io_Bytes.ofString(this.checker.lines[linePos.line]);
				if(linePos.ofs < afterLine.length) {
					afterCurly = afterLine.sub(linePos.ofs,afterLine.length - linePos.ofs).toString();
				}
			}
			var sameRegex = new EReg("^\\s*(else|catch)","");
			var needsSameOption = sameRegex.match(afterCurly);
			var shouldHaveSameOption = false;
			if(this.checker.lines.length > linePos.line + 1) {
				var nextLine = this.checker.lines[linePos.line + 1];
				shouldHaveSameOption = sameRegex.match(nextLine);
			}
			curlyPos.min = curlyPos.max;
			this.logErrorIf(singleLine && this.option != "aloneorsingle","Right curly should not be on same line as left curly",curlyPos);
			if(singleLine) {
				return;
			}
			var curlyAlone = false;
			switch(type._hx_index) {
			case 0:case 1:case 4:
				curlyAlone = new EReg("^\\s*\\}(|\\..*|\\).*|\\].*|,\\s*|;\\s*)(|//.*)$","").match(line);
				break;
			case 2:case 3:
				curlyAlone = new EReg("^\\s*\\}(|\\..*|\\).*|\\].*|,.*|;\\s*)(|//.*)$","").match(line);
				break;
			}
			this.logErrorIf(!curlyAlone && (this.option == "aloneorsingle" || this.option == "alone"),"Right curly should be alone on a new line",curlyPos);
			this.logErrorIf(curlyAlone && needsSameOption,"Right curly should be alone on a new line",curlyPos);
			this.logErrorIf(needsSameOption && this.option != "same","Right curly must not be on same line as following block",curlyPos);
			this.logErrorIf(shouldHaveSameOption && this.option == "same","Right curly should be on same line as following block (e.g. \"} else\" or \"} catch\")",curlyPos);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(typeof(haxe_Exception.caught(_g).unwrap()) != "string") {
				throw _g;
			}
		}
	}
	,logErrorIf: function(condition,msg,pos) {
		if(condition) {
			this.logPos(msg,pos);
			throw haxe_Exception.thrown("exit");
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [{ propertyName : "tokens", value : ["CLASS_DEF","ENUM_DEF","ABSTRACT_DEF","TYPEDEF_DEF","INTERFACE_DEF","OBJECT_DECL","FUNCTION","FOR","WHILE","SWITCH","TRY","CATCH"]}], properties : [{ propertyName : "option", values : ["aloneorsingle","alone","same"]}]},{ fixed : [{ propertyName : "tokens", value : ["IF"]}], properties : [{ propertyName : "option", values : ["aloneorsingle","alone","same"]}]},{ fixed : [{ propertyName : "tokens", value : ["OBJECT_DECL"]}], properties : [{ propertyName : "option", values : ["aloneorsingle","alone","same"]}]}];
	}
	,__class__: checkstyle_checks_block_RightCurlyCheck
});
var checkstyle_checks_coding_ArrowFunctionCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.allowReturn = false;
	this.allowFunction = false;
	this.allowCurlyBody = false;
	this.allowSingleArgParens = false;
	this.categories = ["Style"];
};
$hxClasses["checkstyle.checks.coding.ArrowFunctionCheck"] = checkstyle_checks_coding_ArrowFunctionCheck;
checkstyle_checks_coding_ArrowFunctionCheck.__name__ = "checkstyle.checks.coding.ArrowFunctionCheck";
checkstyle_checks_coding_ArrowFunctionCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_ArrowFunctionCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	allowReturn: null
	,allowFunction: null
	,allowCurlyBody: null
	,allowSingleArgParens: null
	,actualRun: function() {
		var _gthis = this;
		var root = this.checker.getTokenTree();
		var arrowTokens = root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 13) {
				var arrowTokens = _gthis.isPosSuppressed(token.pos);
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < arrowTokens.length) {
			var token = arrowTokens[_g];
			++_g;
			var type = tokentree_utils_TokenTreeCheckUtils.determineArrowType(token);
			switch(type._hx_index) {
			case 0:
				this.checkArrowFunction(token);
				break;
			case 1:case 2:
				continue;
			}
		}
	}
	,checkArrowFunction: function(arrow) {
		var _gthis = this;
		var body = tokentree_TokenTreeAccessHelper.firstChild(arrow);
		if(body == null) {
			return;
		}
		if(!this.allowCurlyBody) {
			if(body.tok._hx_index == 17) {
				var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(body);
				switch(type._hx_index) {
				case 0:case 1:case 3:case 4:
					this.logPos("Arrow function should not have curlies",body.getPos());
					break;
				case 2:
					break;
				}
			}
		}
		arrow.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					if(_gthis.allowFunction) {
						return tokentree_FilterResult.SkipSubtree;
					}
					_gthis.logPos("Arrow function should not include nested functions",token.pos);
					return tokentree_FilterResult.SkipSubtree;
				case 10:
					if(_gthis.allowReturn) {
						return tokentree_FilterResult.GoDeeper;
					}
					_gthis.logPos("Arrow function should not have explicit returns",token.pos);
					return tokentree_FilterResult.SkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 13:
				if(token.index == arrow.index) {
					return tokentree_FilterResult.GoDeeper;
				}
				return tokentree_FilterResult.SkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(this.allowSingleArgParens) {
			return;
		}
		var parent = arrow.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(!parent.matches(tokentree_TokenTreeDef.POpen)) {
			return;
		}
		var count = 0;
		var _g = 0;
		var _g1 = parent.children;
		_hx_loop1: while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			switch(child.tok._hx_index) {
			case 13:
				break _hx_loop1;
			case 20:
				break _hx_loop1;
			default:
				++count;
			}
		}
		if(count == 1) {
			this.logPos("Arrow function should not use parens for single argument invocation",parent.pos);
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "allowReturn", values : [false,true]},{ propertyName : "allowFunction", values : [false,true]},{ propertyName : "allowCurlyBody", values : [false,true]},{ propertyName : "allowSingleArgParens", values : [false,true]}]}];
	}
	,__class__: checkstyle_checks_coding_ArrowFunctionCheck
});
var checkstyle_checks_coding_AvoidTernaryOperatorCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.severity = "IGNORE";
	this.categories = ["Complexity"];
	this.points = 3;
};
$hxClasses["checkstyle.checks.coding.AvoidTernaryOperatorCheck"] = checkstyle_checks_coding_AvoidTernaryOperatorCheck;
checkstyle_checks_coding_AvoidTernaryOperatorCheck.__name__ = "checkstyle.checks.coding.AvoidTernaryOperatorCheck";
checkstyle_checks_coding_AvoidTernaryOperatorCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_AvoidTernaryOperatorCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var _gthis = this;
		if(this.checker.ast == null) {
			return;
		}
		checkstyle_utils_ExprUtils.walkFile(this.checker.ast,function(e) {
			if(_gthis.isPosSuppressed(e.pos)) {
				return;
			}
			var _g = e.expr;
			if(_g._hx_index == 26) {
				var eelse = _g.eelse;
				var eif = _g.eif;
				var econd = _g.econd;
				_gthis.logPos("Avoid ternary operator",e.pos);
			}
		});
	}
	,__class__: checkstyle_checks_coding_AvoidTernaryOperatorCheck
});
var checkstyle_utils_DummyMutex = function() {
};
$hxClasses["checkstyle.utils.DummyMutex"] = checkstyle_utils_DummyMutex;
checkstyle_utils_DummyMutex.__name__ = "checkstyle.utils.DummyMutex";
checkstyle_utils_DummyMutex.prototype = {
	acquire: function() {
	}
	,release: function() {
	}
	,__class__: checkstyle_utils_DummyMutex
};
var checkstyle_checks_coding_CodeSimilarityCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.severityIdentical = "WARNING";
	this.thresholdIdentical = 60;
	this.thresholdSimilar = 120;
	this.categories = ["Style","Duplication"];
};
$hxClasses["checkstyle.checks.coding.CodeSimilarityCheck"] = checkstyle_checks_coding_CodeSimilarityCheck;
checkstyle_checks_coding_CodeSimilarityCheck.__name__ = "checkstyle.checks.coding.CodeSimilarityCheck";
checkstyle_checks_coding_CodeSimilarityCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_CodeSimilarityCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	severityIdentical: null
	,thresholdIdentical: null
	,thresholdSimilar: null
	,actualRun: function() {
		var _gthis = this;
		var root = this.checker.getTokenTree();
		root.filterCallback(function(token,index) {
			var skipSubTree = false;
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					skipSubTree = _gthis.checkFunctionSimilarity(token);
					break;
				case 3:
					skipSubTree = _gthis.checkFunctionSimilarity(token);
					break;
				case 5:
					if(token.parent != null && token.parent.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo))) {
						return tokentree_FilterResult.SkipSubtree;
					}
					skipSubTree = _gthis.checkFunctionSimilarity(token);
					break;
				case 6:
					skipSubTree = _gthis.checkFunctionSimilarity(token);
					break;
				case 7:
					skipSubTree = _gthis.checkFunctionSimilarity(token);
					break;
				case 14:
					skipSubTree = _gthis.checkFunctionSimilarity(token);
					break;
				case 20:
					skipSubTree = _gthis.checkFunctionSimilarity(token);
					break;
				default:
				}
				break;
			case 17:
				skipSubTree = _gthis.checkFunctionSimilarity(token);
				break;
			default:
			}
			if(skipSubTree) {
				return tokentree_FilterResult.SkipSubtree;
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,checkFunctionSimilarity: function(token) {
		var pos = token.getPos();
		if(this.isPosSuppressed(pos)) {
			return true;
		}
		var lineStart = this.checker.getLinePos(pos.min);
		var lineEnd = this.checker.getLinePos(pos.max);
		var hashes = this.makeCodeHashes(token);
		if(hashes.tokenCount <= Math.min(this.thresholdIdentical,this.thresholdSimilar)) {
			return false;
		}
		var codeBlock = { fileName : token.pos.file, lineStart : lineStart, lineEnd : lineEnd, startColumn : this.offsetToColumn(lineStart), endColumn : this.offsetToColumn(lineEnd)};
		if(hashes.tokenCount > this.thresholdIdentical) {
			var existing = this.checkOrAddHash(hashes.identicalHash,codeBlock,checkstyle_checks_coding_CodeSimilarityCheck.IDENTICAL_HASHES);
			if(existing != null) {
				this.logRange("Found identical code block - " + this.formatFirstFound(existing),pos.min,pos.max,"SimilarBlock",this.severityIdentical);
				return true;
			}
		}
		if(hashes.tokenCount > this.thresholdSimilar) {
			var existing = this.checkOrAddHash(hashes.similarHash,codeBlock,checkstyle_checks_coding_CodeSimilarityCheck.SIMILAR_HASHES);
			if(existing == null) {
				return false;
			}
			this.logRange("Found similar code block - " + this.formatFirstFound(existing),pos.min,pos.max,"SimilarBlock");
			return true;
		}
		return false;
	}
	,formatFirstFound: function(existing) {
		return "first seen in " + existing.fileName + ":" + (existing.lineStart.line + 1);
	}
	,checkOrAddHash: function(hash,codeBlock,hashTable) {
		checkstyle_checks_coding_CodeSimilarityCheck.LOCK.acquire();
		var existing = hashTable.h[hash];
		if(existing == null) {
			hashTable.h[hash] = codeBlock;
		}
		checkstyle_checks_coding_CodeSimilarityCheck.LOCK.release();
		return existing;
	}
	,makeCodeHashes: function(token) {
		var similar = new StringBuf();
		var identical = new StringBuf();
		var tokenCount = this.makeCodeHashesRecursive(token,similar,identical);
		return { identicalHash : identical.b, similarHash : similar.b, tokenCount : tokenCount};
	}
	,makeCodeHashesRecursive: function(token,similar,identical) {
		var x = this.similarTokenText(token);
		similar.b += Std.string(x);
		var count = 0;
		var identicalText = this.identicalTokenText(token);
		if(identicalText != null) {
			++count;
			identical.b += identicalText == null ? "null" : "" + identicalText;
		}
		if(token.children != null) {
			var _g = 0;
			var _g1 = token.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				count += this.makeCodeHashesRecursive(child,similar,identical);
			}
		}
		return count;
	}
	,similarTokenText: function(token) {
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 37:case 38:
				return "const_bool";
			default:
				return "" + Std.string(token.tok);
			}
			break;
		case 2:
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				var _g2 = _g1.v;
				return "const_int";
			case 1:
				var _g2 = _g1.f;
				return "const_float";
			case 2:
				var _g2 = _g1.kind;
				var s = _g1.s;
				if(checkstyle_utils_StringUtils.isStringInterpolation(s,this.checker.file.content,token.pos)) {
					return "const_string_interpol";
				}
				return "const_string";
			case 3:
				var _g2 = _g1.s;
				return "identifier";
			case 4:
				var _g2 = _g1.opt;
				var _g2 = _g1.r;
				return "regex";
			}
			break;
		case 4:
			var _g1 = _g.s;
			return "$name";
		case 5:
			var _g1 = _g.op;
			return "unop";
		case 6:
			var _g1 = _g.op;
			switch(_g1._hx_index) {
			case 0:case 1:case 2:case 3:case 19:
				return "oparithmetic";
			case 4:
				return "assign";
			case 5:case 6:case 7:case 8:case 9:case 10:
				return "opcompare";
			case 11:case 12:case 13:case 16:case 17:case 18:
				return "opbitwise";
			case 14:case 15:
				return "oplogical";
			case 20:
				var _g2 = _g1.op;
				return "opassign";
			default:
				return "binop";
			}
			break;
		case 7:
			var _g1 = _g.s;
			return "";
		case 8:
			var _g1 = _g.s;
			return "";
		case 9:
			var _g1 = _g.s;
			return "...";
		default:
			return "" + Std.string(token.tok);
		}
	}
	,identicalTokenText: function(token) {
		var _g = token.tok;
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				var i = _g1.v;
				return "" + i;
			case 1:
				var f = _g1.f;
				return "" + f;
			case 2:
				var _g2 = _g1.kind;
				var s = _g1.s;
				return "\"" + s + "\"";
			case 3:
				var i = _g1.s;
				return "" + i;
			case 4:
				var op = _g1.opt;
				var r = _g1.r;
				return "" + r + "," + op;
			}
			break;
		case 4:
			var n = _g.s;
			return "" + n;
		case 5:
			var op = _g.op;
			return "" + Std.string(op);
		case 6:
			var op = _g.op;
			return "" + Std.string(op);
		case 7:
			var _g1 = _g.s;
			return null;
		case 8:
			var _g1 = _g.s;
			return null;
		case 9:
			var i = _g.s;
			return "..." + i;
		default:
			return "" + Std.string(token.tok);
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_coding_CodeSimilarityCheck
});
var checkstyle_checks_coding_DefaultComesLastCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.categories = ["Style","Clarity"];
	this.points = 2;
};
$hxClasses["checkstyle.checks.coding.DefaultComesLastCheck"] = checkstyle_checks_coding_DefaultComesLastCheck;
checkstyle_checks_coding_DefaultComesLastCheck.__name__ = "checkstyle.checks.coding.DefaultComesLastCheck";
checkstyle_checks_coding_DefaultComesLastCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_DefaultComesLastCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var root = this.checker.getTokenTree();
		var acceptableTokens = root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 14) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < acceptableTokens.length) {
			var token = acceptableTokens[_g];
			++_g;
			var tokens = token.filterCallback(function(token,index) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 15:case 16:
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(tokens.length <= 0) {
				continue;
			}
			if(tokens[tokens.length - 1].matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDefault))) {
				continue;
			}
			var _g1 = 0;
			var _g2 = tokens.length;
			while(_g1 < _g2) {
				var i = _g1++;
				if(tokens[i].matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDefault)) && i < tokens.length - 1) {
					this.logPos("Default should be last label in the \"switch\"",token.pos);
					continue;
				}
			}
		}
	}
	,__class__: checkstyle_checks_coding_DefaultComesLastCheck
});
var checkstyle_checks_coding_HiddenFieldCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.ignoreConstructorParameter = true;
	this.ignoreSetter = true;
	this.ignoreFormat = "^(main|run)$";
	this.categories = ["Complexity","Clarity","Bug Risk"];
	this.points = 5;
};
$hxClasses["checkstyle.checks.coding.HiddenFieldCheck"] = checkstyle_checks_coding_HiddenFieldCheck;
checkstyle_checks_coding_HiddenFieldCheck.__name__ = "checkstyle.checks.coding.HiddenFieldCheck";
checkstyle_checks_coding_HiddenFieldCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_HiddenFieldCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	ignoreConstructorParameter: null
	,ignoreSetter: null
	,ignoreFormat: null
	,actualRun: function() {
		var ignoreFormatRE = new EReg(this.ignoreFormat,"");
		var root = this.checker.getTokenTree();
		this.checkClasses(root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 1) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		}),ignoreFormatRE);
	}
	,checkClasses: function(classes,ignoreFormatRE) {
		var _g = 0;
		while(_g < classes.length) {
			var clazz = classes[_g];
			++_g;
			if(this.isPosSuppressed(clazz.pos)) {
				continue;
			}
			var memberNames = this.collectMemberNames(clazz);
			var methods = clazz.filterCallback(function(token,depth) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					if(_g.k._hx_index == 0) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			var _g1 = 0;
			while(_g1 < methods.length) {
				var method = methods[_g1];
				++_g1;
				if(this.isPosSuppressed(method.pos)) {
					continue;
				}
				this.checkMethod(method,memberNames,ignoreFormatRE);
			}
		}
	}
	,checkMethod: function(method,memberNames,ignoreFormatRE) {
		if(!method.hasChildren()) {
			throw haxe_Exception.thrown("function has invalid structure!");
		}
		var methodName = method.children[0];
		if(methodName.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew)) && this.ignoreConstructorParameter) {
			return;
		}
		if(this.ignoreSetter && this.isSetterFunction(methodName,memberNames)) {
			return;
		}
		var _g = methodName.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 22) {
				if(ignoreFormatRE.match("new")) {
					return;
				}
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var name = _g1.s;
				if(ignoreFormatRE.match(name)) {
					return;
				}
			}
			break;
		default:
		}
		this.checkParams(method,memberNames);
		this.checkVars(method,memberNames);
		this.checkForLoops(method,memberNames);
	}
	,isSetterFunction: function(methodName,memberNames) {
		var _g = methodName.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var name = _g1.s;
				var _g = 0;
				while(_g < memberNames.length) {
					var member = memberNames[_g];
					++_g;
					if("set_" + member.toLowerCase() == name.toLowerCase() || "set" + member.toLowerCase() == name.toLowerCase()) {
						return true;
					}
				}
			}
		}
		return false;
	}
	,checkParams: function(method,memberNames) {
		var paramDef = method.filterCallback(function(token,depth) {
			if(depth > 2) {
				return tokentree_FilterResult.SkipSubtree;
			}
			if(token.tok._hx_index == 19) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(paramDef == null || paramDef.length != 1) {
			throw haxe_Exception.thrown("function parameters have invalid structure!");
		}
		var paramList = paramDef[0].children;
		var _g = 0;
		while(_g < paramList.length) {
			var param = paramList[_g];
			++_g;
			this.checkName(param,memberNames,"Parameter definition");
		}
	}
	,checkVars: function(method,memberNames) {
		var vars = method.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 2) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < vars.length) {
			var v = vars[_g];
			++_g;
			if(!v.hasChildren()) {
				throw haxe_Exception.thrown("var has invalid structure!");
			}
			this.checkName(v.children[0],memberNames,"Variable definition");
		}
	}
	,checkForLoops: function(method,memberNames) {
		var fors = method.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 7) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < fors.length) {
			var f = fors[_g];
			++_g;
			var popens = f.filterCallback(function(token,depth) {
				if(depth > 2) {
					return tokentree_FilterResult.SkipSubtree;
				}
				if(token.tok._hx_index == 19) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(popens.length <= 0) {
				continue;
			}
			var pOpen = popens[0];
			if(!pOpen.hasChildren()) {
				continue;
			}
			this.checkName(pOpen.children[0],memberNames,"For loop definition");
		}
	}
	,checkName: function(token,memberNames,logText) {
		var _g = token.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var name = _g1.s;
				if(memberNames.indexOf(name) != -1) {
					this.logPos("" + logText + " of \"" + name + "\" masks member of same name",token.pos);
				}
			}
		}
	}
	,collectMemberNames: function(clazz) {
		var memberNames = [];
		var varFields = clazz.filterCallback(function(token,depth) {
			if(depth > 3) {
				return tokentree_FilterResult.SkipSubtree;
			}
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 2) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < varFields.length) {
			var member = varFields[_g];
			++_g;
			if(!member.hasChildren()) {
				continue;
			}
			var _g1 = member.children[0].tok;
			if(_g1._hx_index == 2) {
				var _g2 = _g1.c;
				if(_g2._hx_index == 3) {
					var name = _g2.s;
					memberNames.push(name);
				}
			}
		}
		return memberNames;
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "ignoreConstructorParameter", values : [true,false]},{ propertyName : "ignoreSetter", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_coding_HiddenFieldCheck
});
var checkstyle_checks_coding_InnerAssignmentCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.ignoreReturnAssignments = false;
	this.categories = ["Complexity","Clarity","Bug Risk"];
	this.points = 5;
};
$hxClasses["checkstyle.checks.coding.InnerAssignmentCheck"] = checkstyle_checks_coding_InnerAssignmentCheck;
checkstyle_checks_coding_InnerAssignmentCheck.__name__ = "checkstyle.checks.coding.InnerAssignmentCheck";
checkstyle_checks_coding_InnerAssignmentCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_InnerAssignmentCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	ignoreReturnAssignments: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var allAssignments = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 6) {
				var _g1 = _g.op;
				switch(_g1._hx_index) {
				case 4:
					return tokentree_FilterResult.FoundGoDeeper;
				case 20:
					switch(_g1.op._hx_index) {
					case 0:case 1:case 2:case 3:case 11:case 12:case 13:case 16:case 17:case 18:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allAssignments.length) {
			var assignToken = allAssignments[_g];
			++_g;
			if(this.isPosSuppressed(assignToken.pos) || !this.filterAssignment(assignToken)) {
				continue;
			}
			this.logPos("Inner assignment detected",assignToken.pos);
		}
	}
	,filterAssignment: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		if(token.previousSibling != null) {
			if(token.previousSibling.matches(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt))) {
				return false;
			}
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return false;
			case 2:
				return false;
			case 10:
				return this.filterReturn(token);
			case 14:
				return true;
			default:
				return this.filterAssignment(token.parent);
			}
			break;
		case 12:case 17:
			return false;
		case 19:
			return this.filterPOpen(token.parent);
		default:
			return this.filterAssignment(token.parent);
		}
	}
	,filterPOpen: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return false;
			case 2:
				return false;
			case 5:
				return false;
			case 10:
				return true;
			case 22:
				return !Type.enumEq(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction),token.parent.tok);
			default:
				return true;
			}
			break;
		case 2:
			var _g1 = _g.c;
			return this.filterPOpen(token.parent);
		case 19:
			return this.filterPOpen(token.parent);
		default:
			return true;
		}
	}
	,filterReturn: function(token) {
		if(!this.ignoreReturnAssignments) {
			return true;
		}
		var allBinops = token.filterCallback(function(token,depth) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 5:
				var _g1 = _g.op;
				return tokentree_FilterResult.FoundGoDeeper;
			case 6:
				var _g1 = _g.op;
				return tokentree_FilterResult.FoundGoDeeper;
			case 15:case 17:case 19:
				return tokentree_FilterResult.FoundGoDeeper;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(allBinops.length != 1) {
			return true;
		}
		var parent;
		if(Type.enumEq(token.parent.tok,tokentree_TokenTreeDef.BrOpen)) {
			var brOpen = token.parent;
			if(brOpen.children.length > 2) {
				return true;
			}
			parent = brOpen.parent;
		} else {
			parent = token.parent;
			if(parent.getLastChild() != token) {
				return true;
			}
		}
		if(!Type.enumEq(parent.parent.tok,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction))) {
			return true;
		}
		var _g = parent.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var name = _g1.s;
				if(!StringTools.startsWith(name,"set_")) {
					return true;
				}
			} else {
				return true;
			}
		} else {
			return true;
		}
		return false;
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "ignoreReturnAssignments", values : [false,true]}]}];
	}
	,__class__: checkstyle_checks_coding_InnerAssignmentCheck
});
var checkstyle_checks_coding_MagicNumberCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.ignoreNumbers = [-1,0,1,2];
	this.categories = ["Clarity","Complexity"];
	this.points = 3;
};
$hxClasses["checkstyle.checks.coding.MagicNumberCheck"] = checkstyle_checks_coding_MagicNumberCheck;
checkstyle_checks_coding_MagicNumberCheck.__name__ = "checkstyle.checks.coding.MagicNumberCheck";
checkstyle_checks_coding_MagicNumberCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_MagicNumberCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	ignoreNumbers: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var allTypes = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 26:case 27:case 31:case 39:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allTypes.length) {
			var type = allTypes[_g];
			++_g;
			if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(type)) {
				continue;
			}
			this.checkForNumbers(type);
		}
	}
	,checkForNumbers: function(parent) {
		var allNumbers = parent.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 2) {
				var _g1 = _g.c;
				switch(_g1._hx_index) {
				case 0:
					var _g = _g1.v;
					return tokentree_FilterResult.FoundGoDeeper;
				case 1:
					var _g = _g1.f;
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allNumbers.length) {
			var numberToken = allNumbers[_g];
			++_g;
			if(this.isPosSuppressed(numberToken.pos)) {
				continue;
			}
			if(this.filterNumber(numberToken)) {
				continue;
			}
			var _g1 = numberToken.tok;
			if(_g1._hx_index == 2) {
				var _g2 = _g1.c;
				switch(_g2._hx_index) {
				case 0:
					var n = _g2.v;
					var number = Std.parseInt(n);
					if(this.ignoreNumbers.indexOf(number) != -1) {
						continue;
					}
					this.logPos("\"" + n + "\" is a magic number",numberToken.pos);
					break;
				case 1:
					var n1 = _g2.f;
					var number1 = parseFloat(n1);
					if(this.ignoreNumbers.indexOf(number1) != -1) {
						continue;
					}
					this.logPos("\"" + n1 + "\" is a magic number",numberToken.pos);
					break;
				default:
				}
			}
		}
	}
	,filterNumber: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 2:
				if(token.filterCallback(function(token,depth) {
					var _g = token.tok;
					if(_g._hx_index == 1) {
						if(_g.k._hx_index == 17) {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				}).length > 0) {
					return true;
				} else {
					return false;
				}
				break;
			case 41:
				return true;
			default:
				return this.filterNumber(token.parent);
			}
			break;
		case 17:
			return false;
		case 22:
			return true;
		default:
			return this.filterNumber(token.parent);
		}
	}
	,__class__: checkstyle_checks_coding_MagicNumberCheck
});
var checkstyle_checks_coding_MultipleVariableDeclarationsCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.categories = ["Style","Clarity","Complexity"];
	this.points = 2;
};
$hxClasses["checkstyle.checks.coding.MultipleVariableDeclarationsCheck"] = checkstyle_checks_coding_MultipleVariableDeclarationsCheck;
checkstyle_checks_coding_MultipleVariableDeclarationsCheck.__name__ = "checkstyle.checks.coding.MultipleVariableDeclarationsCheck";
checkstyle_checks_coding_MultipleVariableDeclarationsCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_MultipleVariableDeclarationsCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var root = this.checker.getTokenTree();
		var acceptableTokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 2) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var lastVarLineNo = -1;
		var _g = 0;
		while(_g < acceptableTokens.length) {
			var v = acceptableTokens[_g];
			++_g;
			var curVarLineNo = this.checker.getLinePos(v.pos.min).line;
			if(lastVarLineNo > 0 && lastVarLineNo == curVarLineNo) {
				this.logPos("Only one variable definition per line allowed",v.pos);
			}
			lastVarLineNo = curVarLineNo;
			var count = 0;
			var _g1 = 0;
			var _g2 = v.children;
			while(_g1 < _g2.length) {
				var c = _g2[_g1];
				++_g1;
				var _g3 = c.tok;
				if(_g3._hx_index == 2) {
					var _g4 = _g3.c;
					if(_g4._hx_index == 3) {
						var name = _g4.s;
						++count;
					}
				}
			}
			if(count > 1) {
				this.logPos("Each variable declaration must be in its own statement",v.pos);
			}
		}
	}
	,__class__: checkstyle_checks_coding_MultipleVariableDeclarationsCheck
});
var checkstyle_checks_coding_NestedControlFlowCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.max = 3;
	this.categories = ["Complexity"];
	this.points = 8;
};
$hxClasses["checkstyle.checks.coding.NestedControlFlowCheck"] = checkstyle_checks_coding_NestedControlFlowCheck;
checkstyle_checks_coding_NestedControlFlowCheck.__name__ = "checkstyle.checks.coding.NestedControlFlowCheck";
checkstyle_checks_coding_NestedControlFlowCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_NestedControlFlowCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	max: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var controlFlowTokens = root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 3:
					return tokentree_FilterResult.FoundGoDeeper;
				case 5:
					if(token.parent != null && token.parent.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo))) {
						return tokentree_FilterResult.GoDeeper;
					} else {
						return tokentree_FilterResult.FoundGoDeeper;
					}
					break;
				case 6:
					return tokentree_FilterResult.FoundGoDeeper;
				case 7:
					return tokentree_FilterResult.FoundGoDeeper;
				case 14:
					return tokentree_FilterResult.FoundGoDeeper;
				case 20:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < controlFlowTokens.length) {
			var token = controlFlowTokens[_g];
			++_g;
			if(this.isPosSuppressed(token.pos)) {
				continue;
			}
			this.checkExpressionDepth(token);
		}
	}
	,checkExpressionDepth: function(token) {
		var depth = this.calcDepth(token);
		if(depth > this.max) {
			this.warnNestedDepth(depth,token.getPos());
		}
	}
	,calcDepth: function(token) {
		var parent = token.parent;
		var count = 1;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			var _g = parent.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 3:
					++count;
					break;
				case 5:
					if(parent.parent == null || !parent.parent.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo))) {
						++count;
					}
					break;
				case 6:
					++count;
					break;
				case 7:
					++count;
					break;
				case 14:
					++count;
					break;
				case 20:
					++count;
					break;
				default:
				}
			}
			parent = parent.parent;
		}
		return count;
	}
	,warnNestedDepth: function(depth,pos) {
		this.logPos("Nested control flow depth is " + depth + " (max allowed is " + this.max + ")",pos);
	}
	,detectableInstances: function() {
		var _g = [];
		_g.push(1);
		_g.push(2);
		_g.push(3);
		_g.push(4);
		return [{ fixed : [], properties : [{ propertyName : "max", values : _g}]}];
	}
	,__class__: checkstyle_checks_coding_NestedControlFlowCheck
});
var checkstyle_checks_coding_NestedForDepthCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.max = 1;
	this.categories = ["Complexity"];
	this.points = 8;
};
$hxClasses["checkstyle.checks.coding.NestedForDepthCheck"] = checkstyle_checks_coding_NestedForDepthCheck;
checkstyle_checks_coding_NestedForDepthCheck.__name__ = "checkstyle.checks.coding.NestedForDepthCheck";
checkstyle_checks_coding_NestedForDepthCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_NestedForDepthCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	max: null
	,actualRun: function() {
		var _gthis = this;
		this.forEachField(function(f,_) {
			var _g = f.kind;
			if(_g._hx_index == 1) {
				var fun = _g.f;
				_gthis.scanBlock(fun.expr,-1);
			}
		});
	}
	,scanBlock: function(e,depth) {
		if(e == null) {
			return;
		}
		if(depth > this.max) {
			this.warnNestedForDepth(depth,e.pos);
			return;
		}
		var _g = e.expr;
		if(_g._hx_index == 12) {
			var exprs = _g.exprs;
			this.scanExprs(exprs,depth);
		}
	}
	,scanExprs: function(exprs,depth) {
		var _g = 0;
		while(_g < exprs.length) {
			var e = exprs[_g];
			++_g;
			var _g1 = e.expr;
			switch(_g1._hx_index) {
			case 13:
				var _g2 = _g1.it;
				var expr = _g1.expr;
				this.scanBlock(expr,depth + 1);
				break;
			case 15:
				var _g3 = _g1.normalWhile;
				var _g4 = _g1.econd;
				var expr1 = _g1.e;
				this.scanBlock(expr1,depth + 1);
				break;
			default:
			}
		}
	}
	,warnNestedForDepth: function(depth,pos) {
		this.logPos("Nested loop depth is " + depth + " (max allowed is " + this.max + ")",pos);
	}
	,detectableInstances: function() {
		var _g = [];
		_g.push(0);
		_g.push(1);
		_g.push(2);
		_g.push(3);
		_g.push(4);
		return [{ fixed : [], properties : [{ propertyName : "max", values : _g}]}];
	}
	,__class__: checkstyle_checks_coding_NestedForDepthCheck
});
var checkstyle_checks_coding_NestedIfDepthCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.max = 1;
	this.categories = ["Complexity"];
	this.points = 8;
};
$hxClasses["checkstyle.checks.coding.NestedIfDepthCheck"] = checkstyle_checks_coding_NestedIfDepthCheck;
checkstyle_checks_coding_NestedIfDepthCheck.__name__ = "checkstyle.checks.coding.NestedIfDepthCheck";
checkstyle_checks_coding_NestedIfDepthCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_NestedIfDepthCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	max: null
	,actualRun: function() {
		var _gthis = this;
		this.forEachField(function(f,_) {
			var _g = f.kind;
			if(_g._hx_index == 1) {
				var fun = _g.f;
				_gthis.scanBlock(fun.expr,-1);
			}
		});
	}
	,scanBlock: function(e,depth) {
		if(e == null) {
			return;
		}
		if(depth > this.max) {
			this.warnNestedIfDepth(depth,e.pos);
			return;
		}
		var _g = e.expr;
		if(_g._hx_index == 12) {
			var exprs = _g.exprs;
			this.scanExprs(exprs,depth);
		}
	}
	,scanExprs: function(exprs,depth) {
		var _g = 0;
		while(_g < exprs.length) {
			var e = exprs[_g];
			++_g;
			var _g1 = e.expr;
			if(_g1._hx_index == 14) {
				var _g2 = _g1.econd;
				var elsePart = _g1.eelse;
				var ifPart = _g1.eif;
				this.scanBlock(ifPart,depth + 1);
				this.scanBlock(elsePart,depth + 1);
			}
		}
	}
	,warnNestedIfDepth: function(depth,pos) {
		this.logPos("Nested if-else depth is " + depth + " (max allowed is " + this.max + ")",pos);
	}
	,detectableInstances: function() {
		var _g = [];
		_g.push(0);
		_g.push(1);
		_g.push(2);
		_g.push(3);
		_g.push(4);
		_g.push(5);
		_g.push(6);
		_g.push(7);
		_g.push(8);
		_g.push(9);
		return [{ fixed : [], properties : [{ propertyName : "max", values : _g}]}];
	}
	,__class__: checkstyle_checks_coding_NestedIfDepthCheck
});
var checkstyle_checks_coding_NestedTryDepthCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.max = 1;
	this.categories = ["Complexity"];
	this.points = 5;
};
$hxClasses["checkstyle.checks.coding.NestedTryDepthCheck"] = checkstyle_checks_coding_NestedTryDepthCheck;
checkstyle_checks_coding_NestedTryDepthCheck.__name__ = "checkstyle.checks.coding.NestedTryDepthCheck";
checkstyle_checks_coding_NestedTryDepthCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_NestedTryDepthCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	max: null
	,actualRun: function() {
		var _gthis = this;
		this.forEachField(function(f,_) {
			var _g = f.kind;
			if(_g._hx_index == 1) {
				var fun = _g.f;
				_gthis.scanBlock(fun.expr,-1);
			}
		});
	}
	,scanBlock: function(e,depth) {
		if(e == null) {
			return;
		}
		if(depth > this.max) {
			this.warnNestedTryDepth(depth,e.pos);
			return;
		}
		var _g = e.expr;
		if(_g._hx_index == 12) {
			var exprs = _g.exprs;
			this.scanExprs(exprs,depth);
		}
	}
	,scanExprs: function(exprs,depth) {
		var _g = 0;
		while(_g < exprs.length) {
			var e = exprs[_g];
			++_g;
			var _g1 = e.expr;
			if(_g1._hx_index == 17) {
				var catches = _g1.catches;
				var expr = _g1.e;
				this.scanBlock(expr,depth + 1);
				this.scanCatches(catches,depth + 1);
			}
		}
	}
	,scanCatches: function(catches,depth) {
		var _g = 0;
		while(_g < catches.length) {
			var c = catches[_g];
			++_g;
			this.scanBlock(c.expr,depth);
		}
	}
	,warnNestedTryDepth: function(depth,pos) {
		this.logPos("Nested try depth is " + depth + " (max allowed is " + this.max + ")",pos);
	}
	,detectableInstances: function() {
		var _g = [];
		_g.push(0);
		_g.push(1);
		_g.push(2);
		_g.push(3);
		_g.push(4);
		return [{ fixed : [], properties : [{ propertyName : "max", values : _g}]}];
	}
	,__class__: checkstyle_checks_coding_NestedTryDepthCheck
});
var checkstyle_checks_coding_NullableParameterCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.option = "questionMark";
};
$hxClasses["checkstyle.checks.coding.NullableParameterCheck"] = checkstyle_checks_coding_NullableParameterCheck;
checkstyle_checks_coding_NullableParameterCheck.__name__ = "checkstyle.checks.coding.NullableParameterCheck";
checkstyle_checks_coding_NullableParameterCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_NullableParameterCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	option: null
	,actualRun: function() {
		var _gthis = this;
		this.forEachField(function(field,_) {
			var _g = field.kind;
			if(_g._hx_index == 1) {
				var f = _g.f;
				var _g = 0;
				var _g1 = f.args;
				while(_g < _g1.length) {
					var arg = _g1[_g];
					++_g;
					_gthis.checkArgument(arg,field.pos);
				}
			}
		});
	}
	,checkArgument: function(arg,pos) {
		var hasNullDefault = haxe_macro_ExprTools.toString(arg.value) == "null";
		if(!hasNullDefault && arg.value != null) {
			return;
		}
		var formatted = this.formatArguments(arg.opt,arg.name,hasNullDefault);
		switch(this.option) {
		case "nullDefault":
			if(arg.opt) {
				this.logRange("Function parameter " + formatted + " should be " + this.formatArguments(false,arg.name,true),pos.min,pos.min);
			}
			break;
		case "questionMark":
			if(hasNullDefault) {
				this.logRange("Function parameter " + formatted + " should be " + this.formatArguments(true,arg.name,false),pos.min,pos.min);
			}
			break;
		}
	}
	,formatArguments: function(opt,name,nullDefault) {
		return "\"" + (opt ? "?" : "") + name + (nullDefault ? " = null" : "") + "\"";
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "option", values : ["questionMark","nullDefault"]}]}];
	}
	,__class__: checkstyle_checks_coding_NullableParameterCheck
});
var checkstyle_checks_coding_ReturnCountCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.max = 2;
	this.ignoreFormat = "^$";
	this.categories = ["Complexity"];
	this.points = 5;
};
$hxClasses["checkstyle.checks.coding.ReturnCountCheck"] = checkstyle_checks_coding_ReturnCountCheck;
checkstyle_checks_coding_ReturnCountCheck.__name__ = "checkstyle.checks.coding.ReturnCountCheck";
checkstyle_checks_coding_ReturnCountCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_ReturnCountCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	max: null
	,ignoreFormat: null
	,actualRun: function() {
		var ignoreFormatRE = new EReg(this.ignoreFormat,"");
		var root = this.checker.getTokenTree();
		var functions = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 0) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < functions.length) {
			var fn = functions[_g];
			++_g;
			if(fn.children == null) {
				continue;
			}
			var _g1 = fn.getFirstChild().tok;
			if(_g1._hx_index == 2) {
				var _g2 = _g1.c;
				if(_g2._hx_index == 3) {
					var name = _g2.s;
					if(ignoreFormatRE.match(name)) {
						continue;
					}
				}
			}
			if(this.isPosSuppressed(fn.pos)) {
				continue;
			}
			if(!fn.hasChildren()) {
				continue;
			}
			var returns = fn.filterCallback($bind(this,this.filterReturns));
			if(returns.length > this.max) {
				this.logPos("Return count is " + returns.length + " (max allowed is " + this.max + ")",checkstyle_utils_PosHelper.getReportPos(fn));
			}
		}
	}
	,filterReturns: function(token,depth) {
		var _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 0:
				if(depth == 0) {
					return tokentree_FilterResult.GoDeeper;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
				break;
			case 10:
				return tokentree_FilterResult.FoundSkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		} else {
			return tokentree_FilterResult.GoDeeper;
		}
	}
	,detectableInstances: function() {
		var _g = [];
		_g.push(2);
		_g.push(3);
		_g.push(4);
		_g.push(5);
		_g.push(6);
		_g.push(7);
		_g.push(8);
		_g.push(9);
		_g.push(10);
		_g.push(11);
		_g.push(12);
		_g.push(13);
		_g.push(14);
		_g.push(15);
		_g.push(16);
		_g.push(17);
		_g.push(18);
		_g.push(19);
		return [{ fixed : [], properties : [{ propertyName : "max", values : _g}]}];
	}
	,__class__: checkstyle_checks_coding_ReturnCountCheck
});
var checkstyle_checks_coding_SimplifyBooleanExpressionCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.categories = ["Complexity"];
	this.points = 3;
};
$hxClasses["checkstyle.checks.coding.SimplifyBooleanExpressionCheck"] = checkstyle_checks_coding_SimplifyBooleanExpressionCheck;
checkstyle_checks_coding_SimplifyBooleanExpressionCheck.__name__ = "checkstyle.checks.coding.SimplifyBooleanExpressionCheck";
checkstyle_checks_coding_SimplifyBooleanExpressionCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_SimplifyBooleanExpressionCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var root = this.checker.getTokenTree();
		var acceptableTokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 37:case 38:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 5:
				if(_g.op._hx_index == 2) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 5:case 6:case 11:case 12:case 14:case 15:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < acceptableTokens.length) {
			var token = acceptableTokens[_g];
			++_g;
			if(this.isPosSuppressed(token.pos)) {
				continue;
			}
			if(token.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTrue)) || token.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFalse))) {
				this.checkToken(token);
			}
		}
	}
	,checkToken: function(token) {
		var parent = token.parent;
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 5:
			if(_g.op._hx_index == 2) {
				this.logPos("Boolean expression can be simplified",token.pos);
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 5:case 6:case 11:case 12:case 14:case 15:
				this.logPos("Boolean expression can be simplified",token.pos);
				break;
			default:
			}
			break;
		default:
		}
	}
	,__class__: checkstyle_checks_coding_SimplifyBooleanExpressionCheck
});
var checkstyle_checks_coding_SimplifyBooleanReturnCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.categories = ["Complexity"];
	this.points = 2;
};
$hxClasses["checkstyle.checks.coding.SimplifyBooleanReturnCheck"] = checkstyle_checks_coding_SimplifyBooleanReturnCheck;
checkstyle_checks_coding_SimplifyBooleanReturnCheck.__name__ = "checkstyle.checks.coding.SimplifyBooleanReturnCheck";
checkstyle_checks_coding_SimplifyBooleanReturnCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_SimplifyBooleanReturnCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var root = this.checker.getTokenTree();
		var acceptableTokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 3) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < acceptableTokens.length) {
			var token = acceptableTokens[_g];
			++_g;
			var elseLiteral = token.filterCallback(function(token,depth) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					if(_g.k._hx_index == 4) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			})[0];
			if(elseLiteral == null) {
				continue;
			}
			var elseStatement = elseLiteral.getFirstChild();
			var thenStatement = token.children[1];
			if(this.canReturnOnlyBooleanLiteral(thenStatement) && this.canReturnOnlyBooleanLiteral(elseStatement)) {
				this.logPos("Conditional logic can be removed",token.pos);
			}
		}
	}
	,canReturnOnlyBooleanLiteral: function(tkn) {
		if(this.isBooleanLiteralReturnStatement(tkn)) {
			return true;
		}
		return this.isBooleanLiteralReturnStatement(tkn.getFirstChild());
	}
	,isBooleanLiteralReturnStatement: function(tkn) {
		var booleanReturnStatement = false;
		if(tkn != null && tkn.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdReturn))) {
			var expr = tkn.getFirstChild();
			booleanReturnStatement = this.isBooleanLiteralType(expr);
		}
		return booleanReturnStatement;
	}
	,isBooleanLiteralType: function(tkn) {
		if(!tkn.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTrue))) {
			return tkn.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFalse));
		} else {
			return true;
		}
	}
	,__class__: checkstyle_checks_coding_SimplifyBooleanReturnCheck
});
var checkstyle_checks_coding_TraceCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.severity = "IGNORE";
};
$hxClasses["checkstyle.checks.coding.TraceCheck"] = checkstyle_checks_coding_TraceCheck;
checkstyle_checks_coding_TraceCheck.__name__ = "checkstyle.checks.coding.TraceCheck";
checkstyle_checks_coding_TraceCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_TraceCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var root = this.checker.getTokenTree();
		var traces = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 2) {
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "trace") {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < traces.length) {
			var tr = traces[_g];
			++_g;
			if(tr.getFirstChild().tok._hx_index != 19) {
				continue;
			}
			if(this.filterTrace(tr.parent)) {
				continue;
			}
			if(this.isPosSuppressed(tr.pos)) {
				continue;
			}
			this.logPos("Trace detected",tr.getPos());
		}
	}
	,filterTrace: function(token) {
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 0) {
				return true;
			} else {
				return false;
			}
			break;
		case 11:
			return true;
		default:
			return false;
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_coding_TraceCheck
});
var checkstyle_checks_coding_UnusedLocalVarCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
};
$hxClasses["checkstyle.checks.coding.UnusedLocalVarCheck"] = checkstyle_checks_coding_UnusedLocalVarCheck;
checkstyle_checks_coding_UnusedLocalVarCheck.__name__ = "checkstyle.checks.coding.UnusedLocalVarCheck";
checkstyle_checks_coding_UnusedLocalVarCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_UnusedLocalVarCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var root = this.checker.getTokenTree();
		var functions = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 0) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < functions.length) {
			var f = functions[_g];
			++_g;
			if(this.isPosSuppressed(f.pos)) {
				continue;
			}
			var skipFirstFunction = [true];
			var localVars = f.filterCallback((function(skipFirstFunction) {
				return function(tok,depth) {
					var _g = tok.tok;
					if(_g._hx_index == 1) {
						switch(_g.k._hx_index) {
						case 0:
							if(skipFirstFunction[0]) {
								skipFirstFunction[0] = false;
								return tokentree_FilterResult.GoDeeper;
							} else {
								return tokentree_FilterResult.SkipSubtree;
							}
							break;
						case 2:
							return tokentree_FilterResult.FoundSkipSubtree;
						default:
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				};
			})(skipFirstFunction));
			this.checkLocalVars(f,localVars);
		}
	}
	,checkLocalVars: function(f,localVars) {
		var _g = 0;
		while(_g < localVars.length) {
			var localVar = localVars[_g];
			++_g;
			var _g1 = 0;
			var _g2 = localVar.children;
			while(_g1 < _g2.length) {
				var child = _g2[_g1];
				++_g1;
				var _g3 = child.tok;
				if(_g3._hx_index == 2) {
					var _g4 = _g3.c;
					if(_g4._hx_index == 3) {
						var name = _g4.s;
						this.checkLocalVar(f,child,name);
					}
				}
			}
		}
	}
	,checkLocalVar: function(f,v,name) {
		var _gthis = this;
		var ignoreFunctionSignature = true;
		var nameList = f.filterCallback(function(tok,depth) {
			if(ignoreFunctionSignature) {
				var _g = tok.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 18:case 19:
						return tokentree_FilterResult.SkipSubtree;
					default:
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 7:
					var _g1 = _g.s;
					return tokentree_FilterResult.SkipSubtree;
				case 8:
					var _g1 = _g.s;
					return tokentree_FilterResult.SkipSubtree;
				case 19:
					ignoreFunctionSignature = false;
					return tokentree_FilterResult.SkipSubtree;
				case 22:
					return tokentree_FilterResult.SkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			}
			var _g = tok.tok;
			switch(_g._hx_index) {
			case 2:
				var _g1 = _g.c;
				switch(_g1._hx_index) {
				case 2:
					var _g2 = _g1.kind;
					var s = _g1.s;
					return _gthis.checkStringInterpolation(tok,name,s);
				case 3:
					var n = _g1.s;
					if(n == name) {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 4:
				var n = _g.s;
				if(n == name) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(nameList.length > 1) {
			return;
		}
		this.logPos("Unused local variable " + name,v.pos);
	}
	,checkStringInterpolation: function(tok,name,s) {
		if(!checkstyle_utils_StringUtils.isStringInterpolation(s,this.checker.file.content,tok.pos)) {
			return tokentree_FilterResult.GoDeeper;
		}
		var format = "\\$" + name + "([^_0-9a-zA-Z]|$)";
		var r = new EReg(format,"");
		if(r.match(s)) {
			return tokentree_FilterResult.FoundGoDeeper;
		}
		format = "\\$\\{(|.*[^_0-9a-zA-Z])" + name + "([^_0-9a-zA-Z].*|)\\}";
		r = new EReg(format,"");
		if(r.match(s)) {
			return tokentree_FilterResult.FoundGoDeeper;
		}
		return tokentree_FilterResult.GoDeeper;
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_coding_UnusedLocalVarCheck
});
var checkstyle_checks_coding_VariableInitialisationCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.categories = ["Style","Clarity"];
	this.points = 2;
	this.allowFinal = false;
};
$hxClasses["checkstyle.checks.coding.VariableInitialisationCheck"] = checkstyle_checks_coding_VariableInitialisationCheck;
checkstyle_checks_coding_VariableInitialisationCheck.__name__ = "checkstyle.checks.coding.VariableInitialisationCheck";
checkstyle_checks_coding_VariableInitialisationCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_coding_VariableInitialisationCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	allowFinal: null
	,actualRun: function() {
		this.forEachField($bind(this,this.checkField));
	}
	,checkField: function(f,p) {
		if(f.name == "new" || p.kind == checkstyle_utils_FieldParentKind.INTERFACE || p.kind == checkstyle_utils_FieldParentKind.ENUM_ABSTRACT) {
			return;
		}
		var isPrivate = false;
		var isPublic = false;
		var isInline = f.access.indexOf(haxe_macro_Access.AInline) != -1;
		var isStatic = f.access.indexOf(haxe_macro_Access.AStatic) != -1;
		var isFinal = false;
		if(isInline || isStatic) {
			return;
		}
		if(f.access.indexOf(haxe_macro_Access.APublic) != -1) {
			isPublic = true;
		} else {
			isPrivate = true;
		}
		if(f.access.indexOf(haxe_macro_Access.AFinal) != -1) {
			isFinal = true;
		}
		if(this.allowFinal && isFinal) {
			return;
		}
		if(isPrivate || isPublic) {
			var _g = f.kind;
			if(_g._hx_index == 0) {
				var e = _g.e;
				var t = _g.t;
				if(e == null) {
					return;
				}
				this.warnVarInit(f.name,f.pos);
			}
		}
	}
	,warnVarInit: function(name,pos) {
		this.logPos("Invalid variable initialisation for \"" + name + "\" (move initialisation to constructor or function)",pos);
	}
	,__class__: checkstyle_checks_coding_VariableInitialisationCheck
});
var checkstyle_checks_comments_DocCommentStyleCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.startStyle = "twostars";
	this.lineStyle = "none";
};
$hxClasses["checkstyle.checks.comments.DocCommentStyleCheck"] = checkstyle_checks_comments_DocCommentStyleCheck;
checkstyle_checks_comments_DocCommentStyleCheck.__name__ = "checkstyle.checks.comments.DocCommentStyleCheck";
checkstyle_checks_comments_DocCommentStyleCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_comments_DocCommentStyleCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	startStyle: null
	,lineStyle: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var docTokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:case 1:case 2:case 26:case 27:case 31:case 39:
					return tokentree_FilterResult.FoundGoDeeper;
				case 41:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < docTokens.length) {
			var token = docTokens[_g];
			++_g;
			if(this.isPosSuppressed(token.pos)) {
				continue;
			}
			var prevToken = token.previousSibling;
			if(prevToken == null) {
				continue;
			}
			var _g1 = prevToken.tok;
			if(_g1._hx_index == 7) {
				var text = _g1.s;
				this.checkCommentStyle(prevToken,text);
			}
		}
	}
	,checkCommentStyle: function(token,text) {
		if(text.length <= 0) {
			return;
		}
		switch(this.startStyle) {
		case "ignore":
			break;
		case "none":case "onestar":
			if(text.indexOf("*") == 0 || text.lastIndexOf("*") == text.length - 1) {
				this.logPos("Comment should use '/*…*/'",token.pos,"OneStarStart");
			}
			break;
		case "twostars":
			if(text.indexOf("*") != 0 || text.lastIndexOf("*") != text.length - 1) {
				this.logPos("Comment should use '/**…**/'",token.pos,"TwoStarsStart");
			}
			break;
		}
		if(this.lineStyle == "ignore") {
			return;
		}
		var lines = text.split(this.checker.lineSeparator);
		var oneStar = new EReg("^\\s*\\*","");
		var twoStar = new EReg("^\\s*\\*\\*","");
		var _g = 1;
		var _g1 = lines.length - 1;
		while(_g < _g1) {
			var i = _g++;
			var line = lines[i];
			switch(this.lineStyle) {
			case "ignore":
				break;
			case "none":
				if(oneStar.match(line)) {
					this.logPos("Comment lines should not start with '*'",token.pos,"NoStarsLine");
				}
				break;
			case "onestar":
				if(!oneStar.match(line)) {
					this.logPos("Comment lines should start with '*'",token.pos,"OneStarLine");
				}
				break;
			case "twostars":
				if(!twoStar.match(line)) {
					this.logPos("Comment lines should start with '**'",token.pos,"TwoStarsLine");
				}
				break;
			}
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "startStyle", values : ["onestar","twostars"]},{ propertyName : "lineStyle", values : ["none","onestar","twostars"]}]}];
	}
	,__class__: checkstyle_checks_comments_DocCommentStyleCheck
});
var checkstyle_checks_comments_FieldDocCommentCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.tokens = ["ABSTRACT_DEF","CLASS_DEF","ENUM_DEF","INTERFACE_DEF","TYPEDEF_DEF"];
	this.fieldType = "BOTH";
	this.modifier = "PUBLIC";
	this.requireParams = true;
	this.requireReturn = true;
	this.excludeNames = ["new","toString"];
	this.ignoreOverride = true;
};
$hxClasses["checkstyle.checks.comments.FieldDocCommentCheck"] = checkstyle_checks_comments_FieldDocCommentCheck;
checkstyle_checks_comments_FieldDocCommentCheck.__name__ = "checkstyle.checks.comments.FieldDocCommentCheck";
checkstyle_checks_comments_FieldDocCommentCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_comments_FieldDocCommentCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	tokens: null
	,fieldType: null
	,modifier: null
	,requireParams: null
	,requireReturn: null
	,ignoreOverride: null
	,excludeNames: null
	,hasToken: function(token) {
		if(this.tokens.length != 0) {
			return this.tokens.indexOf(token) != -1;
		} else {
			return true;
		}
	}
	,actualRun: function() {
		var _gthis = this;
		var typeTokens = this.checker.getTokenTree().filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:
					if(_gthis.hasToken("CLASS_DEF")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 26:
					if(_gthis.hasToken("ENUM_DEF")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 27:
					if(_gthis.hasToken("INTERFACE_DEF")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 31:
					if(_gthis.hasToken("TYPEDEF_DEF")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 39:
					if(_gthis.hasToken("ABSTRACT_DEF")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < typeTokens.length) {
			var typeToken = typeTokens[_g];
			++_g;
			if(this.isPosSuppressed(typeToken.pos)) {
				continue;
			}
			var fieldTokens = typeToken.filterCallback(function(token,depth) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 0:
						if(_gthis.fieldType == "FUNCTIONS" || _gthis.fieldType == "BOTH") {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
						break;
					case 2:
						if(_gthis.fieldType == "VARS" || _gthis.fieldType == "BOTH") {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
						break;
					case 41:
						if(_gthis.fieldType == "VARS" || _gthis.fieldType == "BOTH") {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
						break;
					default:
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			var _g1 = 0;
			while(_g1 < fieldTokens.length) {
				var token = fieldTokens[_g1];
				++_g1;
				this.checkField(token,this.isDefaultPublic(typeToken));
			}
		}
	}
	,isDefaultPublic: function(token) {
		var _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 27:
				return true;
			case 31:
				return true;
			case 39:
				return true;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	,checkField: function(token,defaultPublic) {
		if(this.isPosSuppressed(token.pos)) {
			return;
		}
		if(!this.matchesModifier(token,defaultPublic)) {
			return;
		}
		if(this.checkIgnoreOverride(token)) {
			return;
		}
		var name = this.getTypeName(token);
		if(this.excludeNames.indexOf(name) >= 0) {
			return;
		}
		var prevToken = token.previousSibling;
		if(prevToken == null || !prevToken.isComment()) {
			this.logPos("Field \"" + name + "\" should have documentation",checkstyle_utils_PosHelper.getReportPos(token));
			return;
		}
		var _g = prevToken.tok;
		if(_g._hx_index == 7) {
			var text = _g.s;
			this.checkComment(name,token,prevToken,text);
		}
	}
	,checkIgnoreOverride: function(token) {
		if(!this.ignoreOverride) {
			return false;
		}
		var ignoreTokens = token.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 30) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		return ignoreTokens.length > 0;
	}
	,matchesModifier: function(token,defaultPublic) {
		if(this.modifier == "BOTH") {
			return true;
		}
		var modifierList = token.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 18:case 19:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var isPublic = defaultPublic;
		var _g = 0;
		while(_g < modifierList.length) {
			var modToken = modifierList[_g];
			++_g;
			var _g1 = modToken.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 18:
					isPublic = true;
					break;
				case 19:
					isPublic = false;
					break;
				default:
				}
			}
		}
		if(this.modifier == "PUBLIC") {
			return isPublic;
		}
		return !isPublic;
	}
	,getTypeName: function(token) {
		var nameTok = tokentree_TokenTreeAccessHelper.firstChild(token);
		if(nameTok == null) {
			return "<unknown>";
		}
		var _g = nameTok.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 22) {
				return "new";
			} else {
				return "<unknown>";
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var text = _g1.s;
				return text;
			} else {
				return "<unknown>";
			}
			break;
		default:
			return "<unknown>";
		}
	}
	,checkComment: function(name,token,docToken,text) {
		if(text == null || StringTools.trim(text).length <= 0) {
			this.logPos("Documentation for field \"" + name + "\" should contain text",docToken.pos);
			return;
		}
		var lines = text.split(this.checker.lineSeparator);
		if(lines.length < 3) {
			this.logPos("Documentation for field \"" + name + "\" should have at least one extra line of text",docToken.pos);
			return;
		}
		var firstLine = StringTools.trim(lines[1]);
		if(firstLine == "" || firstLine == "*") {
			this.logPos("Documentation for field \"" + name + "\" should have at least one extra line of text",docToken.pos);
		}
		var _g = token.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 0) {
				this.checkFunctionComment(name,token,docToken,text);
			}
		}
	}
	,checkFunctionComment: function(name,token,docToken,text) {
		if(this.requireParams) {
			this.checkParams(name,token,docToken,text);
		}
		if(!this.requireReturn) {
			return;
		}
		var access = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.DblDot);
		var dblDotToken = access;
		if(dblDotToken == null) {
			return;
		}
		var identToken = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(access),tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent("Void")));
		if(identToken != null) {
			return;
		}
		this.checkReturn(name,docToken,text);
	}
	,checkParams: function(fieldName,token,docToken,text) {
		var popenToken = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.POpen);
		if(popenToken == null) {
			return;
		}
		var params = [];
		if(popenToken.children != null) {
			var _g = 0;
			var _g1 = popenToken.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				var _g2 = child.tok;
				if(_g2._hx_index == 2) {
					var _g3 = _g2.c;
					if(_g3._hx_index == 3) {
						var ident = _g3.s;
						params.push(ident);
					}
				}
			}
		}
		this.checkParamsAndOrder(fieldName,params,docToken,text);
	}
	,checkParamsAndOrder: function(fieldName,params,docToken,text) {
		if(params.length <= 0) {
			return;
		}
		var lines = text.split(this.checker.lineSeparator);
		var paramOrder = [];
		var missingParams = [];
		var _g = 0;
		while(_g < params.length) {
			var param = params[_g];
			++_g;
			var search = "@param " + param + " ";
			var index = 0;
			var found = false;
			while(index < lines.length) {
				var line = lines[index++];
				var pos = line.indexOf(search);
				if(pos >= 0) {
					paramOrder.push(index);
					var desc = HxOverrides.substr(line,pos + search.length,null);
					found = !new EReg("^[\\-\\s]*$","").match(desc);
					break;
				}
			}
			if(!found) {
				missingParams.push(param);
			}
		}
		if(missingParams.length > 0) {
			this.logMissingParams(fieldName,missingParams,docToken);
		} else {
			this.checkParamOrder(fieldName,params,paramOrder,docToken);
		}
	}
	,checkParamOrder: function(fieldName,params,paramOrder,docToken) {
		var start = 0;
		var _g = 0;
		var _g1 = paramOrder.length;
		while(_g < _g1) {
			var index = _g++;
			var value = paramOrder[index];
			if(value > start) {
				start = value;
				continue;
			}
			var param = params[index];
			this.logPos("Incorrect order of documentation for parameter \"" + param + "\" of field \"" + fieldName + "\"",docToken.pos);
		}
	}
	,logMissingParams: function(fieldName,params,docToken) {
		var _g = 0;
		while(_g < params.length) {
			var param = params[_g];
			++_g;
			this.logPos("Documentation for parameter \"" + param + "\" of field \"" + fieldName + "\" missing",docToken.pos);
		}
	}
	,checkReturn: function(name,docToken,text) {
		var search = "@return ";
		var pos = text.indexOf(search);
		if(pos < 0) {
			this.logPos("Documentation for return value of field \"" + name + "\" missing",docToken.pos);
			return;
		}
		var desc = HxOverrides.substr(text,pos + search.length,null);
		var lines = desc.split(this.checker.lineSeparator);
		if(lines.length < 0) {
			this.logPos("Documentation for return value of field \"" + name + "\" missing",docToken.pos);
			return;
		}
		if(!new EReg("^[\\-\\s]*$","").match(lines[0])) {
			return;
		}
		this.logPos("Documentation for return value of field \"" + name + "\" missing",docToken.pos);
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "tokens", values : [["ABSTRACT_DEF","CLASS_DEF","ENUM_DEF","INTERFACE_DEF","TYPEDEF_DEF"]]},{ propertyName : "excludeNames", values : [["new","toString"]]},{ propertyName : "modifier", values : ["PUBLIC","BOTH","PRIVATE"]},{ propertyName : "fieldType", values : ["BOTH","FUNCTIONS","VARS"]},{ propertyName : "requireParams", values : [true,false]},{ propertyName : "requireReturn", values : [true,false]},{ propertyName : "ignoreOverride", values : [false,true]}]}];
	}
	,__class__: checkstyle_checks_comments_FieldDocCommentCheck
});
var checkstyle_checks_comments_TODOCommentCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.LINE);
	this.severity = "IGNORE";
	this.format = "^\\s*(TODO|FIXME|HACK|XXX|BUG)";
	this.categories = ["Bug Risk"];
	this.points = 8;
};
$hxClasses["checkstyle.checks.comments.TODOCommentCheck"] = checkstyle_checks_comments_TODOCommentCheck;
checkstyle_checks_comments_TODOCommentCheck.__name__ = "checkstyle.checks.comments.TODOCommentCheck";
checkstyle_checks_comments_TODOCommentCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_comments_TODOCommentCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	format: null
	,actualRun: function() {
		var re = new EReg(this.format,"");
		var _g = 0;
		var _g1 = this.checker.tokens;
		while(_g < _g1.length) {
			var tk = _g1[_g];
			++_g;
			var _g2 = tk.tok;
			switch(_g2._hx_index) {
			case 6:
				var s = _g2.s;
				if(re.match(s)) {
					this.logPos("TODO comment:" + s,tk.pos);
				}
				break;
			case 7:
				var s1 = _g2.s;
				if(re.match(s1)) {
					this.logPos("TODO comment:" + s1,tk.pos);
				}
				break;
			default:
			}
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "format", values : ["^\\s*(TODO|FIXME|HACK|XXX|BUG)"]}]}];
	}
	,__class__: checkstyle_checks_comments_TODOCommentCheck
});
var checkstyle_checks_comments_TypeDocCommentCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.tokens = ["ABSTRACT_DEF","CLASS_DEF","ENUM_DEF","INTERFACE_DEF","TYPEDEF_DEF"];
};
$hxClasses["checkstyle.checks.comments.TypeDocCommentCheck"] = checkstyle_checks_comments_TypeDocCommentCheck;
checkstyle_checks_comments_TypeDocCommentCheck.__name__ = "checkstyle.checks.comments.TypeDocCommentCheck";
checkstyle_checks_comments_TypeDocCommentCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_comments_TypeDocCommentCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	tokens: null
	,hasToken: function(token) {
		if(this.tokens.length != 0) {
			return this.tokens.indexOf(token) != -1;
		} else {
			return true;
		}
	}
	,actualRun: function() {
		var _gthis = this;
		var root = this.checker.getTokenTree();
		var docTokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:
					if(_gthis.hasToken("CLASS_DEF")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 26:
					if(_gthis.hasToken("ENUM_DEF")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 27:
					if(_gthis.hasToken("INTERFACE_DEF")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 31:
					if(_gthis.hasToken("TYPEDEF_DEF")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				case 39:
					if(_gthis.hasToken("ABSTRACT_DEF")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < docTokens.length) {
			var token = docTokens[_g];
			++_g;
			if(this.isPosSuppressed(token.pos)) {
				continue;
			}
			var name = this.getTypeName(token);
			var docToken = this.findDocToken(token);
			if(docToken == null) {
				this.logPos("Type \"" + name + "\" should have documentation",token.pos);
				continue;
			}
			var _g1 = docToken.tok;
			if(_g1._hx_index == 7) {
				var text = _g1.s;
				this.checkComment(name,docToken,text);
			}
		}
	}
	,getTypeName: function(token) {
		var nameTok = tokentree_TokenTreeAccessHelper.firstChild(token);
		if(nameTok == null) {
			return "<unknown>";
		}
		var _g = nameTok.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var text = _g1.s;
				return text;
			} else {
				return "<unknown>";
			}
		} else {
			return "<unknown>";
		}
	}
	,findDocToken: function(token) {
		if(token.previousSibling == null) {
			return null;
		}
		var docToken = token.previousSibling;
		while(docToken != null) {
			var _g = docToken.tok;
			switch(_g._hx_index) {
			case 3:
				var s = _g.s;
				var notAllowed = docToken.filterCallback(function(token,depth) {
					var _g = token.tok;
					if(_g._hx_index == 1) {
						switch(_g.k._hx_index) {
						case 1:case 13:case 26:case 27:case 31:case 35:case 39:
							return tokentree_FilterResult.FoundSkipSubtree;
						default:
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				});
				if(notAllowed.length > 0) {
					return null;
				}
				docToken = docToken.previousSibling;
				break;
			case 7:
				var s1 = _g.s;
				return docToken;
			default:
				return null;
			}
		}
		return null;
	}
	,checkComment: function(name,token,text) {
		if(text == null || StringTools.trim(text).length <= 0) {
			this.logPos("Documentation for type \"" + name + "\" should contain text",token.pos);
			return;
		}
		var lines = text.split(this.checker.lineSeparator);
		if(lines.length < 3) {
			this.logPos("Documentation for type \"" + name + "\" should have at least one extra line of text",token.pos);
			return;
		}
		var firstLine = StringTools.trim(lines[1]);
		if(firstLine == "" || firstLine == "*") {
			this.logPos("Documentation for type \"" + name + "\" should have at least one extra line of text",token.pos);
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "tokens", values : [["ABSTRACT_DEF","CLASS_DEF","ENUM_DEF","INTERFACE_DEF","TYPEDEF_DEF"]]}]}];
	}
	,__class__: checkstyle_checks_comments_TypeDocCommentCheck
});
var checkstyle_checks_design_EmptyPackageCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.enforceEmptyPackage = false;
};
$hxClasses["checkstyle.checks.design.EmptyPackageCheck"] = checkstyle_checks_design_EmptyPackageCheck;
checkstyle_checks_design_EmptyPackageCheck.__name__ = "checkstyle.checks.design.EmptyPackageCheck";
checkstyle_checks_design_EmptyPackageCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_design_EmptyPackageCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	enforceEmptyPackage: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var packageTokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 33) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(this.enforceEmptyPackage) {
			if(packageTokens.length == 0) {
				this.log("Missing package declaration",1,0,1,0,"MissingPackage");
			}
		} else {
			this.checkPackageNames(packageTokens);
		}
	}
	,checkPackageNames: function(entries) {
		var _g = 0;
		while(_g < entries.length) {
			var entry = entries[_g];
			++_g;
			var firstChild = entry.getFirstChild();
			if(firstChild.matches(tokentree_TokenTreeDef.Semicolon)) {
				this.logRange("Found empty package",entry.pos.min,firstChild.pos.max,"RedundantPackage");
			}
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "enforceEmptyPackage", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_design_EmptyPackageCheck
});
var checkstyle_checks_design_InterfaceCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.allowMarkerInterfaces = true;
	this.allowProperties = false;
	this.categories = ["Complexity","Style"];
	this.points = 13;
};
$hxClasses["checkstyle.checks.design.InterfaceCheck"] = checkstyle_checks_design_InterfaceCheck;
checkstyle_checks_design_InterfaceCheck.__name__ = "checkstyle.checks.design.InterfaceCheck";
checkstyle_checks_design_InterfaceCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_design_InterfaceCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	allowMarkerInterfaces: null
	,allowProperties: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var interfaces = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 27) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < interfaces.length) {
			var intr = interfaces[_g];
			++_g;
			var functions = intr.filterCallback(function(token,depth) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					if(_g.k._hx_index == 0) {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			var vars = intr.filterCallback(function(token,depth) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					if(_g.k._hx_index == 2) {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(functions.length == 0 && vars.length == 0) {
				if(this.allowMarkerInterfaces) {
					continue;
				} else {
					this.logPos("Marker interfaces are not allowed",intr.pos);
				}
			}
			if(!this.allowProperties && vars.length > 0) {
				this.logPos("Properties are not allowed in interfaces",intr.pos);
			}
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "allowMarkerInterfaces", values : [true,false]},{ propertyName : "allowProperties", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_design_InterfaceCheck
});
var checkstyle_checks_design_UnnecessaryConstructorCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.categories = ["Bug Risk"];
	this.points = 3;
};
$hxClasses["checkstyle.checks.design.UnnecessaryConstructorCheck"] = checkstyle_checks_design_UnnecessaryConstructorCheck;
checkstyle_checks_design_UnnecessaryConstructorCheck.__name__ = "checkstyle.checks.design.UnnecessaryConstructorCheck";
checkstyle_checks_design_UnnecessaryConstructorCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_design_UnnecessaryConstructorCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var classes = this.findClasses();
		var _g = 0;
		while(_g < classes.length) {
			var cls = classes[_g];
			++_g;
			if(this.extendsBaseClass(cls)) {
				continue;
			}
			if(this.isPosSuppressed(cls.pos)) {
				continue;
			}
			var acceptableTokens = cls.filterCallback(function(token,depth) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 0:case 2:
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			var haveConstructor = false;
			var staticTokens = 0;
			var constructorPos = null;
			var _g1 = 0;
			while(_g1 < acceptableTokens.length) {
				var token = acceptableTokens[_g1];
				++_g1;
				if(token.filterCallback(function(token,depth) {
					if(depth > 2) {
						return tokentree_FilterResult.SkipSubtree;
					}
					var _g = token.tok;
					if(_g._hx_index == 1) {
						if(_g.k._hx_index == 22) {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				}).length > 0) {
					haveConstructor = true;
					constructorPos = token.getPos();
					continue;
				}
				if(token.filterCallback(function(token,depth) {
					if(depth > 2) {
						return tokentree_FilterResult.SkipSubtree;
					}
					var _g = token.tok;
					if(_g._hx_index == 1) {
						if(_g.k._hx_index == 17) {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				}).length > 0) {
					++staticTokens;
					continue;
				}
			}
			if(haveConstructor && acceptableTokens.length > 1 && acceptableTokens.length == staticTokens + 1) {
				this.logPos("Unnecessary constructor found",constructorPos);
			}
		}
	}
	,findClasses: function() {
		return this.checker.getTokenTree().filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 1) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	,extendsBaseClass: function(cls) {
		var clsName = cls.getFirstChild();
		var _g = 0;
		var _g1 = clsName.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtends))) {
				return true;
			}
		}
		return false;
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_design_UnnecessaryConstructorCheck
});
var checkstyle_checks_imports_AvoidStarImportCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.categories = ["Style","Clarity"];
	this.points = 2;
};
$hxClasses["checkstyle.checks.imports.AvoidStarImportCheck"] = checkstyle_checks_imports_AvoidStarImportCheck;
checkstyle_checks_imports_AvoidStarImportCheck.__name__ = "checkstyle.checks.imports.AvoidStarImportCheck";
checkstyle_checks_imports_AvoidStarImportCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_imports_AvoidStarImportCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var root = this.checker.getTokenTree();
		this.checkImports(root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 13) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		}));
	}
	,checkImports: function(importEntries) {
		var _g = 0;
		while(_g < importEntries.length) {
			var entry = importEntries[_g];
			++_g;
			var stars = entry.filterCallback(function(token,depth) {
				var _g = token.tok;
				if(_g._hx_index == 6) {
					if(_g.op._hx_index == 1) {
						return tokentree_FilterResult.FoundGoDeeper;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(stars.length <= 0) {
				continue;
			}
			this.logPos("Using the \".*\" form of import should be avoided",entry.getPos());
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_imports_AvoidStarImportCheck
});
var checkstyle_checks_imports_UnusedImportCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.ignoreModules = [];
	this.moduleTypeMap = { };
	this.categories = ["Style","Clarity","Duplication"];
	this.points = 1;
};
$hxClasses["checkstyle.checks.imports.UnusedImportCheck"] = checkstyle_checks_imports_UnusedImportCheck;
checkstyle_checks_imports_UnusedImportCheck.__name__ = "checkstyle.checks.imports.UnusedImportCheck";
checkstyle_checks_imports_UnusedImportCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_imports_UnusedImportCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	ignoreModules: null
	,moduleTypeMap: null
	,actualRun: function() {
		var _gthis = this;
		var seenModules = [];
		if(this.isImportHx()) {
			return;
		}
		var root = this.checker.getTokenTree();
		var packageName = this.detectPackageName(root);
		var imports = this.findImports(root);
		var idents = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 2) {
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					var _g = _g1.s;
					if(tokentree_utils_TokenTreeCheckUtils.isImport(token)) {
						return tokentree_FilterResult.GoDeeper;
					}
					return tokentree_FilterResult.FoundGoDeeper;
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var stringLiterals = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 2) {
				var _g1 = _g.c;
				if(_g1._hx_index == 2) {
					var _g = _g1.kind;
					var text = _g1.s;
					if(_gthis.checker.getString(token.pos.min,token.pos.min + 1) != "'") {
						return tokentree_FilterResult.GoDeeper;
					}
					if(new EReg("\\$\\{[^\\}]+\\.[^\\}]+\\}","").match(text)) {
						return tokentree_FilterResult.FoundGoDeeper;
					}
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < imports.length) {
			var imp = imports[_g];
			++_g;
			var typeName = this.detectTypeName(imp);
			var moduleName = this.detectModuleName(imp);
			if(typeName == null || moduleName == null) {
				continue;
			}
			if(this.ignoreModules.indexOf(moduleName) != -1) {
				continue;
			}
			if(packageName != null && !this.hasMapping(moduleName) && "" + packageName + "." + typeName == moduleName) {
				this.logPos("Detected import \"" + moduleName + "\" from same package \"" + packageName + "\"",imp.getPos(),"SamePackage");
				continue;
			}
			if(!new EReg("\\.","").match(moduleName)) {
				this.logPos("Unnecessary toplevel import \"" + moduleName + "\" detected",imp.getPos(),"ToplevelImport");
				continue;
			}
			if(seenModules.indexOf(moduleName) != -1) {
				this.logPos("Duplicate import \"" + moduleName + "\" detected",imp.getPos(),"DuplicateImport");
				continue;
			}
			seenModules.push(moduleName);
			this.checkUsage(typeName,moduleName,imp,idents,stringLiterals);
		}
	}
	,findImports: function(root) {
		return root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 13) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	,isImportHx: function() {
		var fileName = haxe_io_Path.withoutDirectory(this.checker.file.name);
		return fileName == "import.hx";
	}
	,detectPackageName: function(root) {
		var packageToken = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 33) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(packageToken == null || packageToken.length <= 0) {
			return null;
		}
		var packageName = this.detectModuleName(packageToken[0]);
		if(packageName == "") {
			packageName = null;
		}
		if(packageToken.length > 1) {
			this.logPos("Multiple package declarations found",packageToken[1].getPos(),"MultiplePackage");
		}
		return packageName;
	}
	,detectModuleName: function(token) {
		var moduleName_b = "";
		while(true) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 13:
					break;
				case 33:
					break;
				default:
					moduleName_b += Std.string(token.toString());
				}
				break;
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "as") {
						if(token.parent.tok._hx_index == 11) {
							moduleName_b += Std.string(token.toString());
						} else {
							moduleName_b += " as ";
						}
					} else {
						moduleName_b += Std.string(token.toString());
					}
				} else {
					moduleName_b += Std.string(token.toString());
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 1:
					return null;
				case 23:
					if(token.parent.tok._hx_index == 11) {
						moduleName_b += Std.string(token.toString());
					} else {
						moduleName_b += " in ";
					}
					break;
				default:
					moduleName_b += Std.string(token.toString());
				}
				break;
			case 10:
				return moduleName_b;
			default:
				moduleName_b += Std.string(token.toString());
			}
			token = token.getFirstChild();
		}
	}
	,detectTypeName: function(token) {
		var lastName = null;
		while(true) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					var name = _g1.s;
					lastName = name;
				}
				break;
			case 6:
				if(_g.op._hx_index == 1) {
					return null;
				}
				break;
			case 10:
				return lastName;
			default:
			}
			token = token.getFirstChild();
		}
	}
	,checkUsage: function(typeName,moduleName,importTok,idents,stringLiterals) {
		var _g = 0;
		while(_g < idents.length) {
			var ident = idents[_g];
			++_g;
			var name = ident.toString();
			if(!this.checkName(typeName,moduleName,name)) {
				continue;
			}
			var _g1 = ident.parent.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 1:case 26:case 27:case 31:case 39:
					continue;
				default:
					return;
				}
				break;
			case 11:
				continue;
			default:
				return;
			}
		}
		var _g = 0;
		while(_g < stringLiterals.length) {
			var literal = stringLiterals[_g];
			++_g;
			var names = this.extractLiteralNames(literal.toString());
			var _g1 = 0;
			while(_g1 < names.length) {
				var name = names[_g1];
				++_g1;
				if(this.checkName(typeName,moduleName,name)) {
					return;
				}
			}
		}
		this.logPos("Unused import \"" + moduleName + "\" detected",importTok.getPos(),"UnusedImport");
	}
	,extractLiteralNames: function(text) {
		var names = [];
		var interpols = [];
		var interpolRegEx = new EReg("\\$\\{([^\\}]+)\\}","g");
		while(interpolRegEx.match(text)) {
			interpols.push(interpolRegEx.matched(1));
			text = interpolRegEx.matchedRight();
		}
		var namesRegEx = new EReg("([A-Z][A-Za-z0-9_]*)","g");
		var _g = 0;
		while(_g < interpols.length) {
			var interpol = interpols[_g];
			++_g;
			while(namesRegEx.match(interpol)) {
				names.push(namesRegEx.matched(1));
				interpol = namesRegEx.matchedRight();
			}
		}
		return names;
	}
	,hasMapping: function(moduleName) {
		var mappedTypes = Reflect.field(this.moduleTypeMap,moduleName);
		if(mappedTypes != null) {
			return mappedTypes.length > 0;
		} else {
			return false;
		}
	}
	,checkName: function(typeName,moduleName,identName) {
		var mappedTypes = Reflect.field(this.moduleTypeMap,moduleName);
		if(mappedTypes == null || mappedTypes.length <= 0) {
			return typeName == identName;
		}
		var _g = 0;
		while(_g < mappedTypes.length) {
			var mappedType = mappedTypes[_g];
			++_g;
			if(mappedType == identName) {
				return true;
			}
		}
		return typeName == identName;
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_imports_UnusedImportCheck
});
var checkstyle_checks_literal_ArrayLiteralCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.literal.ArrayLiteralCheck"] = checkstyle_checks_literal_ArrayLiteralCheck;
checkstyle_checks_literal_ArrayLiteralCheck.__name__ = "checkstyle.checks.literal.ArrayLiteralCheck";
checkstyle_checks_literal_ArrayLiteralCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_literal_ArrayLiteralCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var _gthis = this;
		if(this.checker.ast == null) {
			return;
		}
		checkstyle_utils_ExprUtils.walkFile(this.checker.ast,function(e) {
			var _g = e.expr;
			if(_g._hx_index == 8) {
				var _g1 = _g.params;
				var _g1 = _g.t;
				var _g = _g1.sub;
				var _g = _g1.params;
				if(_g1.name == "Array") {
					if(_g1.pack.length == 0) {
						_gthis.logPos("Bad array instantiation, use the array literal notation \"[]\" which is shorter and cleaner",e.pos);
					}
				}
			}
		});
	}
	,__class__: checkstyle_checks_literal_ArrayLiteralCheck
});
var checkstyle_checks_literal_ERegLiteralCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.literal.ERegLiteralCheck"] = checkstyle_checks_literal_ERegLiteralCheck;
checkstyle_checks_literal_ERegLiteralCheck.__name__ = "checkstyle.checks.literal.ERegLiteralCheck";
checkstyle_checks_literal_ERegLiteralCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_literal_ERegLiteralCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var _gthis = this;
		if(this.checker.ast == null) {
			return;
		}
		checkstyle_utils_ExprUtils.walkFile(this.checker.ast,function(e) {
			if(_gthis.isPosSuppressed(e.pos)) {
				return;
			}
			var _g = e.expr;
			if(_g._hx_index == 8) {
				var _g1 = _g.params;
				var _g2 = _g.t;
				var _g = _g2.sub;
				var _g = _g2.params;
				if(_g2.name == "EReg") {
					if(_g2.pack.length == 0) {
						if(_g1.length == 2) {
							var _g = _g1[1];
							var _g2 = _g1[0];
							var _g1 = _g2.pos;
							var _g1 = _g2.expr;
							if(_g1._hx_index == 0) {
								var _g2 = _g1.c;
								if(_g2._hx_index == 2) {
									var _g1 = _g2.kind;
									var _g1 = _g.pos;
									var _g1 = _g.expr;
									if(_g1._hx_index == 0) {
										var _g = _g1.c;
										if(_g._hx_index == 2) {
											var _g1 = _g.kind;
											var re = _g2.s;
											var opt = _g.s;
											if(new EReg("\\$\\{.+\\}","").match(re)) {
												return;
											}
											_gthis.logPos("Bad EReg instantiation, define expression between \"~/\" and \"/\"",e.pos);
										}
									}
								}
							}
						}
					}
				}
			}
		});
	}
	,__class__: checkstyle_checks_literal_ERegLiteralCheck
});
var checkstyle_checks_literal_HexadecimalLiteralCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.option = "upperCase";
	this.categories = ["Style","Clarity"];
	this.points = 1;
};
$hxClasses["checkstyle.checks.literal.HexadecimalLiteralCheck"] = checkstyle_checks_literal_HexadecimalLiteralCheck;
checkstyle_checks_literal_HexadecimalLiteralCheck.__name__ = "checkstyle.checks.literal.HexadecimalLiteralCheck";
checkstyle_checks_literal_HexadecimalLiteralCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_literal_HexadecimalLiteralCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	option: null
	,actualRun: function() {
		var _gthis = this;
		if(this.checker.ast == null) {
			return;
		}
		checkstyle_utils_ExprUtils.walkFile(this.checker.ast,function(e) {
			var _g = e.expr;
			if(_g._hx_index == 0) {
				var _g1 = _g.c;
				if(_g1._hx_index == 0) {
					var s = _g1.v;
					_gthis.checkString(s,e.pos);
				}
			}
		});
	}
	,checkString: function(s,p) {
		var prefix = HxOverrides.substr(s,0,2);
		if(prefix.toLowerCase() == "0x") {
			var bodyActual = HxOverrides.substr(s,2,null);
			var bodyExpected = bodyActual;
			if(this.option == "lowerCase") {
				bodyExpected = bodyExpected.toLowerCase();
			} else {
				bodyExpected = bodyExpected.toUpperCase();
			}
			if(bodyExpected != bodyActual) {
				this.logPos("Bad hexadecimal literal, use " + this.option,p);
			}
		}
	}
	,__class__: checkstyle_checks_literal_HexadecimalLiteralCheck
});
var checkstyle_checks_literal_MultipleStringLiteralsCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.ignore = "^\\s+$";
	this.allowDuplicates = 2;
	this.minLength = 2;
	this.categories = ["Style","Clarity"];
	this.points = 2;
};
$hxClasses["checkstyle.checks.literal.MultipleStringLiteralsCheck"] = checkstyle_checks_literal_MultipleStringLiteralsCheck;
checkstyle_checks_literal_MultipleStringLiteralsCheck.__name__ = "checkstyle.checks.literal.MultipleStringLiteralsCheck";
checkstyle_checks_literal_MultipleStringLiteralsCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_literal_MultipleStringLiteralsCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	allowDuplicates: null
	,minLength: null
	,ignore: null
	,ignoreRE: null
	,actualRun: function() {
		this.ignoreRE = new EReg(this.ignore,"");
		var root = this.checker.getTokenTree();
		var allLiterals = new haxe_ds_StringMap();
		var allStringLiterals = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 2) {
				var _g1 = _g.c;
				if(_g1._hx_index == 2) {
					var _g = _g1.kind;
					var _g = _g1.s;
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allStringLiterals.length) {
			var literalToken = allStringLiterals[_g];
			++_g;
			if(!this.filterLiteral(literalToken.parent)) {
				continue;
			}
			if(literalToken.parent.tok._hx_index == 17) {
				continue;
			}
			if(this.isPosSuppressed(literalToken.pos)) {
				continue;
			}
			var _g1 = literalToken.tok;
			if(_g1._hx_index == 2) {
				var _g2 = _g1.c;
				if(_g2._hx_index == 2) {
					var _g3 = _g2.kind;
					var s = _g2.s;
					if(checkstyle_utils_StringUtils.isStringInterpolation(s,this.checker.file.content,literalToken.pos)) {
						continue;
					}
					if(this.ignoreRE.match(s)) {
						continue;
					}
					if(s.length < this.minLength) {
						continue;
					}
					if(this.checkLiteralCount(s,allLiterals)) {
						this.logPos("String \"" + s + "\" appears " + allLiterals.h[s] + " times in the file",literalToken.pos);
					}
				}
			}
		}
	}
	,checkLiteralCount: function(literal,map) {
		if(!Object.prototype.hasOwnProperty.call(map.h,literal)) {
			map.h[literal] = 1;
		} else {
			map.h[literal] += 1;
		}
		return map.h[literal] > this.allowDuplicates;
	}
	,filterLiteral: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return true;
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 2) {
				return token.filterCallback(function(token,depth) {
					var _g = token.tok;
					if(_g._hx_index == 1) {
						if(_g.k._hx_index == 17) {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				}).length <= 0;
			} else {
				return this.filterLiteral(token.parent);
			}
			break;
		case 22:
			return false;
		default:
			return this.filterLiteral(token.parent);
		}
	}
	,__class__: checkstyle_checks_literal_MultipleStringLiteralsCheck
});
var checkstyle_checks_literal_StringLiteralCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.policy = "doubleAndInterpolation";
	this.allowException = true;
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.literal.StringLiteralCheck"] = checkstyle_checks_literal_StringLiteralCheck;
checkstyle_checks_literal_StringLiteralCheck.__name__ = "checkstyle.checks.literal.StringLiteralCheck";
checkstyle_checks_literal_StringLiteralCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_literal_StringLiteralCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	policy: null
	,allowException: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var allStringLiterals = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 2) {
				var _g1 = _g.c;
				if(_g1._hx_index == 2) {
					var _g = _g1.kind;
					var _g = _g1.s;
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allStringLiterals.length) {
			var literalToken = allStringLiterals[_g];
			++_g;
			var _g1 = literalToken.tok;
			if(_g1._hx_index == 2) {
				var _g2 = _g1.c;
				if(_g2._hx_index == 2) {
					var _g3 = _g2.kind;
					var s = _g2.s;
					if(this.isPosSuppressed(literalToken.pos)) {
						continue;
					}
					this.checkLiteral(s,literalToken.pos);
				}
			}
		}
	}
	,checkLiteral: function(s,pos) {
		var quote = this.checker.getString(pos.min,pos.min + 1);
		var singleQuote = quote == "'";
		switch(this.policy) {
		case "doubleAndInterpolation":
			if(!singleQuote) {
				return;
			}
			if(checkstyle_utils_StringUtils.isStringInterpolation(s,this.checker.file.content,pos)) {
				return;
			}
			if(this.allowException && new EReg("\"","").match(s)) {
				return;
			}
			this.logPos("String \"" + s + "\" uses single quotes instead of double quotes",pos,"UseDoubleQuotes");
			break;
		case "onlyDouble":
			if(!singleQuote) {
				return;
			}
			if(this.allowException && new EReg("\"","").match(s)) {
				return;
			}
			this.logPos("String \"" + s + "\" uses single quotes instead of double quotes",pos,"UseDoubleQuotes");
			break;
		case "onlySingle":
			if(singleQuote) {
				return;
			}
			if(this.allowException && new EReg("'","").match(s)) {
				return;
			}
			this.logPos("String \"" + s + "\" uses double quotes instead of single quotes",pos,"UseSingleQuotes");
			break;
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "policy", values : ["doubleAndInterpolation","onlySingle","onlyDouble"]},{ propertyName : "allowException", values : [false,true]}]}];
	}
	,__class__: checkstyle_checks_literal_StringLiteralCheck
});
var checkstyle_checks_meta_RedundantAccessMetaBase = function(metaName) {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.metaName = metaName;
	this.prohibitMeta = false;
};
$hxClasses["checkstyle.checks.meta.RedundantAccessMetaBase"] = checkstyle_checks_meta_RedundantAccessMetaBase;
checkstyle_checks_meta_RedundantAccessMetaBase.__name__ = "checkstyle.checks.meta.RedundantAccessMetaBase";
checkstyle_checks_meta_RedundantAccessMetaBase.__super__ = checkstyle_checks_Check;
checkstyle_checks_meta_RedundantAccessMetaBase.prototype = $extend(checkstyle_checks_Check.prototype,{
	prohibitMeta: null
	,metaName: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var docTokens = root.filterCallback(function(token,depth) {
			if(token.tok._hx_index == 22) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var infos = [];
		var _g = 0;
		while(_g < docTokens.length) {
			var token = docTokens[_g];
			++_g;
			if(this.isPosSuppressed(token.pos)) {
				continue;
			}
			var target = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.DblDot)),tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent(this.metaName)))),tokentree_TokenTreeDef.POpen));
			if(target == null) {
				continue;
			}
			if(this.prohibitMeta) {
				this.logForbidden(token,this.getTargetName(target));
				continue;
			}
			var parent = token.parent;
			if(parent == null) {
				continue;
			}
			var info = { name : this.getTargetName(target), ident : parent.toString(), token : token, pos : parent.getPos()};
			if(this.filerParent(parent,info)) {
				continue;
			}
			this.checkAndAdd(infos,info);
		}
	}
	,filerParent: function(parent,info) {
		return false;
	}
	,checkAndAdd: function(infos,newInfo) {
		var _g = 0;
		while(_g < infos.length) {
			var info = infos[_g];
			++_g;
			if(info.pos.min >= newInfo.pos.max || info.pos.max <= newInfo.pos.min) {
				continue;
			}
			if(newInfo.name == info.name || StringTools.startsWith(newInfo.name,"" + info.name + ".")) {
				this.logPos("Redundant \"@:" + this.metaName + "(" + newInfo.name + ")\" for field \"" + newInfo.ident + "\" detected",newInfo.token.getPos());
				break;
			}
		}
		infos.push(newInfo);
	}
	,logForbidden: function(token,name) {
		this.logPos("Consider removing \"@:" + this.metaName + "(" + name + ")\"",token.getPos());
	}
	,getTargetName: function(token) {
		var result = "";
		while(token != null) {
			result += token.toString();
			token = token.getFirstChild();
		}
		return result;
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_meta_RedundantAccessMetaBase
});
var checkstyle_checks_meta_RedundantAccessMetaCheck = function() {
	checkstyle_checks_meta_RedundantAccessMetaBase.call(this,"access");
};
$hxClasses["checkstyle.checks.meta.RedundantAccessMetaCheck"] = checkstyle_checks_meta_RedundantAccessMetaCheck;
checkstyle_checks_meta_RedundantAccessMetaCheck.__name__ = "checkstyle.checks.meta.RedundantAccessMetaCheck";
checkstyle_checks_meta_RedundantAccessMetaCheck.__super__ = checkstyle_checks_meta_RedundantAccessMetaBase;
checkstyle_checks_meta_RedundantAccessMetaCheck.prototype = $extend(checkstyle_checks_meta_RedundantAccessMetaBase.prototype,{
	__class__: checkstyle_checks_meta_RedundantAccessMetaCheck
});
var checkstyle_checks_meta_RedundantAllowMetaCheck = function() {
	checkstyle_checks_meta_RedundantAccessMetaBase.call(this,"allow");
};
$hxClasses["checkstyle.checks.meta.RedundantAllowMetaCheck"] = checkstyle_checks_meta_RedundantAllowMetaCheck;
checkstyle_checks_meta_RedundantAllowMetaCheck.__name__ = "checkstyle.checks.meta.RedundantAllowMetaCheck";
checkstyle_checks_meta_RedundantAllowMetaCheck.__super__ = checkstyle_checks_meta_RedundantAccessMetaBase;
checkstyle_checks_meta_RedundantAllowMetaCheck.prototype = $extend(checkstyle_checks_meta_RedundantAccessMetaBase.prototype,{
	filerParent: function(parent,info) {
		var access = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdPublic));
		if(access == null) {
			return false;
		}
		this.logPos("Redundant \"@:allow(" + info.name + ")\" for public field \"" + info.ident + "\" detected",info.token.getPos());
		return true;
	}
	,__class__: checkstyle_checks_meta_RedundantAllowMetaCheck
});
var checkstyle_checks_metrics_CyclomaticComplexityCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.thresholds = [{ severity : "WARNING", complexity : checkstyle_checks_metrics_CyclomaticComplexityCheck.DEFAULT_COMPLEXITY_WARNING},{ severity : "ERROR", complexity : checkstyle_checks_metrics_CyclomaticComplexityCheck.DEFAULT_COMPLEXITY_ERROR}];
	this.categories = ["Complexity"];
	this.points = 13;
};
$hxClasses["checkstyle.checks.metrics.CyclomaticComplexityCheck"] = checkstyle_checks_metrics_CyclomaticComplexityCheck;
checkstyle_checks_metrics_CyclomaticComplexityCheck.__name__ = "checkstyle.checks.metrics.CyclomaticComplexityCheck";
checkstyle_checks_metrics_CyclomaticComplexityCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_metrics_CyclomaticComplexityCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	thresholds: null
	,actualRun: function() {
		var _gthis = this;
		this.forEachField(function(field,_) {
			var _g = field.kind;
			if(_g._hx_index == 1) {
				var f = _g.f;
				_gthis.calculateComplexity({ name : field.name, expr : f.expr, pos : field.pos});
			}
		});
	}
	,calculateComplexity: function(method) {
		var complexity = 1 + this.evaluateExpr(method.expr);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.thresholds;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(complexity >= v.complexity && v.severity != "IGNORE") {
				_g.push(v);
			}
		}
		var risk = _g.pop();
		if(risk != null) {
			this.notify(method,complexity,risk);
		}
	}
	,evaluateExpr: function(e) {
		var _gthis = this;
		if(e == null || e.expr == null) {
			return 0;
		}
		var _g = e.expr;
		switch(_g._hx_index) {
		case 1:
			var e2 = _g.e2;
			var e1 = _g.e1;
			return this.evaluateExpr(e1) + this.evaluateExpr(e2);
		case 2:
			var e2 = _g.e2;
			var e1 = _g.e1;
			var op = _g.op;
			var tmp = this.evaluateExpr(e1) + this.evaluateExpr(e2);
			var tmp1;
			switch(op._hx_index) {
			case 14:
				tmp1 = 1;
				break;
			case 15:
				tmp1 = 1;
				break;
			default:
				tmp1 = 0;
			}
			return tmp + tmp1;
		case 4:
			var e = _g.e;
			return this.evaluateExpr(e);
		case 5:
			var fields = _g.fields;
			var result = new Array(fields.length);
			var _g1 = 0;
			var _g2 = fields.length;
			while(_g1 < _g2) {
				var i = _g1++;
				result[i] = fields[i].expr;
			}
			return Lambda.fold(result,function(e,total) {
				return total + _gthis.evaluateExpr(e);
			},0);
		case 6:
			var values = _g.values;
			return Lambda.fold(values,function(e,total) {
				return total + _gthis.evaluateExpr(e);
			},0);
		case 12:
			var exprs = _g.exprs;
			return Lambda.fold(exprs,function(e,total) {
				return total + _gthis.evaluateExpr(e);
			},0);
		case 13:
			var e = _g.expr;
			var it = _g.it;
			return 1 + this.evaluateExpr(it) + this.evaluateExpr(e);
		case 14:
			var eelse = _g.eelse;
			var eif = _g.eif;
			var econd = _g.econd;
			return 1 + this.evaluateExpr(econd) + this.evaluateExpr(eif) + this.evaluateExpr(eelse);
		case 15:
			var _g1 = _g.normalWhile;
			var e = _g.e;
			var econd = _g.econd;
			return 1 + this.evaluateExpr(econd) + this.evaluateExpr(e);
		case 16:
			var def = _g.edef;
			var cases = _g.cases;
			var e = _g.e;
			var tmp = this.evaluateExpr(def);
			var result = new Array(cases.length);
			var _g1 = 0;
			var _g2 = cases.length;
			while(_g1 < _g2) {
				var i = _g1++;
				result[i] = cases[i].expr;
			}
			return tmp + Lambda.fold(result,function(e,total) {
				return total + 1 + _gthis.evaluateExpr(e);
			},0);
		case 17:
			var catches = _g.catches;
			var e = _g.e;
			var result = new Array(catches.length);
			var _g1 = 0;
			var _g2 = catches.length;
			while(_g1 < _g2) {
				var i = _g1++;
				result[i] = catches[i].expr;
			}
			return Lambda.fold(result,function(e,total) {
				return total + 1 + _gthis.evaluateExpr(e);
			},0);
		case 18:
			var e = _g.e;
			if(e != null) {
				return this.evaluateExpr(e);
			} else {
				return 0;
			}
			break;
		case 21:
			var e = _g.e;
			return this.evaluateExpr(e);
		case 22:
			var e = _g.e;
			return this.evaluateExpr(e);
		case 23:
			var _g1 = _g.t;
			var e = _g.e;
			return this.evaluateExpr(e);
		case 24:
			var _g1 = _g.displayKind;
			var e = _g.e;
			return this.evaluateExpr(e);
		case 26:
			var eelse = _g.eelse;
			var eif = _g.eif;
			var econd = _g.econd;
			return 1 + this.evaluateExpr(econd) + this.evaluateExpr(eif) + this.evaluateExpr(eelse);
		case 27:
			var _g1 = _g.t;
			var e = _g.e;
			return this.evaluateExpr(e);
		default:
			return 0;
		}
	}
	,notify: function(method,complexity,risk) {
		this.logPos("Method \"" + method.name + "\" is too complex (score: " + complexity + ").",method.pos,null,risk.severity);
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "thresholds", values : [[{ severity : "WARNING", complexity : 6},{ severity : "ERROR", complexity : 16}],[{ severity : "WARNING", complexity : 11},{ severity : "ERROR", complexity : 21}],[{ severity : "WARNING", complexity : 16},{ severity : "ERROR", complexity : 26}],[{ severity : "WARNING", complexity : 21},{ severity : "ERROR", complexity : 31}]]}]}];
	}
	,__class__: checkstyle_checks_metrics_CyclomaticComplexityCheck
});
var checkstyle_checks_modifier_FinalCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.categories = ["Style","Clarity"];
	this.points = 1;
};
$hxClasses["checkstyle.checks.modifier.FinalCheck"] = checkstyle_checks_modifier_FinalCheck;
checkstyle_checks_modifier_FinalCheck.__name__ = "checkstyle.checks.modifier.FinalCheck";
checkstyle_checks_modifier_FinalCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_modifier_FinalCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		this.forEachField($bind(this,this.checkField));
	}
	,checkField: function(f,p) {
		var _g = f.kind;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.e;
			var _g1 = _g.t;
			break;
		case 1:
			var _g1 = _g.f;
			return;
		case 2:
			var _g1 = _g.e;
			var _g1 = _g.t;
			var _g1 = _g.set;
			var _g1 = _g.get;
			return;
		}
		if(f.access.indexOf(haxe_macro_Access.AFinal) != -1) {
			return;
		}
		if(this.checkInlineVar(f)) {
			this.logPos("Consider using \"inline final\" for field \"" + f.name + "\"",f.pos,"UseInlineFinal");
			return;
		}
		if(this.checkPublicStatic(f)) {
			this.logPos("Consider making public static field \"" + f.name + "\" \"final\" or \"private\"",f.pos,"ShouldBePublicFinal");
			return;
		}
	}
	,checkPublicStatic: function(f) {
		if(f.access.indexOf(haxe_macro_Access.APublic) != -1) {
			return f.access.indexOf(haxe_macro_Access.AStatic) != -1;
		} else {
			return false;
		}
	}
	,checkInlineVar: function(f) {
		return f.access.indexOf(haxe_macro_Access.AInline) != -1;
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_modifier_FinalCheck
});
var checkstyle_checks_modifier_ModifierOrderCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.modifiers = ["MACRO","OVERRIDE","PUBLIC_PRIVATE","STATIC","INLINE","DYNAMIC","FINAL"];
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.modifier.ModifierOrderCheck"] = checkstyle_checks_modifier_ModifierOrderCheck;
checkstyle_checks_modifier_ModifierOrderCheck.__name__ = "checkstyle.checks.modifier.ModifierOrderCheck";
checkstyle_checks_modifier_ModifierOrderCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_modifier_ModifierOrderCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	modifiers: null
	,actualRun: function() {
		this.forEachField($bind(this,this.checkField));
	}
	,checkField: function(f,_) {
		var lastIndex = -1;
		var index;
		var actual = [];
		var expected = [];
		expected.length = this.modifiers.length;
		var compliant = true;
		var _g = 0;
		var _g1 = f.access;
		while(_g < _g1.length) {
			var access = _g1[_g];
			++_g;
			var modifier = checkstyle_checks_modifier_ModifierOrderCheckModifier.fromAccess(access);
			index = this.modifiers.indexOf(modifier);
			if(index < 0) {
				continue;
			}
			actual.push(checkstyle_checks_modifier_ModifierOrderCheckModifier.accessToString(access));
			expected[index] = checkstyle_checks_modifier_ModifierOrderCheckModifier.accessToString(access);
			if(index < lastIndex) {
				compliant = false;
			}
			lastIndex = index;
		}
		if(compliant) {
			return;
		}
		var pos = this.calcPos(f);
		this.warnOrder(f.name,actual,expected,pos);
	}
	,calcPos: function(f) {
		var _g = f.kind;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.e;
			var _g1 = _g.t;
			return f.pos;
		case 1:
			var fun = _g.f;
			if(fun.expr == null) {
				return f.pos;
			}
			return haxe_macro_PositionTools.make({ min : f.pos.min, max : fun.expr.pos.min, file : f.pos.file});
		case 2:
			var _g1 = _g.e;
			var _g1 = _g.t;
			var _g1 = _g.set;
			var _g1 = _g.get;
			return f.pos;
		}
	}
	,warnOrder: function(name,actual,expected,pos) {
		var _g = [];
		var _g1 = 0;
		var _g2 = expected;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v != null) {
				_g.push(v);
			}
		}
		expected = _g;
		this.logPos("modifier order for field \"" + name + "\" is \"" + actual.join(" ") + "\" but should be \"" + expected.join(" ") + "\"",pos);
	}
	,__class__: checkstyle_checks_modifier_ModifierOrderCheck
});
var checkstyle_checks_modifier_ModifierOrderCheckModifier = {};
checkstyle_checks_modifier_ModifierOrderCheckModifier.fromAccess = function(access) {
	switch(access._hx_index) {
	case 0:case 1:
		return "PUBLIC_PRIVATE";
	case 2:
		return "STATIC";
	case 3:
		return "OVERRIDE";
	case 4:
		return "DYNAMIC";
	case 5:
		return "INLINE";
	case 6:
		return "MACRO";
	case 7:
		return "FINAL";
	case 8:
		return "EXTERN";
	}
};
checkstyle_checks_modifier_ModifierOrderCheckModifier.accessToString = function(access) {
	switch(access._hx_index) {
	case 0:
		return "public";
	case 1:
		return "private";
	case 2:
		return "static";
	case 3:
		return "override";
	case 4:
		return "dynamic";
	case 5:
		return "inline";
	case 6:
		return "macro";
	case 7:
		return "final";
	case 8:
		return "extern";
	}
};
var checkstyle_checks_modifier_PublicAccessorCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.categories = ["Style","Clarity"];
	this.points = 1;
};
$hxClasses["checkstyle.checks.modifier.PublicAccessorCheck"] = checkstyle_checks_modifier_PublicAccessorCheck;
checkstyle_checks_modifier_PublicAccessorCheck.__name__ = "checkstyle.checks.modifier.PublicAccessorCheck";
checkstyle_checks_modifier_PublicAccessorCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_modifier_PublicAccessorCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		this.forEachField($bind(this,this.checkField));
	}
	,checkField: function(f,p) {
		var _g = f.kind;
		var tmp;
		if(_g._hx_index == 1) {
			var _g1 = _g.f;
			tmp = true;
		} else {
			tmp = false;
		}
		if(!tmp) {
			return;
		}
		if(!StringTools.startsWith(f.name,"set_") && !StringTools.startsWith(f.name,"get_")) {
			return;
		}
		var isDefaultPrivate = checkstyle_utils_FieldUtils.isDefaultPrivate(f,p);
		if(isDefaultPrivate && f.access.indexOf(haxe_macro_Access.APublic) == -1) {
			return;
		} else if(!isDefaultPrivate && f.access.indexOf(haxe_macro_Access.APrivate) != -1) {
			return;
		}
		this.logPos("Accessor method should not be public",f.pos);
	}
	,__class__: checkstyle_checks_modifier_PublicAccessorCheck
});
var checkstyle_checks_modifier_RedundantModifierCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.enforcePublicPrivate = false;
	this.enforcePublic = false;
	this.enforcePrivate = false;
	this.categories = ["Style","Clarity"];
	this.points = 1;
};
$hxClasses["checkstyle.checks.modifier.RedundantModifierCheck"] = checkstyle_checks_modifier_RedundantModifierCheck;
checkstyle_checks_modifier_RedundantModifierCheck.__name__ = "checkstyle.checks.modifier.RedundantModifierCheck";
checkstyle_checks_modifier_RedundantModifierCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_modifier_RedundantModifierCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	enforcePublicPrivate: null
	,enforcePublic: null
	,enforcePrivate: null
	,actualRun: function() {
		var _gthis = this;
		var forcePrivate = this.enforcePrivate;
		var forcePublic = this.enforcePublic;
		if(this.enforcePublicPrivate) {
			forcePrivate = true;
			forcePublic = true;
		}
		this.forEachField(function(f,p) {
			_gthis.checkField(f,p,forcePrivate,forcePublic);
		});
	}
	,checkField: function(f,p,forcePrivate,forcePublic) {
		var isDefaultPrivate = checkstyle_utils_FieldUtils.isDefaultPrivate(f,p);
		var implicitAccess = isDefaultPrivate ? "private" : "public";
		var missingCode = isDefaultPrivate ? "MissingPrivate" : "MissingPublic";
		var redundantCode = isDefaultPrivate ? "RedundantPrivate" : "RedundantPublic";
		if(f.access.indexOf(haxe_macro_Access.APublic) == -1 && f.access.indexOf(haxe_macro_Access.APrivate) == -1) {
			if(!isDefaultPrivate && forcePublic || isDefaultPrivate && forcePrivate) {
				this.logPos("Missing \"" + implicitAccess + "\" keyword for \"" + f.name + "\"",checkstyle_utils_PosHelper.makeFieldSignaturePosition(f),missingCode);
			}
		}
		if(!forcePrivate && isDefaultPrivate && f.access.indexOf(haxe_macro_Access.APrivate) != -1 || !forcePublic && !isDefaultPrivate && f.access.indexOf(haxe_macro_Access.APublic) != -1) {
			this.logPos("\"" + implicitAccess + "\" keyword is redundant for \"" + f.name + "\"",checkstyle_utils_PosHelper.makeFieldSignaturePosition(f),redundantCode);
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "enforcePrivate", values : [true,false]},{ propertyName : "enforcePublic", values : [true,false]},{ propertyName : "enforcePublicPrivate", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_modifier_RedundantModifierCheck
});
var checkstyle_checks_naming_CatchParameterNameCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.format = "^(e|t|ex|[a-z][a-z][a-zA-Z]+)$";
};
$hxClasses["checkstyle.checks.naming.CatchParameterNameCheck"] = checkstyle_checks_naming_CatchParameterNameCheck;
checkstyle_checks_naming_CatchParameterNameCheck.__name__ = "checkstyle.checks.naming.CatchParameterNameCheck";
checkstyle_checks_naming_CatchParameterNameCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_naming_CatchParameterNameCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	format: null
	,actualRun: function() {
		var formatRE = new EReg(this.format,"");
		var root = this.checker.getTokenTree();
		var catchTokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 21) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < catchTokens.length) {
			var tkn = catchTokens[_g];
			++_g;
			var _g1 = 0;
			var _g2 = tkn.children;
			while(_g1 < _g2.length) {
				var item = _g2[_g1];
				++_g1;
				var child = item.getFirstChild();
				if(child == null) {
					continue;
				}
				var _g3 = child.tok;
				if(_g3._hx_index == 2) {
					var _g4 = _g3.c;
					if(_g4._hx_index == 3) {
						var name = _g4.s;
						if(item.matches(tokentree_TokenTreeDef.POpen)) {
							if(!formatRE.match(name)) {
								this.logPos("\"" + name + "\" must match pattern \"~/" + this.format + "/\"",item.pos);
							}
							continue;
						}
					}
				}
			}
		}
	}
	,__class__: checkstyle_checks_naming_CatchParameterNameCheck
});
var checkstyle_checks_naming_NameCheckBase = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.format = "^.*$";
	this.tokens = [];
	this.ignoreExtern = true;
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.naming.NameCheckBase"] = checkstyle_checks_naming_NameCheckBase;
checkstyle_checks_naming_NameCheckBase.__name__ = "checkstyle.checks.naming.NameCheckBase";
checkstyle_checks_naming_NameCheckBase.__super__ = checkstyle_checks_Check;
checkstyle_checks_naming_NameCheckBase.prototype = $extend(checkstyle_checks_Check.prototype,{
	format: null
	,tokens: null
	,ignoreExtern: null
	,formatRE: null
	,hasToken: function(token) {
		if(this.tokens.length != 0) {
			return this.tokens.indexOf(token) != -1;
		} else {
			return true;
		}
	}
	,actualRun: function() {
		this.formatRE = new EReg(this.format,"");
		this.checkClassFields();
	}
	,checkClassFields: function() {
		if(this.checker.ast == null) {
			return;
		}
		var _g = 0;
		var _g1 = this.checker.ast.decls;
		while(_g < _g1.length) {
			var td = _g1[_g];
			++_g;
			var _g2 = td.decl;
			switch(_g2._hx_index) {
			case 0:
				var d = _g2.d;
				this.checkClassType(td.decl,d,td.pos);
				break;
			case 1:
				var d1 = _g2.d;
				this.checkEnumType(td.decl,d1,td.pos);
				break;
			case 2:
				var d2 = _g2.d;
				this.checkTypedefType(td.decl,d2,td.pos);
				break;
			case 3:
				var d3 = _g2.a;
				this.checkAbstractType(td.decl,d3,td.pos);
				break;
			default:
			}
		}
	}
	,checkClassType: function(decl,d,pos) {
	}
	,checkEnumType: function(decl,d,pos) {
	}
	,checkAbstractType: function(decl,d,pos) {
	}
	,checkTypedefType: function(decl,d,pos) {
	}
	,matchTypeName: function(type,name,pos) {
		if(!this.formatRE.match(name)) {
			this.warn(type,name,pos);
		}
	}
	,warn: function(type,name,pos) {
		this.logPos("Invalid " + type + " signature: \"" + name + "\" (name should be \"~/" + this.format + "/\")",pos);
	}
	,__class__: checkstyle_checks_naming_NameCheckBase
});
var checkstyle_checks_naming_ConstantNameCheck = function() {
	checkstyle_checks_naming_NameCheckBase.call(this);
	this.format = "^[A-Z][A-Z0-9]*(_[A-Z0-9_]+)*$";
};
$hxClasses["checkstyle.checks.naming.ConstantNameCheck"] = checkstyle_checks_naming_ConstantNameCheck;
checkstyle_checks_naming_ConstantNameCheck.__name__ = "checkstyle.checks.naming.ConstantNameCheck";
checkstyle_checks_naming_ConstantNameCheck.__super__ = checkstyle_checks_naming_NameCheckBase;
checkstyle_checks_naming_ConstantNameCheck.prototype = $extend(checkstyle_checks_naming_NameCheckBase.prototype,{
	checkClassType: function(decl,d,pos) {
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_ClassFlag.HExtern) != -1) {
			return;
		}
		this.checkFields(d.data,checkstyle_utils_FieldUtils.toParentType(decl));
	}
	,checkEnumType: function(decl,d,pos) {
	}
	,checkAbstractType: function(decl,d,pos) {
		this.checkFields(d.data,checkstyle_utils_FieldUtils.toParentType(decl));
	}
	,checkTypedefType: function(decl,d,pos) {
	}
	,checkFields: function(d,p) {
		var _g = 0;
		while(_g < d.length) {
			var field = d[_g];
			++_g;
			if(this.isCheckSuppressed(field)) {
				continue;
			}
			var _g1 = field.kind;
			if(_g1._hx_index == 0) {
				var e = _g1.e;
				var t = _g1.t;
				this.checkField(field,t,e,p);
			}
		}
	}
	,checkField: function(f,t,e,p) {
		if(e == null || e.expr == null || !checkstyle_utils_FieldUtils.isStatic(f,p)) {
			return;
		}
		if(!this.hasToken("INLINE") && checkstyle_utils_FieldUtils.isInline(f,p)) {
			return;
		}
		if(!this.hasToken("NOTINLINE") && !checkstyle_utils_FieldUtils.isInline(f,p)) {
			return;
		}
		this.matchTypeName("const",f.name,f.pos);
	}
	,detectableInstances: function() {
		var instanceInline = { fixed : [{ propertyName : "tokens", value : ["INLINE"]}], properties : [{ propertyName : "format", values : ["^[A-Z][A-Z0-9]*(_[A-Z0-9_]+)*$","^[A-Z]+[a-zA-Z0-9]*$","^[a-z][a-zA-Z0-9]*$"]},{ propertyName : "ignoreExtern", values : [true,false]}]};
		var instanceNotInline = { fixed : [{ propertyName : "tokens", value : ["NOTINLINE"]}], properties : [{ propertyName : "format", values : ["^[A-Z][A-Z0-9]*(_[A-Z0-9_]+)*$","^[A-Z]+[a-zA-Z0-9]*$","^[a-z][a-zA-Z0-9]*$"]},{ propertyName : "ignoreExtern", values : [true,false]}]};
		return [instanceInline,instanceNotInline];
	}
	,__class__: checkstyle_checks_naming_ConstantNameCheck
});
var checkstyle_checks_naming_ListenerNameCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.listeners = ["addEventListener","addListener","on","once"];
	this.format = "^_?[a-z][a-zA-Z0-9]*$";
};
$hxClasses["checkstyle.checks.naming.ListenerNameCheck"] = checkstyle_checks_naming_ListenerNameCheck;
checkstyle_checks_naming_ListenerNameCheck.__name__ = "checkstyle.checks.naming.ListenerNameCheck";
checkstyle_checks_naming_ListenerNameCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_naming_ListenerNameCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	listeners: null
	,format: null
	,formatRE: null
	,actualRun: function() {
		var _gthis = this;
		checkstyle_utils_ExprUtils.walkFile(this.checker.ast,function(e) {
			if(_gthis.isPosSuppressed(e.pos)) {
				return;
			}
			var _g = e.expr;
			if(_g._hx_index == 7) {
				var params = _g.params;
				var e = _g.e;
				_gthis.searchCall(e,params);
			}
		});
	}
	,searchCall: function(e,p) {
		var _g = 0;
		var _g1 = this.listeners;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			if(this.searchLeftCall(e,listener)) {
				this.searchCallParam(p);
			}
		}
	}
	,searchLeftCall: function(e,name) {
		var _g = e.expr;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var ident = _g1.s;
				return ident == name;
			} else {
				return false;
			}
			break;
		case 3:
			var field = _g.field;
			var e2 = _g.e;
			return field == name;
		default:
			return false;
		}
	}
	,searchCallParam: function(p) {
		if(p.length < 2) {
			return;
		}
		var listener = p[1];
		var _g = listener.expr;
		if(_g._hx_index == 0) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var ident = _g1.s;
				this.checkListenerName(ident,listener.pos);
			}
		}
	}
	,checkListenerName: function(name,pos) {
		this.formatRE = new EReg(this.format,"");
		var match = this.formatRE.match(name);
		if(!match) {
			this.logPos("Wrong listener name: \"" + name + "\" (should be \"~/" + this.format + "/\")",pos);
		}
	}
	,__class__: checkstyle_checks_naming_ListenerNameCheck
});
var checkstyle_checks_naming_LocalVariableNameCheck = function() {
	checkstyle_checks_naming_NameCheckBase.call(this);
	this.format = "^[a-z][a-zA-Z0-9]*$";
};
$hxClasses["checkstyle.checks.naming.LocalVariableNameCheck"] = checkstyle_checks_naming_LocalVariableNameCheck;
checkstyle_checks_naming_LocalVariableNameCheck.__name__ = "checkstyle.checks.naming.LocalVariableNameCheck";
checkstyle_checks_naming_LocalVariableNameCheck.__super__ = checkstyle_checks_naming_NameCheckBase;
checkstyle_checks_naming_LocalVariableNameCheck.prototype = $extend(checkstyle_checks_naming_NameCheckBase.prototype,{
	actualRun: function() {
		var _gthis = this;
		this.formatRE = new EReg(this.format,"");
		if(this.checker.ast == null) {
			return;
		}
		checkstyle_utils_ExprUtils.walkFile(this.checker.ast,function(e) {
			var _g = e.expr;
			if(_g._hx_index == 10) {
				var vars = _g.vars;
				if(_gthis.ignoreExtern && _gthis.isPosExtern(e.pos)) {
					return;
				}
				if(_gthis.isPosSuppressed(e.pos)) {
					return;
				}
				var _g = 0;
				while(_g < vars.length) {
					var v = vars[_g];
					++_g;
					_gthis.matchTypeName("local var",v.name,e.pos);
				}
			}
		});
	}
	,__class__: checkstyle_checks_naming_LocalVariableNameCheck
});
var checkstyle_checks_naming_MemberNameCheck = function() {
	checkstyle_checks_naming_NameCheckBase.call(this);
	this.format = "^[a-z][a-zA-Z0-9]*$";
};
$hxClasses["checkstyle.checks.naming.MemberNameCheck"] = checkstyle_checks_naming_MemberNameCheck;
checkstyle_checks_naming_MemberNameCheck.__name__ = "checkstyle.checks.naming.MemberNameCheck";
checkstyle_checks_naming_MemberNameCheck.__super__ = checkstyle_checks_naming_NameCheckBase;
checkstyle_checks_naming_MemberNameCheck.prototype = $extend(checkstyle_checks_naming_NameCheckBase.prototype,{
	checkClassType: function(decl,d,pos) {
		if(!this.hasToken("CLASS")) {
			if(this.hasToken("ABSTRACT")) {
				return;
			}
			if(!this.hasToken("PUBLIC") && !this.hasToken("PRIVATE")) {
				return;
			}
		}
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_ClassFlag.HExtern) != -1) {
			return;
		}
		this.checkFields(d.data,checkstyle_utils_FieldUtils.toParentType(decl));
	}
	,checkEnumType: function(decl,d,pos) {
		if(!this.hasToken("ENUM")) {
			return;
		}
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_EnumFlag.EExtern) != -1) {
			return;
		}
		if(this.isPosSuppressed(pos)) {
			return;
		}
		this.checkEnumFields(d.data);
	}
	,checkAbstractType: function(decl,d,pos) {
		if(!this.hasToken("ABSTRACT")) {
			if(this.hasToken("CLASS")) {
				return;
			}
			if(!this.hasToken("PUBLIC") && !this.hasToken("PRIVATE")) {
				return;
			}
		}
		this.checkFields(d.data,checkstyle_utils_FieldUtils.toParentType(decl));
	}
	,checkTypedefType: function(decl,d,pos) {
		if(!this.hasToken("TYPEDEF")) {
			return;
		}
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_EnumFlag.EExtern) != -1) {
			return;
		}
		var _g = d.data;
		if(_g._hx_index == 2) {
			var f = _g.fields;
			this.checkTypedefFields(f);
		}
	}
	,checkFields: function(d,p) {
		var _g = 0;
		while(_g < d.length) {
			var field = d[_g];
			++_g;
			if(this.isCheckSuppressed(field)) {
				continue;
			}
			var _g1 = field.kind;
			switch(_g1._hx_index) {
			case 0:
				var e = _g1.e;
				var t = _g1.t;
				this.checkField(field,t,e,p);
				break;
			case 2:
				var _g2 = _g1.set;
				var _g3 = _g1.get;
				var e1 = _g1.e;
				var t1 = _g1.t;
				this.checkField(field,t1,e1,p);
				break;
			default:
			}
		}
	}
	,checkTypedefFields: function(d) {
		var _g = 0;
		while(_g < d.length) {
			var field = d[_g];
			++_g;
			if(this.isCheckSuppressed(field)) {
				continue;
			}
			var _g1 = field.kind;
			if(_g1._hx_index == 0) {
				var e = _g1.e;
				var t = _g1.t;
				this.checkTypedefField(field,t,e);
			}
		}
	}
	,checkEnumFields: function(d) {
		var _g = 0;
		while(_g < d.length) {
			var field = d[_g];
			++_g;
			this.matchTypeName("enum member",field.name,field.pos);
		}
	}
	,checkField: function(f,t,e,p) {
		if(checkstyle_utils_FieldUtils.isStatic(f,p)) {
			return;
		}
		if(this.hasToken("PUBLIC") || this.hasToken("PRIVATE")) {
			if(!this.hasToken("PUBLIC") && checkstyle_utils_FieldUtils.isPublic(f,p)) {
				return;
			}
			if(!this.hasToken("PRIVATE") && checkstyle_utils_FieldUtils.isPrivate(f,p)) {
				return;
			}
		}
		this.matchTypeName("member",f.name,f.pos);
	}
	,checkTypedefField: function(f,t,e) {
		this.matchTypeName("typedef member",f.name,f.pos);
	}
	,__class__: checkstyle_checks_naming_MemberNameCheck
});
var checkstyle_checks_naming_MethodNameCheck = function() {
	checkstyle_checks_naming_NameCheckBase.call(this);
	this.format = "^[a-z][a-zA-Z0-9]*$";
};
$hxClasses["checkstyle.checks.naming.MethodNameCheck"] = checkstyle_checks_naming_MethodNameCheck;
checkstyle_checks_naming_MethodNameCheck.__name__ = "checkstyle.checks.naming.MethodNameCheck";
checkstyle_checks_naming_MethodNameCheck.__super__ = checkstyle_checks_naming_NameCheckBase;
checkstyle_checks_naming_MethodNameCheck.prototype = $extend(checkstyle_checks_naming_NameCheckBase.prototype,{
	checkClassType: function(decl,d,pos) {
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_ClassFlag.HExtern) != -1) {
			return;
		}
		if(d.flags.indexOf(haxeparser_ClassFlag.HInterface) != -1) {
			return;
		}
		this.checkFields(d.data,checkstyle_utils_FieldUtils.toParentType(decl));
	}
	,checkAbstractType: function(decl,d,pos) {
		this.checkFields(d.data,checkstyle_utils_FieldUtils.toParentType(decl));
	}
	,checkTypedefType: function(decl,d,pos) {
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_EnumFlag.EExtern) != -1) {
			return;
		}
		var p = checkstyle_utils_FieldUtils.toParentType(decl);
		var _g = d.data;
		if(_g._hx_index == 2) {
			var f = _g.fields;
			this.checkFields(f,p);
		}
	}
	,checkFields: function(d,p) {
		var _g = 0;
		while(_g < d.length) {
			var field = d[_g];
			++_g;
			if(this.isCheckSuppressed(field)) {
				continue;
			}
			var _g1 = field.kind;
			if(_g1._hx_index == 1) {
				var f = _g1.f;
				this.checkField(field,p);
			}
		}
	}
	,checkField: function(f,p) {
		if(StringTools.startsWith(f.name,"get_") || StringTools.startsWith(f.name,"set_")) {
			return;
		}
		if(this.hasToken("NOTINLINE") && !this.hasToken("INLINE") && checkstyle_utils_FieldUtils.isInline(f,p)) {
			return;
		}
		if(this.hasToken("INLINE") && !this.hasToken("NOTINLINE") && !checkstyle_utils_FieldUtils.isInline(f,p)) {
			return;
		}
		if(this.hasToken("NOTSTATIC") && !this.hasToken("STATIC") && checkstyle_utils_FieldUtils.isStatic(f,p)) {
			return;
		}
		if(this.hasToken("STATIC") && !this.hasToken("NOTSTATIC") && !checkstyle_utils_FieldUtils.isStatic(f,p)) {
			return;
		}
		if(this.hasToken("PUBLIC") && !this.hasToken("PRIVATE") && !checkstyle_utils_FieldUtils.isPublic(f,p)) {
			return;
		}
		if(this.hasToken("PRIVATE") && !this.hasToken("PUBLIC") && !checkstyle_utils_FieldUtils.isPrivate(f,p)) {
			return;
		}
		this.matchTypeName("method name",f.name,f.pos);
	}
	,__class__: checkstyle_checks_naming_MethodNameCheck
});
var checkstyle_checks_naming_ParameterNameCheck = function() {
	checkstyle_checks_naming_NameCheckBase.call(this);
	this.format = "^(_|[a-z][a-zA-Z0-9]*$)";
};
$hxClasses["checkstyle.checks.naming.ParameterNameCheck"] = checkstyle_checks_naming_ParameterNameCheck;
checkstyle_checks_naming_ParameterNameCheck.__name__ = "checkstyle.checks.naming.ParameterNameCheck";
checkstyle_checks_naming_ParameterNameCheck.__super__ = checkstyle_checks_naming_NameCheckBase;
checkstyle_checks_naming_ParameterNameCheck.prototype = $extend(checkstyle_checks_naming_NameCheckBase.prototype,{
	checkClassType: function(decl,d,pos) {
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_ClassFlag.HExtern) != -1) {
			return;
		}
		this.checkFields(d.data);
	}
	,checkEnumType: function(decl,d,pos) {
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_EnumFlag.EExtern) != -1) {
			return;
		}
		this.checkEnumFields(d.data);
	}
	,checkAbstractType: function(decl,d,pos) {
		this.checkFields(d.data);
	}
	,checkTypedefType: function(decl,d,pos) {
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_EnumFlag.EExtern) != -1) {
			return;
		}
		var _g = d.data;
		if(_g._hx_index == 2) {
			var f = _g.fields;
			this.checkFields(f);
		}
	}
	,checkFields: function(d) {
		var _g = 0;
		while(_g < d.length) {
			var field = d[_g];
			++_g;
			if(this.isCheckSuppressed(field)) {
				continue;
			}
			var _g1 = field.kind;
			if(_g1._hx_index == 1) {
				var f = _g1.f;
				this.checkField(f.args,field.pos);
			}
		}
	}
	,checkEnumFields: function(d) {
		var _g = 0;
		while(_g < d.length) {
			var field = d[_g];
			++_g;
			var _g1 = 0;
			var _g2 = field.args;
			while(_g1 < _g2.length) {
				var arg = _g2[_g1];
				++_g1;
				this.matchTypeName("parameter name",arg.name,field.pos);
			}
		}
	}
	,checkField: function(args,pos) {
		if(args == null || args.length <= 0) {
			return;
		}
		var _g = 0;
		while(_g < args.length) {
			var arg = args[_g];
			++_g;
			this.matchTypeName("parameter name",arg.name,pos);
		}
	}
	,__class__: checkstyle_checks_naming_ParameterNameCheck
});
var checkstyle_checks_naming_TypeNameCheck = function() {
	checkstyle_checks_naming_NameCheckBase.call(this);
	this.format = "^[A-Z]+[a-zA-Z0-9]*$";
};
$hxClasses["checkstyle.checks.naming.TypeNameCheck"] = checkstyle_checks_naming_TypeNameCheck;
checkstyle_checks_naming_TypeNameCheck.__name__ = "checkstyle.checks.naming.TypeNameCheck";
checkstyle_checks_naming_TypeNameCheck.__super__ = checkstyle_checks_naming_NameCheckBase;
checkstyle_checks_naming_TypeNameCheck.prototype = $extend(checkstyle_checks_naming_NameCheckBase.prototype,{
	checkClassType: function(decl,d,pos) {
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_ClassFlag.HExtern) != -1) {
			return;
		}
		var isInterface = d.flags.indexOf(haxeparser_ClassFlag.HInterface) != -1;
		if(!this.hasToken("INTERFACE") && isInterface) {
			return;
		}
		if(!this.hasToken("CLASS") && !isInterface) {
			return;
		}
		if(isInterface) {
			this.matchTypeName("interface",d.name,pos);
		} else {
			this.matchTypeName("class",d.name,pos);
		}
	}
	,checkEnumType: function(decl,d,pos) {
		if(!this.hasToken("ENUM")) {
			return;
		}
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_EnumFlag.EExtern) != -1) {
			return;
		}
		this.matchTypeName("enum",d.name,pos);
	}
	,checkAbstractType: function(decl,d,pos) {
		if(!this.hasToken("ABSTRACT")) {
			return;
		}
		this.matchTypeName("abstract",d.name,pos);
	}
	,checkTypedefType: function(decl,d,pos) {
		if(!this.hasToken("TYPEDEF")) {
			return;
		}
		if(this.ignoreExtern && d.flags.indexOf(haxeparser_EnumFlag.EExtern) != -1) {
			return;
		}
		this.matchTypeName("typedef",d.name,pos);
	}
	,__class__: checkstyle_checks_naming_TypeNameCheck
});
var checkstyle_checks_size_FileLengthCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.LINE);
	this.max = checkstyle_checks_size_FileLengthCheck.DEFAULT_MAX_LENGTH;
	this.ignoreEmptyLines = true;
	this.categories = ["Complexity","Clarity"];
	this.points = 21;
};
$hxClasses["checkstyle.checks.size.FileLengthCheck"] = checkstyle_checks_size_FileLengthCheck;
checkstyle_checks_size_FileLengthCheck.__name__ = "checkstyle.checks.size.FileLengthCheck";
checkstyle_checks_size_FileLengthCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_size_FileLengthCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	max: null
	,ignoreEmptyLines: null
	,actualRun: function() {
		if(this.checker.ast == null) {
			return;
		}
		var _g = 0;
		var _g1 = this.checker.ast.decls;
		while(_g < _g1.length) {
			var td = _g1[_g];
			++_g;
			var _g2 = td.decl;
			if(_g2._hx_index == 0) {
				var d = _g2.d;
				var _g3 = 0;
				var _g4 = d.data;
				while(_g3 < _g4.length) {
					var field = _g4[_g3];
					++_g3;
					if(this.isCheckSuppressed(field)) {
						return;
					}
				}
			}
		}
		var count = this.checker.lines.length;
		if(this.ignoreEmptyLines) {
			var emptyLines = checkstyle_checks_whitespace_ListOfEmptyLines.detectEmptyLines(this.checker);
			count -= emptyLines.lines.length;
		}
		if(count > this.max) {
			this.log("File length is " + this.checker.lines.length + " lines (max allowed is " + this.max + ")",this.checker.lines.length,0,this.checker.lines.length,0);
		}
	}
	,detectableInstances: function() {
		var _g = [];
		_g.push(400);
		_g.push(500);
		_g.push(600);
		_g.push(700);
		_g.push(800);
		_g.push(900);
		_g.push(1000);
		_g.push(1100);
		_g.push(1200);
		_g.push(1300);
		return [{ fixed : [], properties : [{ propertyName : "max", values : _g}]}];
	}
	,__class__: checkstyle_checks_size_FileLengthCheck
});
var checkstyle_checks_size_LineLengthCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.LINE);
	this.max = checkstyle_checks_size_LineLengthCheck.DEFAULT_MAX_LENGTH;
	this.ignorePattern = "^$";
	this.categories = ["Complexity","Clarity"];
	this.points = 2;
};
$hxClasses["checkstyle.checks.size.LineLengthCheck"] = checkstyle_checks_size_LineLengthCheck;
checkstyle_checks_size_LineLengthCheck.__name__ = "checkstyle.checks.size.LineLengthCheck";
checkstyle_checks_size_LineLengthCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_size_LineLengthCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	max: null
	,ignorePattern: null
	,actualRun: function() {
		var ignoreRE = new EReg(this.ignorePattern,"");
		var _g = 0;
		var _g1 = this.checker.lines.length;
		while(_g < _g1) {
			var i = _g++;
			var line = this.checker.lines[i];
			if(line.length > this.max) {
				if(ignoreRE.match(line) || this.isLineSuppressed(i)) {
					continue;
				}
				this.log("Line is longer than " + this.max + " characters (found " + line.length + ")",i + 1,0,i + 1,line.length);
			}
		}
	}
	,detectableInstances: function() {
		var _g = [];
		_g.push(80);
		_g.push(100);
		_g.push(120);
		_g.push(140);
		_g.push(160);
		_g.push(180);
		_g.push(200);
		return [{ fixed : [], properties : [{ propertyName : "max", values : _g}]}];
	}
	,__class__: checkstyle_checks_size_LineLengthCheck
});
var checkstyle_checks_size_MethodCountCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.maxTotal = checkstyle_checks_size_MethodCountCheck.DEFAULT_MAX_COUNT;
	this.maxPrivate = checkstyle_checks_size_MethodCountCheck.DEFAULT_MAX_COUNT;
	this.maxPublic = checkstyle_checks_size_MethodCountCheck.DEFAULT_MAX_COUNT;
	this.categories = ["Complexity"];
	this.points = 21;
};
$hxClasses["checkstyle.checks.size.MethodCountCheck"] = checkstyle_checks_size_MethodCountCheck;
checkstyle_checks_size_MethodCountCheck.__name__ = "checkstyle.checks.size.MethodCountCheck";
checkstyle_checks_size_MethodCountCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_size_MethodCountCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	maxTotal: null
	,maxPrivate: null
	,maxPublic: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var acceptableTokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 0) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(acceptableTokens.length > this.maxTotal) {
			this.logPos("Total number of methods is " + acceptableTokens.length + " (max allowed is " + this.maxTotal + ")",acceptableTokens[this.maxTotal].pos);
			return;
		}
		var privateTokens = [];
		var publicTokens = [];
		var _g = 0;
		while(_g < acceptableTokens.length) {
			var token = acceptableTokens[_g];
			++_g;
			if(token.filterCallback(function(token,depth) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					if(_g.k._hx_index == 18) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			}).length > 0) {
				publicTokens.push(token);
			} else {
				privateTokens.push(token);
			}
		}
		if(privateTokens.length > this.maxPrivate) {
			this.logPos("Number of private methods is " + privateTokens.length + " (max allowed is " + this.maxPrivate + ")",privateTokens[this.maxPrivate].pos);
			return;
		}
		if(publicTokens.length > this.maxPublic) {
			this.logPos("Number of public methods is " + publicTokens.length + " (max allowed is " + this.maxPublic + ")",publicTokens[this.maxPublic].pos);
			return;
		}
	}
	,detectableInstances: function() {
		var _g = [];
		_g.push(10);
		_g.push(15);
		_g.push(20);
		_g.push(25);
		_g.push(30);
		_g.push(35);
		_g.push(40);
		_g.push(45);
		_g.push(50);
		_g.push(55);
		_g.push(60);
		_g.push(65);
		_g.push(70);
		_g.push(75);
		_g.push(80);
		_g.push(85);
		_g.push(90);
		_g.push(95);
		_g.push(100);
		_g.push(105);
		_g.push(110);
		var _g1 = [];
		_g1.push(10);
		_g1.push(15);
		_g1.push(20);
		_g1.push(25);
		_g1.push(30);
		_g1.push(35);
		_g1.push(40);
		_g1.push(45);
		_g1.push(50);
		_g1.push(55);
		_g1.push(60);
		_g1.push(65);
		_g1.push(70);
		_g1.push(75);
		_g1.push(80);
		_g1.push(85);
		_g1.push(90);
		_g1.push(95);
		_g1.push(100);
		_g1.push(105);
		_g1.push(110);
		var _g2 = [];
		_g2.push(10);
		_g2.push(15);
		_g2.push(20);
		_g2.push(25);
		_g2.push(30);
		_g2.push(35);
		_g2.push(40);
		_g2.push(45);
		_g2.push(50);
		_g2.push(55);
		_g2.push(60);
		_g2.push(65);
		_g2.push(70);
		_g2.push(75);
		_g2.push(80);
		_g2.push(85);
		_g2.push(90);
		_g2.push(95);
		_g2.push(100);
		_g2.push(105);
		_g2.push(110);
		return [{ fixed : [], properties : [{ propertyName : "maxTotal", values : _g},{ propertyName : "maxPrivate", values : _g1},{ propertyName : "maxPublic", values : _g2}]}];
	}
	,__class__: checkstyle_checks_size_MethodCountCheck
});
var checkstyle_checks_size_MethodLengthCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.max = checkstyle_checks_size_MethodLengthCheck.DEFAULT_MAX_LENGTH;
	this.ignoreEmptyLines = true;
	this.categories = ["Complexity","Clarity"];
	this.points = 8;
};
$hxClasses["checkstyle.checks.size.MethodLengthCheck"] = checkstyle_checks_size_MethodLengthCheck;
checkstyle_checks_size_MethodLengthCheck.__name__ = "checkstyle.checks.size.MethodLengthCheck";
checkstyle_checks_size_MethodLengthCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_size_MethodLengthCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	max: null
	,ignoreEmptyLines: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var functions = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 0) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var emptyLines = checkstyle_checks_whitespace_ListOfEmptyLines.detectEmptyLines(this.checker);
		var _g = 0;
		while(_g < functions.length) {
			var func = functions[_g];
			++_g;
			if(this.isPosSuppressed(func.pos)) {
				continue;
			}
			this.checkMethod(func,emptyLines);
		}
	}
	,checkMethod: function(token,emptyLines) {
		var pos = token.getPos();
		var lmin = this.checker.getLinePos(pos.min).line;
		var lmax = this.checker.getLinePos(pos.max).line;
		var len = this.getLineCount(lmin,lmax,emptyLines);
		var name = "(anonymous)";
		var nameTok = tokentree_TokenTreeAccessHelper.firstChild(token);
		if(nameTok != null) {
			var _g = nameTok.tok;
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 22) {
					name = "new";
				}
				break;
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					var text = _g1.s;
					name = text;
				}
				break;
			default:
			}
		}
		if(len > this.max) {
			this.warnFunctionLength(len,name,checkstyle_utils_PosHelper.getReportPos(token));
		}
	}
	,getLineCount: function(lmin,lmax,emptyLines) {
		var emptyLineCount = 0;
		if(this.ignoreEmptyLines) {
			emptyLineCount = emptyLines.countEmptylinesBetween(lmin,lmax);
		}
		return lmax - lmin - emptyLineCount;
	}
	,warnFunctionLength: function(len,name,pos) {
		this.logPos("Method `" + name + "` length is " + len + " lines (max allowed is " + this.max + ")",pos);
	}
	,detectableInstances: function() {
		var _g = [];
		_g.push(20);
		_g.push(25);
		_g.push(30);
		_g.push(35);
		_g.push(40);
		_g.push(45);
		_g.push(50);
		_g.push(55);
		_g.push(60);
		_g.push(65);
		_g.push(70);
		_g.push(75);
		_g.push(80);
		_g.push(85);
		_g.push(90);
		_g.push(95);
		_g.push(100);
		return [{ fixed : [], properties : [{ propertyName : "max", values : _g},{ propertyName : "ignoreEmptyLines", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_size_MethodLengthCheck
});
var checkstyle_checks_size_ParameterNumberCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.max = checkstyle_checks_size_ParameterNumberCheck.DEFAULT_MAX_PARAMS;
	this.ignoreOverriddenMethods = false;
	this.categories = ["Complexity","Clarity"];
	this.points = 5;
};
$hxClasses["checkstyle.checks.size.ParameterNumberCheck"] = checkstyle_checks_size_ParameterNumberCheck;
checkstyle_checks_size_ParameterNumberCheck.__name__ = "checkstyle.checks.size.ParameterNumberCheck";
checkstyle_checks_size_ParameterNumberCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_size_ParameterNumberCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	max: null
	,ignoreOverriddenMethods: null
	,actualRun: function() {
		this.forEachField($bind(this,this.checkField));
	}
	,checkField: function(f,_) {
		if(this.ignoreOverriddenMethods && f.access.indexOf(haxe_macro_Access.AOverride) != -1) {
			return;
		}
		var _g = f.kind;
		if(_g._hx_index == 1) {
			var fun = _g.f;
			if(fun.args != null && fun.args.length > this.max) {
				this.warnMaxParameter(f.name,checkstyle_utils_PosHelper.makeFieldSignaturePosition(f));
			}
		}
	}
	,warnMaxParameter: function(name,pos) {
		this.logPos("Too many parameters for function: " + name + " (> " + this.max + ")",pos);
	}
	,detectableInstances: function() {
		var _g = [];
		_g.push(4);
		_g.push(5);
		_g.push(6);
		_g.push(7);
		_g.push(8);
		_g.push(9);
		_g.push(10);
		_g.push(11);
		_g.push(12);
		_g.push(13);
		_g.push(14);
		return [{ fixed : [], properties : [{ propertyName : "max", values : _g},{ propertyName : "ignoreOverriddenMethods", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_size_ParameterNumberCheck
});
var checkstyle_checks_type_AnonymousCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.categories = ["Style","Clarity","Bug Risk","Complexity"];
	this.points = 8;
};
$hxClasses["checkstyle.checks.type.AnonymousCheck"] = checkstyle_checks_type_AnonymousCheck;
checkstyle_checks_type_AnonymousCheck.__name__ = "checkstyle.checks.type.AnonymousCheck";
checkstyle_checks_type_AnonymousCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_type_AnonymousCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		this.forEachField($bind(this,this.checkField));
		this.checkLocalVars();
	}
	,checkField: function(f,_) {
		if(f.name == "new") {
			return;
		}
		var _g = f.kind;
		if(_g._hx_index == 0) {
			var _g1 = _g.t;
			if(_g1 != null) {
				if(_g1._hx_index == 2) {
					var val = _g.e;
					var fields = _g1.fields;
					this.error(f.name,f.pos);
				}
			}
		}
	}
	,checkLocalVars: function() {
		var _gthis = this;
		if(this.checker.ast == null) {
			return;
		}
		checkstyle_utils_ExprUtils.walkFile(this.checker.ast,function(e) {
			var _g = e.expr;
			if(_g._hx_index == 10) {
				var vars = _g.vars;
				var _g = 0;
				while(_g < vars.length) {
					var v = vars[_g];
					++_g;
					if(v.type == null) {
						continue;
					}
					var _g1 = v.type;
					if(_g1 != null) {
						if(_g1._hx_index == 2) {
							var fields = _g1.fields;
							_gthis.error(v.name,e.pos);
						}
					}
				}
			}
		});
	}
	,error: function(name,pos) {
		this.logPos("Anonymous structure \"" + name + "\" found, use \"typedef\"",pos);
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_type_AnonymousCheck
});
var checkstyle_checks_type_AvoidIdentifierCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.avoidIdentifiers = [];
};
$hxClasses["checkstyle.checks.type.AvoidIdentifierCheck"] = checkstyle_checks_type_AvoidIdentifierCheck;
checkstyle_checks_type_AvoidIdentifierCheck.__name__ = "checkstyle.checks.type.AvoidIdentifierCheck";
checkstyle_checks_type_AvoidIdentifierCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_type_AvoidIdentifierCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	avoidIdentifiers: null
	,actualRun: function() {
		var _gthis = this;
		var root = this.checker.getTokenTree();
		root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 2) {
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					var ident = _g1.s;
					_gthis.checkIdent(ident,token);
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,checkIdent: function(ident,token) {
		if(this.isPosSuppressed(token.pos)) {
			return;
		}
		if(this.avoidIdentifiers.indexOf(ident) < 0) {
			return;
		}
		this.error(ident,token.pos);
	}
	,error: function(name,pos) {
		this.logPos("Identifier \"" + name + "\" should be avoided",pos);
	}
	,__class__: checkstyle_checks_type_AvoidIdentifierCheck
});
var checkstyle_checks_type_DynamicCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.categories = ["Clarity","Bug Risk","Complexity"];
	this.points = 3;
};
$hxClasses["checkstyle.checks.type.DynamicCheck"] = checkstyle_checks_type_DynamicCheck;
checkstyle_checks_type_DynamicCheck.__name__ = "checkstyle.checks.type.DynamicCheck";
checkstyle_checks_type_DynamicCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_type_DynamicCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	actualRun: function() {
		var _gthis = this;
		var root = this.checker.getTokenTree();
		root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 2) {
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					if(_g1.s == "Dynamic") {
						if(_gthis.isPosSuppressed(token.pos)) {
							return tokentree_FilterResult.SkipSubtree;
						}
						_gthis.logPos("Avoid using \"Dynamic\" as type",token.pos);
						return tokentree_FilterResult.SkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_type_DynamicCheck
});
var checkstyle_checks_type_ReturnCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.allowEmptyReturn = true;
	this.enforceReturnType = false;
	this.enforceReturnTypeForAnonymous = false;
	this.categories = ["Clarity"];
	this.points = 2;
};
$hxClasses["checkstyle.checks.type.ReturnCheck"] = checkstyle_checks_type_ReturnCheck;
checkstyle_checks_type_ReturnCheck.__name__ = "checkstyle.checks.type.ReturnCheck";
checkstyle_checks_type_ReturnCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_type_ReturnCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	allowEmptyReturn: null
	,enforceReturnType: null
	,enforceReturnTypeForAnonymous: null
	,actualRun: function() {
		var _gthis = this;
		this.forEachField(function(field,parent) {
			if(field.name != "new" && parent.kind != checkstyle_utils_FieldParentKind.INTERFACE) {
				_gthis.checkField(field);
			}
		});
		this.checkInlineFunctions();
	}
	,checkField: function(f) {
		if(this.isPosExtern(f.pos)) {
			return;
		}
		var noReturn = false;
		var _g = f.kind;
		if(_g._hx_index == 1) {
			var fun = _g.f;
			noReturn = fun.ret == null;
			if(this.enforceReturnType && noReturn) {
				this.warnReturnTypeMissing(f.name,f.pos);
				return;
			}
			if(!noReturn) {
				var _g = fun.ret;
				if(_g != null) {
					if(_g._hx_index == 0) {
						var val = _g.p;
						if(!this.enforceReturnType && (val.name == null ? "null" : "" + val.name) == "Void") {
							this.warnVoid(f.name,f.pos);
						}
					}
				}
			}
			this.walkExpr(fun.expr,noReturn,f.name,f.pos);
		}
	}
	,checkInlineFunctions: function() {
		var _gthis = this;
		if(this.checker.ast == null) {
			return;
		}
		checkstyle_utils_ExprUtils.walkFile(this.checker.ast,function(e) {
			var _g = e.expr;
			if(_g._hx_index == 11) {
				var f = _g.f;
				var kind = _g.kind;
				var name;
				if(kind == null) {
					name = null;
				} else {
					switch(kind._hx_index) {
					case 0:
						name = null;
						break;
					case 1:
						var inlined = kind.inlined;
						var name1 = kind.name;
						name = name1;
						break;
					case 2:
						name = null;
						break;
					}
				}
				var funNoReturn = f.ret == null;
				_gthis.walkExpr(f.expr,funNoReturn,name,e.pos);
			}
		});
	}
	,walkExpr: function(e,noReturn,name,pos) {
		if(e == null || e.expr == null) {
			return;
		}
		if(!noReturn) {
			return;
		}
		var _g = e.expr;
		switch(_g._hx_index) {
		case 12:
			var exprs = _g.exprs;
			var _g1 = 0;
			while(_g1 < exprs.length) {
				var expr = exprs[_g1];
				++_g1;
				this.walkExpr(expr,noReturn,name,pos);
			}
			break;
		case 13:
			var expr = _g.expr;
			var it = _g.it;
			this.walkExpr(expr,noReturn,name,pos);
			break;
		case 14:
			var eelse = _g.eelse;
			var eif = _g.eif;
			var econd = _g.econd;
			this.walkExpr(eif,noReturn,name,pos);
			this.walkExpr(eelse,noReturn,name,pos);
			break;
		case 15:
			var _g1 = _g.normalWhile;
			var expr = _g.e;
			var econd = _g.econd;
			this.walkExpr(expr,noReturn,name,pos);
			break;
		case 16:
			var edef = _g.edef;
			var cases = _g.cases;
			var expr = _g.e;
			var _g1 = 0;
			while(_g1 < cases.length) {
				var ecase = cases[_g1];
				++_g1;
				this.walkExpr(ecase.expr,noReturn,name,pos);
			}
			this.walkExpr(edef,noReturn,name,pos);
			break;
		case 17:
			var catches = _g.catches;
			var expr = _g.e;
			this.walkExpr(expr,noReturn,name,pos);
			var _g1 = 0;
			while(_g1 < catches.length) {
				var ecatch = catches[_g1];
				++_g1;
				this.walkExpr(ecatch.expr,noReturn,name,pos);
			}
			break;
		case 18:
			var expr = _g.e;
			if(expr == null) {
				if(this.allowEmptyReturn) {
					return;
				}
				this.warnEmptyReturn(name,pos);
			} else {
				this.warnReturnTypeMissing(name,pos);
			}
			break;
		default:
		}
	}
	,warnVoid: function(name,pos) {
		this.logPos("Redundant \"Void\" for method \"" + name + "\"",pos);
	}
	,warnEmptyReturn: function(name,pos) {
		this.logPos("Empty return in method \"" + name + "\" found",pos);
	}
	,warnReturnTypeMissing: function(name,pos) {
		if(name == null) {
			if(this.enforceReturnTypeForAnonymous) {
				this.logPos("Return type not specified for anonymous method",pos);
			}
		} else {
			this.logPos("Return type not specified for method \"" + name + "\"",pos);
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "allowEmptyReturn", values : [true,false]},{ propertyName : "enforceReturnTypeForAnonymous", values : [true,false]},{ propertyName : "enforceReturnType", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_type_ReturnCheck
});
var checkstyle_checks_type_TypeCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.ignoreEnumAbstractValues = true;
	this.categories = ["Clarity"];
};
$hxClasses["checkstyle.checks.type.TypeCheck"] = checkstyle_checks_type_TypeCheck;
checkstyle_checks_type_TypeCheck.__name__ = "checkstyle.checks.type.TypeCheck";
checkstyle_checks_type_TypeCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_type_TypeCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	ignoreEnumAbstractValues: null
	,actualRun: function() {
		var _gthis = this;
		this.forEachField(function(f,p) {
			if(f.name == "new") {
				return;
			}
			if(_gthis.ignoreEnumAbstractValues && p.kind == checkstyle_utils_FieldParentKind.ENUM_ABSTRACT && f.access.indexOf(haxe_macro_Access.AStatic) == -1) {
				return;
			}
			var _g = f.kind;
			if(_g._hx_index == 0) {
				var e = _g.e;
				var t = _g.t;
				if(t == null) {
					_gthis.error(f.name,f.pos);
				}
			}
		});
	}
	,error: function(name,pos) {
		this.logPos("Variable \"" + name + "\" type not specified",pos);
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_type_TypeCheck
});
var checkstyle_checks_type_VarTypeHintCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.typeHintPolicy = "infer_new_or_const";
	this.ignoreEnumAbstractValues = true;
	this.categories = ["Clarity","Bug Risk"];
};
$hxClasses["checkstyle.checks.type.VarTypeHintCheck"] = checkstyle_checks_type_VarTypeHintCheck;
checkstyle_checks_type_VarTypeHintCheck.__name__ = "checkstyle.checks.type.VarTypeHintCheck";
checkstyle_checks_type_VarTypeHintCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_type_VarTypeHintCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	typeHintPolicy: null
	,ignoreEnumAbstractValues: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		var varList = root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 2:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 41:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < varList.length) {
			var v = varList[_g];
			++_g;
			this.checkVar(v);
		}
	}
	,checkVar: function(token) {
		if(this.isPosSuppressed(token.pos)) {
			return;
		}
		if(!token.hasChildren()) {
			return;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			this.checkVarName(child);
		}
	}
	,checkVarName: function(name) {
		if(this.ignoreEnumAbstractValues && this.isEnumAbstractValue(name)) {
			return;
		}
		switch(name.tok._hx_index) {
		case 0:
			return;
		case 21:
			this.checkVarName(name.getFirstChild());
			return;
		default:
		}
		var colon = tokentree_TokenTreeAccessHelper.firstOf(name,tokentree_TokenTreeDef.DblDot);
		var opAssign = tokentree_TokenTreeAccessHelper.firstOf(name,tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		var hasNewOrConst = this.detectNewOrConst(opAssign);
		switch(this.typeHintPolicy) {
		case "enforce_all":
			if(colon == null) {
				this.needsTypeHint(name.toString(),name.pos);
			}
			break;
		case "infer_all":
			if(opAssign == null) {
				if(colon != null) {
					return;
				}
				this.needsTypeHint(name.toString(),name.pos);
			} else if(colon != null) {
				this.noTypeHintNeeded(name.toString(),name.pos);
			}
			break;
		case "infer_new_or_const":
			if(opAssign == null) {
				if(colon != null) {
					return;
				}
				this.needsTypeHint(name.toString(),name.pos);
			} else if(colon == null) {
				if(hasNewOrConst) {
					return;
				}
				this.needsTypeHint(name.toString(),name.pos);
			} else {
				if(!hasNewOrConst) {
					return;
				}
				this.noTypeHintNeeded(name.toString(),name.pos);
			}
			break;
		}
	}
	,detectNewOrConst: function(token) {
		if(token == null) {
			return false;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 22:
					return true;
				case 37:case 38:
					return true;
				default:
				}
				break;
			case 2:
				var _g3 = _g2.c;
				switch(_g3._hx_index) {
				case 0:
					var _g4 = _g3.v;
					return true;
				case 1:
					var _g5 = _g3.f;
					return true;
				case 2:
					var _g6 = _g3.kind;
					var _g7 = _g3.s;
					return true;
				case 4:
					var _g8 = _g3.opt;
					var _g9 = _g3.r;
					return true;
				default:
				}
				break;
			case 10:
				return false;
			default:
			}
		}
		return false;
	}
	,isEnumAbstractValue: function(token) {
		var parent = token.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			var _g = parent.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:
					return false;
				case 26:
					return false;
				case 27:
					return false;
				case 31:
					return false;
				case 39:
					return tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(parent);
				default:
				}
			}
			parent = parent.parent;
		}
		return false;
	}
	,needsTypeHint: function(name,pos) {
		this.logPos("\"" + name + "\" should have a type hint",pos);
	}
	,noTypeHintNeeded: function(name,pos) {
		this.logPos("\"" + name + "\" type hint not needed",pos);
	}
	,__class__: checkstyle_checks_type_VarTypeHintCheck
});
var checkstyle_checks_whitespace_ArrayAccessCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.AST);
	this.spaceBefore = false;
	this.spaceInside = false;
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.whitespace.ArrayAccessCheck"] = checkstyle_checks_whitespace_ArrayAccessCheck;
checkstyle_checks_whitespace_ArrayAccessCheck.__name__ = "checkstyle.checks.whitespace.ArrayAccessCheck";
checkstyle_checks_whitespace_ArrayAccessCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_whitespace_ArrayAccessCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	spaceBefore: null
	,spaceInside: null
	,actualRun: function() {
		var _gthis = this;
		var lastExpr = null;
		if(this.checker.ast == null) {
			return;
		}
		checkstyle_utils_ExprUtils.walkFile(this.checker.ast,function(e) {
			if(lastExpr == null) {
				lastExpr = e;
				return;
			}
			var _g = e.expr;
			if(_g._hx_index == 1) {
				var e2 = _g.e2;
				var e1 = _g.e1;
				if(!_gthis.spaceBefore) {
					var e1length = e1.pos.max - e1.pos.min;
					var eString = _gthis.checker.getString(e.pos.min,e.pos.max);
					if(HxOverrides.substr(eString,e1length,1) == " ") {
						_gthis.logPos("Space between array and [",e.pos);
					}
				}
				if(!_gthis.spaceInside) {
					if(_gthis.checker.getString(e2.pos.min - 1,e2.pos.min) == " ") {
						_gthis.logPos("Space between [ and index",e.pos);
					}
					if(_gthis.checker.getString(e2.pos.max,e2.pos.max + 1) == " ") {
						_gthis.logPos("Space between index and ]",e.pos);
					}
				}
			}
			lastExpr = e;
		});
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "spaceBefore", values : [true,false]},{ propertyName : "spaceInside", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_whitespace_ArrayAccessCheck
});
var checkstyle_checks_whitespace_LineCheckBase = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.LINE);
	this.commentStartRE = new EReg("/([/*])","");
	this.commentBlockEndRE = new EReg("\\*/","");
	this.stringStartRE = new EReg("['\"]","");
	this.stringInterpolatedEndRE = new EReg("^(?:[^'\\\\]|\\\\\\S)*'","");
	this.stringLiteralEndRE = new EReg("^(?:[^\"\\\\]|\\\\\\S)*\"","");
};
$hxClasses["checkstyle.checks.whitespace.LineCheckBase"] = checkstyle_checks_whitespace_LineCheckBase;
checkstyle_checks_whitespace_LineCheckBase.__name__ = "checkstyle.checks.whitespace.LineCheckBase";
checkstyle_checks_whitespace_LineCheckBase.__super__ = checkstyle_checks_Check;
checkstyle_checks_whitespace_LineCheckBase.prototype = $extend(checkstyle_checks_Check.prototype,{
	currentState: null
	,skipOverInitialQuote: null
	,commentStartRE: null
	,commentBlockEndRE: null
	,stringStartRE: null
	,stringInterpolatedEndRE: null
	,stringLiteralEndRE: null
	,reset: function() {
		checkstyle_checks_Check.prototype.reset.call(this);
		this.currentState = checkstyle_checks_whitespace_RangeType.TEXT;
		this.skipOverInitialQuote = false;
	}
	,getRanges: function(line) {
		var ranges = [];
		var currentStart = 0;
		while(currentStart < line.length) {
			var _g = this.currentState;
			switch(_g._hx_index) {
			case 0:
				currentStart = this.handleTextState(line,ranges,currentStart);
				break;
			case 1:
				var isBlock = _g.isBlock;
				currentStart = this.handleCommentState(line,ranges,currentStart,isBlock);
				break;
			case 2:
				var isInterpolated = _g.isInterpolated;
				currentStart = this.handleStringState(line,ranges,currentStart,isInterpolated);
				break;
			}
		}
		if(line.length == 0) {
			ranges.push({ type : this.currentState, start : 0, end : 0});
		}
		return ranges;
	}
	,handleTextState: function(line,ranges,currentStart) {
		var foundCommentStart = this.commentStartRE.matchSub(line,currentStart);
		var commentStart = foundCommentStart ? this.commentStartRE.matchedPos().pos : line.length;
		var foundStringStart = this.stringStartRE.matchSub(line,currentStart);
		var stringStart = foundStringStart ? this.stringStartRE.matchedPos().pos : line.length;
		if(foundCommentStart && commentStart < stringStart) {
			if(commentStart > currentStart) {
				ranges.push({ type : this.currentState, start : currentStart, end : commentStart});
			}
			this.currentState = checkstyle_checks_whitespace_RangeType.COMMENT(this.commentStartRE.matched(1) == "*");
			return commentStart;
		} else if(foundStringStart && stringStart < commentStart) {
			if(stringStart > currentStart) {
				ranges.push({ type : this.currentState, start : currentStart, end : stringStart});
			}
			this.skipOverInitialQuote = true;
			this.currentState = checkstyle_checks_whitespace_RangeType.STRING(this.stringStartRE.matched(0) == "'");
			return stringStart;
		} else {
			ranges.push({ type : this.currentState, start : currentStart, end : line.length});
			return line.length;
		}
	}
	,handleCommentState: function(line,ranges,currentStart,isBlock) {
		if(isBlock && this.commentBlockEndRE.matchSub(line,currentStart)) {
			var commentEnd = this.commentBlockEndRE.matchedPos().pos + 2;
			ranges.push({ type : this.currentState, start : currentStart, end : commentEnd});
			this.currentState = checkstyle_checks_whitespace_RangeType.TEXT;
			return commentEnd;
		} else {
			ranges.push({ type : this.currentState, start : currentStart, end : line.length});
			if(!isBlock) {
				this.currentState = checkstyle_checks_whitespace_RangeType.TEXT;
			}
			return line.length;
		}
	}
	,handleStringState: function(line,ranges,currentStart,isInterpolated) {
		var adjustedStart = currentStart + (this.skipOverInitialQuote ? 1 : 0);
		this.skipOverInitialQuote = false;
		var re = isInterpolated ? this.stringInterpolatedEndRE : this.stringLiteralEndRE;
		if(re.match(line.substring(adjustedStart))) {
			var matchedPos = re.matchedPos();
			var stringEnd = adjustedStart + matchedPos.pos + matchedPos.len;
			ranges.push({ type : this.currentState, start : currentStart, end : stringEnd});
			this.currentState = checkstyle_checks_whitespace_RangeType.TEXT;
			return stringEnd;
		} else {
			ranges.push({ type : this.currentState, start : currentStart, end : line.length});
			return line.length;
		}
	}
	,__class__: checkstyle_checks_whitespace_LineCheckBase
});
var checkstyle_checks_whitespace_EmptyLinesCheck = function() {
	checkstyle_checks_whitespace_LineCheckBase.call(this);
	this.max = 1;
	this.allowEmptyLineAfterSingleLineComment = true;
	this.allowEmptyLineAfterMultiLineComment = true;
	this.requireEmptyLineAfterPackage = true;
	this.requireEmptyLineAfterClass = true;
	this.requireEmptyLineAfterInterface = true;
	this.requireEmptyLineAfterAbstract = true;
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.whitespace.EmptyLinesCheck"] = checkstyle_checks_whitespace_EmptyLinesCheck;
checkstyle_checks_whitespace_EmptyLinesCheck.__name__ = "checkstyle.checks.whitespace.EmptyLinesCheck";
checkstyle_checks_whitespace_EmptyLinesCheck.__super__ = checkstyle_checks_whitespace_LineCheckBase;
checkstyle_checks_whitespace_EmptyLinesCheck.prototype = $extend(checkstyle_checks_whitespace_LineCheckBase.prototype,{
	max: null
	,allowEmptyLineAfterSingleLineComment: null
	,allowEmptyLineAfterMultiLineComment: null
	,requireEmptyLineAfterPackage: null
	,requireEmptyLineAfterClass: null
	,requireEmptyLineAfterInterface: null
	,requireEmptyLineAfterAbstract: null
	,actualRun: function() {
		var inGroup = false;
		var isLastLinePackage = false;
		var isLastLineClass = false;
		var isLastLineInterface = false;
		var isLastLineAbstract = false;
		var start = 0;
		var end = 0;
		var _g = 0;
		var _g1 = this.checker.lines.length;
		while(_g < _g1) {
			var i = _g++;
			var line = this.checker.lines[i];
			var ranges = this.getRanges(line);
			if(ranges.length == 1) {
				var _g2 = ranges[0].type;
				switch(_g2._hx_index) {
				case 0:
					break;
				case 1:
					var isBlock = _g2.isBlock;
					if(isBlock) {
						continue;
					}
					break;
				case 2:
					var isInterpolated = _g2.isInterpolated;
					continue;
				}
			}
			if(new EReg("^\\s*$","").match(line)) {
				if(!inGroup) {
					inGroup = true;
					start = i;
				}
				end = i;
				if(!this.allowEmptyLineAfterSingleLineComment) {
					this.checkComment(i,start,new EReg("^(//).*$",""));
				}
				if(!this.allowEmptyLineAfterMultiLineComment) {
					this.checkComment(i,start,new EReg("^^(/\\*).*|(\\*/)$",""));
				}
			} else {
				if(inGroup) {
					inGroup = false;
					if(end - start + 1 > this.max) {
						this.logInfo(start);
					}
				}
				if(this.requireEmptyLineAfterPackage && isLastLinePackage) {
					this.log("Empty line required after package declaration",i + 1,0,i + 1,0);
				}
				if(this.requireEmptyLineAfterClass && isLastLineClass) {
					this.log("Empty line required after class declaration",i + 1,0,i + 1,0);
				}
				if(this.requireEmptyLineAfterInterface && isLastLineInterface) {
					this.log("Empty line required after interface declaration",i + 1,0,i + 1,0);
				}
				if(this.requireEmptyLineAfterAbstract && isLastLineAbstract) {
					this.log("Empty line required after abstract declaration",i + 1,0,i + 1,0);
				}
			}
			isLastLinePackage = new EReg("^\\s*package\\s.*?;","").match(line);
			isLastLineClass = new EReg("^\\s*class\\s.*?\\{","").match(line);
			isLastLineInterface = new EReg("^\\s*interface\\s.*?\\{","").match(line);
			isLastLineAbstract = new EReg("^\\s*abstract\\s.*?\\{","").match(line);
		}
		if(inGroup) {
			inGroup = false;
			if(end - start + 1 > this.max) {
				this.logInfo(start);
			}
		}
	}
	,checkComment: function(i,start,regex) {
		var tmp;
		if(i > 0) {
			var tmp1 = StringTools.trim(this.checker.lines[i - 1]);
			tmp = regex.match(tmp1);
		} else {
			tmp = false;
		}
		if(tmp) {
			this.log("Empty line not allowed after comment(s)",start + 1,0,start + 1,0);
		}
	}
	,logInfo: function(pos) {
		this.log("Too many consecutive empty lines (> " + this.max + ")",pos + 1,0,pos + 1,0);
	}
	,detectableInstances: function() {
		return [{ fixed : [{ propertyName : "max", value : 1}], properties : [{ propertyName : "allowEmptyLineAfterSingleLineComment", values : [false,true]},{ propertyName : "allowEmptyLineAfterMultiLineComment", values : [false,true]},{ propertyName : "requireEmptyLineAfterPackage", values : [true,false]},{ propertyName : "requireEmptyLineAfterClass", values : [true,false]},{ propertyName : "requireEmptyLineAfterInterface", values : [true,false]},{ propertyName : "requireEmptyLineAfterAbstract", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_whitespace_EmptyLinesCheck
});
var checkstyle_checks_whitespace_ExtendedEmptyLinesCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.max = 1;
	this.skipSingleLineTypes = true;
	this.defaultPolicy = "upto";
	this.ignore = [];
	this.none = [];
	this.exact = [];
	this.upto = [];
	this.atleast = [];
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.whitespace.ExtendedEmptyLinesCheck"] = checkstyle_checks_whitespace_ExtendedEmptyLinesCheck;
checkstyle_checks_whitespace_ExtendedEmptyLinesCheck.__name__ = "checkstyle.checks.whitespace.ExtendedEmptyLinesCheck";
checkstyle_checks_whitespace_ExtendedEmptyLinesCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_whitespace_ExtendedEmptyLinesCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	max: null
	,skipSingleLineTypes: null
	,defaultPolicy: null
	,ignore: null
	,none: null
	,exact: null
	,upto: null
	,atleast: null
	,placemap: null
	,buildPolicyMap: function() {
		this.placemap = new haxe_ds_StringMap();
		var _g = 0;
		var _g1 = this.ignore;
		while(_g < _g1.length) {
			var place = _g1[_g];
			++_g;
			this.placemap.set(place,"ignore");
		}
		var _g = 0;
		var _g1 = this.none;
		while(_g < _g1.length) {
			var place = _g1[_g];
			++_g;
			this.placemap.set(place,"none");
		}
		var _g = 0;
		var _g1 = this.exact;
		while(_g < _g1.length) {
			var place = _g1[_g];
			++_g;
			this.placemap.set(place,"exact");
		}
		var _g = 0;
		var _g1 = this.upto;
		while(_g < _g1.length) {
			var place = _g1[_g];
			++_g;
			this.placemap.set(place,"upto");
		}
		var _g = 0;
		var _g1 = this.atleast;
		while(_g < _g1.length) {
			var place = _g1[_g];
			++_g;
			this.placemap.set(place,"atleast");
		}
	}
	,getPolicy: function(place) {
		if(this.placemap.exists(place)) {
			return this.placemap.get(place);
		}
		return this.defaultPolicy;
	}
	,isIgnored: function(places) {
		var _g = 0;
		while(_g < places.length) {
			var place = places[_g];
			++_g;
			if(this.getPolicy(place) != "ignore") {
				return false;
			}
		}
		return true;
	}
	,actualRun: function() {
		this.buildPolicyMap();
		var emptyLines = checkstyle_checks_whitespace_ListOfEmptyLines.detectEmptyLines(this.checker);
		if(this.max <= 0) {
			this.max = 1;
		}
		this.checkPackages(emptyLines);
		this.checkImports(emptyLines);
		this.checkTypes(emptyLines);
		this.checkFile(emptyLines);
		this.checkFunctions(emptyLines);
		this.checkComments(emptyLines);
	}
	,checkPackages: function(emptyLines) {
		if(this.isIgnored(["beforePackage","afterPackage"])) {
			return;
		}
		var root = this.checker.getTokenTree();
		var packages = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 33) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < packages.length) {
			var pack = packages[_g];
			++_g;
			this.checkBetweenToken(emptyLines,null,pack,this.getPolicy("beforePackage"),"before package");
			this.checkBetweenToken(emptyLines,pack,pack.nextSibling,this.getPolicy("afterPackage"),"after package");
		}
	}
	,checkImports: function(emptyLines) {
		if(this.isIgnored(["afterImports","beforeUsing","betweenImports"])) {
			return;
		}
		var root = this.checker.getTokenTree();
		var imports = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 13:case 35:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(imports.length <= 0) {
			return;
		}
		var lastImport = imports[imports.length - 1];
		if(lastImport.nextSibling != null) {
			var _g = lastImport.nextSibling.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 26:case 27:case 31:case 39:
					this.checkBetweenToken(emptyLines,lastImport,lastImport.nextSibling,this.getPolicy("afterImports"),"after imports/using");
					break;
				default:
				}
			}
		}
		var _g = 1;
		var _g1 = imports.length;
		while(_g < _g1) {
			var index = _g++;
			var imp = imports[index];
			var prev = imp.previousSibling;
			if(prev == null) {
				continue;
			}
			if(imp.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdUsing))) {
				if(prev.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdImport))) {
					this.checkBetweenToken(emptyLines,prev,imp,this.getPolicy("beforeUsing"),"between import and using");
					continue;
				}
			} else if(prev.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdUsing))) {
				this.checkBetweenToken(emptyLines,prev,imp,this.getPolicy("beforeUsing"),"between import and using");
				continue;
			}
			var _g2 = prev.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 13:case 35:
					this.checkBetweenToken(emptyLines,prev,imp,this.getPolicy("betweenImports"),"between imports/using");
					break;
				default:
				}
				break;
			case 7:
				var _g3 = _g2.s;
				this.checkBetweenToken(emptyLines,prev,imp,this.getPolicy("betweenImports"),"between imports/using");
				break;
			case 8:
				var _g4 = _g2.s;
				this.checkBetweenToken(emptyLines,prev,imp,this.getPolicy("betweenImports"),"between imports/using");
				break;
			default:
			}
		}
	}
	,checkTypes: function(emptyLines) {
		var _gthis = this;
		var root = this.checker.getTokenTree();
		var types = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 26:case 27:case 31:case 39:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(types.length <= 0) {
			return;
		}
		this.checkBetweenTypes(emptyLines,types);
		var _g = 0;
		while(_g < types.length) {
			var type = types[_g];
			++_g;
			var pos = type.getPos();
			if(this.skipSingleLineTypes && this.checker.getLinePos(pos.min).line - this.checker.getLinePos(pos.max).line == 0) {
				continue;
			}
			var _g1 = type.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 1:
					this.checkClass(emptyLines,type);
					break;
				case 26:
					if(this.isIgnored(["beginEnum","endEnum","betweenEnumFields","typeDefinition"])) {
						continue;
					}
					this.checkType(emptyLines,type,this.getPolicy("beginEnum"),this.getPolicy("endEnum"),function(child,next) {
						if(_gthis.hasDocComment(child)) {
							return _gthis.makePolicyAndWhat(_gthis.getPolicy("afterDocCommentField"),"between type fields");
						}
						return _gthis.makePolicyAndWhat(_gthis.getPolicy("betweenEnumFields"),"between type fields");
					});
					break;
				case 27:
					if(this.isIgnored(["beginInterface","endInterface","betweenInterfaceFields","typeDefinition"])) {
						continue;
					}
					this.checkType(emptyLines,type,this.getPolicy("beginInterface"),this.getPolicy("endInterface"),function(child,next) {
						if(_gthis.hasDocComment(child)) {
							return _gthis.makePolicyAndWhat(_gthis.getPolicy("afterDocCommentField"),"between type fields");
						}
						return _gthis.makePolicyAndWhat(_gthis.getPolicy("betweenInterfaceFields"),"between type fields");
					});
					break;
				case 31:
					if(this.isIgnored(["beginTypedef","endTypedef","betweenTypedefFields","typeDefinition"])) {
						continue;
					}
					this.checkType(emptyLines,type,this.getPolicy("beginTypedef"),this.getPolicy("endTypedef"),function(child,next) {
						if(_gthis.hasDocComment(child)) {
							return _gthis.makePolicyAndWhat(_gthis.getPolicy("afterDocCommentField"),"between type fields");
						}
						return _gthis.makePolicyAndWhat(_gthis.getPolicy("betweenTypedefFields"),"between type fields");
					});
					break;
				case 39:
					this.checkAbstract(emptyLines,type);
					break;
				default:
				}
			}
		}
	}
	,hasDocComment: function(token) {
		var docToken = tokentree_utils_TokenTreeCheckUtils.getDocComment(token);
		return docToken != null;
	}
	,checkBetweenTypes: function(emptyLines,types) {
		if(this.isIgnored(["betweenTypes"])) {
			return;
		}
		var _g = 1;
		var _g1 = types.length;
		while(_g < _g1) {
			var index = _g++;
			var type = types[index];
			var sibling = type.previousSibling;
			var prevType = types[index - 1];
			if(sibling == null) {
				continue;
			}
			if(sibling != prevType) {
				var _g2 = sibling.tok;
				switch(_g2._hx_index) {
				case 3:
					var _g3 = _g2.s;
					continue;
				case 7:
					var _g4 = _g2.s;
					type = sibling;
					break;
				case 8:
					var _g5 = _g2.s;
					type = sibling;
					break;
				default:
				}
			}
			var prevPos = prevType.getPos();
			if(this.skipSingleLineTypes && this.checker.getLinePos(prevPos.min).line - this.checker.getLinePos(prevPos.max).line == 0) {
				continue;
			}
			var startLine = this.checker.getLinePos(prevPos.max).line;
			var endLine = this.checker.getLinePos(type.getPos().min).line;
			this.checkBetween(emptyLines,startLine,endLine,this.getPolicy("betweenTypes"),"between types");
		}
	}
	,checkAbstract: function(emptyLines,typeToken) {
		var _gthis = this;
		if(this.isIgnored(["beginAbstract","endAbstract","betweenAbstractMethods","afterAbstractVars","betweenAbstractVars","typeDefinition"])) {
			return;
		}
		this.checkType(emptyLines,typeToken,this.getPolicy("beginAbstract"),this.getPolicy("endAbstract"),function(child,next) {
			if(_gthis.hasDocComment(child)) {
				return _gthis.makePolicyAndWhat(_gthis.getPolicy("afterDocCommentField"),"between type fields");
			}
			var isFuncChild = child.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction));
			var isVarChild = child.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdVar));
			if(!isVarChild && !isFuncChild) {
				return null;
			}
			var type = _gthis.detectNextFieldType(next);
			if(type == checkstyle_checks_whitespace_EmptyLinesFieldType.OTHER) {
				return null;
			}
			if(isFuncChild && type == checkstyle_checks_whitespace_EmptyLinesFieldType.FUNCTION) {
				return _gthis.makePolicyAndWhat(_gthis.getPolicy("betweenAbstractMethods"),"between abstract functions");
			}
			if(isVarChild && type == checkstyle_checks_whitespace_EmptyLinesFieldType.FUNCTION) {
				return _gthis.makePolicyAndWhat(_gthis.getPolicy("afterAbstractVars"),"after abstract vars");
			}
			if(isFuncChild && type == checkstyle_checks_whitespace_EmptyLinesFieldType.VAR) {
				return _gthis.makePolicyAndWhat(_gthis.getPolicy("afterAbstractVars"),"after abstract vars");
			}
			return _gthis.makePolicyAndWhat(_gthis.getPolicy("betweenAbstractVars"),"between abstract vars");
		});
	}
	,checkClass: function(emptyLines,typeToken) {
		var _gthis = this;
		var places = ["beginClass","endClass","betweenClassMethods","afterClassVars","betweenClassStaticVars","betweenClassVars","afterClassStaticVars","typeDefinition"];
		if(this.isIgnored(places)) {
			return;
		}
		this.checkType(emptyLines,typeToken,this.getPolicy("beginClass"),this.getPolicy("endClass"),function(child,next) {
			if(_gthis.hasDocComment(child)) {
				return _gthis.makePolicyAndWhat(_gthis.getPolicy("afterDocCommentField"),"between type fields");
			}
			while(next != null) {
				if(!next.isComment()) {
					break;
				}
				next = next.nextSibling;
			}
			if(next == null) {
				return null;
			}
			var isFuncChild = child.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction));
			var isVarChild = child.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdVar));
			if(!isVarChild && !isFuncChild) {
				return null;
			}
			var type = _gthis.detectNextFieldType(next);
			if(type == checkstyle_checks_whitespace_EmptyLinesFieldType.OTHER) {
				return null;
			}
			if(isFuncChild && type == checkstyle_checks_whitespace_EmptyLinesFieldType.FUNCTION) {
				return _gthis.makePolicyAndWhat(_gthis.getPolicy("betweenClassMethods"),"between class methods");
			}
			if(isVarChild && type == checkstyle_checks_whitespace_EmptyLinesFieldType.FUNCTION) {
				return _gthis.makePolicyAndWhat(_gthis.getPolicy("afterClassVars"),"after class vars");
			}
			if(isFuncChild && type == checkstyle_checks_whitespace_EmptyLinesFieldType.VAR) {
				return _gthis.makePolicyAndWhat(_gthis.getPolicy("afterClassVars"),"after class vars");
			}
			var isStaticChild = child.filterCallback(function(token,depth) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					if(_g.k._hx_index == 17) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			}).length > 0;
			var isStaticNext = next.filterCallback(function(token,depth) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					if(_g.k._hx_index == 17) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			}).length > 0;
			if(isStaticChild && isStaticNext) {
				return _gthis.makePolicyAndWhat(_gthis.getPolicy("betweenClassStaticVars"),"between class static vars");
			}
			if(!isStaticChild && !isStaticNext) {
				return _gthis.makePolicyAndWhat(_gthis.getPolicy("betweenClassVars"),"between class vars");
			}
			return _gthis.makePolicyAndWhat(_gthis.getPolicy("afterClassStaticVars"),"after class static vars");
		});
	}
	,detectNextFieldType: function(field) {
		if(field.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction))) {
			return checkstyle_checks_whitespace_EmptyLinesFieldType.FUNCTION;
		}
		if(field.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdVar))) {
			return checkstyle_checks_whitespace_EmptyLinesFieldType.VAR;
		}
		if(!field.isComment()) {
			return checkstyle_checks_whitespace_EmptyLinesFieldType.OTHER;
		}
		var after = field.nextSibling;
		while(after != null) {
			if(after.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction))) {
				return checkstyle_checks_whitespace_EmptyLinesFieldType.FUNCTION;
			}
			if(after.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdVar))) {
				return checkstyle_checks_whitespace_EmptyLinesFieldType.VAR;
			}
			if(after.isComment()) {
				after = after.nextSibling;
				continue;
			}
			return checkstyle_checks_whitespace_EmptyLinesFieldType.OTHER;
		}
		return checkstyle_checks_whitespace_EmptyLinesFieldType.OTHER;
	}
	,checkType: function(emptyLines,typeToken,beginPolicy,endPolicy,fieldPolicyProvider) {
		var brOpen = this.findTypeBrOpen(typeToken);
		if(brOpen == null) {
			return;
		}
		this.checkBetweenToken(emptyLines,typeToken,brOpen,this.getPolicy("typeDefinition"),"between type definition and left curly");
		var brClose = brOpen.getLastChild();
		if(brClose == null) {
			return;
		}
		var start = this.checker.getLinePos(brOpen.pos.max).line;
		var end = this.checker.getLinePos(brClose.pos.min).line;
		if(start == end) {
			return;
		}
		this.checkLines(emptyLines,beginPolicy,start + 1,start + 1,"after left curly");
		this.checkLines(emptyLines,endPolicy,end - 1,end - 1,"before right curly");
		var _g = 0;
		var _g1 = brOpen.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 7:
				var _g3 = _g2.s;
				break;
			case 8:
				var _g4 = _g2.s;
				break;
			case 22:
				break;
			default:
				var next = child.nextSibling;
				if(next == null) {
					continue;
				}
				var _g5 = next.tok;
				switch(_g5._hx_index) {
				case 7:
					var _g6 = _g5.s;
					continue;
				case 8:
					var _g7 = _g5.s;
					continue;
				case 18:
					continue;
				default:
				}
				var policyAndWhat = fieldPolicyProvider(child,next);
				if(policyAndWhat == null) {
					continue;
				}
				this.checkBetweenFullToken(emptyLines,child,next,policyAndWhat.policy,policyAndWhat.whatMsg);
			}
		}
	}
	,findTypeBrOpen: function(parent) {
		if(parent == null) {
			return null;
		}
		var brOpens = parent.filterCallback(function(tok,depth) {
			if(tok.tok._hx_index == 17) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(brOpens.length <= 0) {
			return null;
		}
		return brOpens[0];
	}
	,checkFile: function(emptyLines) {
		if(this.isIgnored(["anywhereInFile","beforeFileEnd"])) {
			return;
		}
		var ranges = emptyLines.getRanges(0,this.checker.lines.length);
		var _g = 0;
		while(_g < ranges.length) {
			var range = ranges[_g];
			++_g;
			var line = 0;
			switch(range._hx_index) {
			case 0:
				break;
			case 1:
				var l = range.line;
				line = l;
				break;
			case 2:
				var end = range.end;
				var start = range.start;
				line = end;
				break;
			}
			var result = emptyLines.checkRange(this.getPolicy("anywhereInFile"),this.max,range,line);
			this.logEmptyRange(this.getPolicy("anywhereInFile"),"anywhere in file",result);
		}
		var range = checkstyle_checks_whitespace_EmptyLineRange.NONE;
		if(ranges.length > 0) {
			var lastRange = ranges[ranges.length - 1];
			switch(lastRange._hx_index) {
			case 0:
				break;
			case 1:
				var line = lastRange.line;
				if(line == this.checker.lines.length - 1) {
					range = lastRange;
				}
				break;
			case 2:
				var end = lastRange.end;
				var start = lastRange.start;
				if(end == this.checker.lines.length - 1) {
					range = lastRange;
				}
				break;
			}
		}
		var result = emptyLines.checkRange(this.getPolicy("beforeFileEnd"),this.max,range,this.checker.lines.length - 1);
		this.logEmptyRange(this.getPolicy("beforeFileEnd"),"before file end",result);
	}
	,checkFunctions: function(emptyLines) {
		if(this.isIgnored(["inFunction","afterLeftCurly","beforeRightCurly"])) {
			return;
		}
		var root = this.checker.getTokenTree();
		var funcs = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 0) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(funcs.length <= 0) {
			return;
		}
		var _g = 0;
		while(_g < funcs.length) {
			var func = funcs[_g];
			++_g;
			var pos = func.getPos();
			var start = this.checker.getLinePos(pos.min).line;
			var end = this.checker.getLinePos(pos.max).line;
			this.checkLines(emptyLines,this.getPolicy("inFunction"),start,end,"inside functions",true);
			var brOpen = func.filterCallback(function(token,depth) {
				if(token.tok._hx_index == 17) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			var _g1 = 0;
			while(_g1 < brOpen.length) {
				var open = brOpen[_g1];
				++_g1;
				var close = open.getLastChild();
				if(close == null) {
					continue;
				}
				var start1 = this.checker.getLinePos(open.pos.max).line;
				var end1 = this.checker.getLinePos(close.pos.min).line;
				if(start1 == end1) {
					continue;
				}
				this.checkLines(emptyLines,this.getPolicy("afterLeftCurly"),start1 + 1,start1 + 1,"after left curly");
				this.checkLines(emptyLines,this.getPolicy("beforeRightCurly"),end1 - 1,end1 - 1,"before right curly");
			}
		}
	}
	,checkComments: function(emptyLines) {
		if(this.isIgnored(["afterMultiLineComment","afterSingleLineComment","beforeMultiLineComment","beforeSingleLineComment"])) {
			return;
		}
		var root = this.checker.getTokenTree();
		var comments = root.filterCallback(function(tok,depth) {
			var _g = tok.tok;
			switch(_g._hx_index) {
			case 7:
				var _g1 = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			case 8:
				var _g1 = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < comments.length) {
			var comment = comments[_g];
			++_g;
			var line = this.checker.getLinePos(comment.pos.min).line;
			if(!new EReg("^\\s*(//|/\\*)","").match(this.checker.lines[line])) {
				continue;
			}
			var prevLine = this.checker.getLinePos(comment.getPos().min).line - 1;
			var nextLine = this.checker.getLinePos(comment.getPos().max).line + 1;
			var _g1 = comment.tok;
			switch(_g1._hx_index) {
			case 7:
				var _g2 = _g1.s;
				if(this.checkPreviousSiblingComment(comment.previousSibling)) {
					this.checkLines(emptyLines,this.getPolicy("beforeMultiLineComment"),prevLine,prevLine,"before comment");
				}
				if(comment.nextSibling == null || !comment.nextSibling.isComment()) {
					this.checkLines(emptyLines,this.getPolicy("afterMultiLineComment"),nextLine,nextLine,"after comment");
				}
				break;
			case 8:
				var _g3 = _g1.s;
				if(this.checkPreviousSiblingComment(comment.previousSibling)) {
					this.checkLines(emptyLines,this.getPolicy("beforeSingleLineComment"),prevLine,prevLine,"before comment");
				}
				if(comment.nextSibling == null || !comment.nextSibling.isComment()) {
					this.checkLines(emptyLines,this.getPolicy("afterSingleLineComment"),nextLine,nextLine,"after comment");
				}
				break;
			default:
			}
		}
	}
	,checkPreviousSiblingComment: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
				var parent = token.parent;
				if(parent != null) {
					var _g1 = parent.tok;
					if(_g1._hx_index == 3) {
						var _g2 = _g1.s;
						return false;
					}
				}
			}
			break;
		case 3:
			var _g1 = _g.s;
			return false;
		case 7:
			var _g1 = _g.s;
			return false;
		case 8:
			var _g1 = _g.s;
			return false;
		case 19:
			var parent = token.parent;
			if(parent != null) {
				var _g = parent.tok;
				if(_g._hx_index == 3) {
					var _g1 = _g.s;
					return false;
				}
			}
			break;
		default:
		}
		return true;
	}
	,checkLines: function(emptyLines,policy,start,end,whatMsg,tolerateEmptyRange) {
		if(tolerateEmptyRange == null) {
			tolerateEmptyRange = false;
		}
		var ranges = emptyLines.getRanges(start,end);
		if(!tolerateEmptyRange && ranges.length <= 0) {
			ranges = [checkstyle_checks_whitespace_EmptyLineRange.NONE];
		}
		var _g = 0;
		while(_g < ranges.length) {
			var range = ranges[_g];
			++_g;
			var result = emptyLines.checkRange(policy,this.max,range,end);
			this.logEmptyRange(policy,whatMsg,result);
		}
	}
	,checkBetweenFullToken: function(emptyLines,firstToken,secondToken,policy,whatMsg) {
		var lineStart = 0;
		var lineEnd = this.checker.lines.length;
		if(firstToken != null) {
			lineStart = this.checker.getLinePos(firstToken.getPos().max).line;
		}
		if(secondToken != null) {
			lineEnd = this.checker.getLinePos(secondToken.getPos().min).line;
		}
		this.checkBetween(emptyLines,lineStart,lineEnd,policy,whatMsg);
	}
	,checkBetweenToken: function(emptyLines,firstToken,secondToken,policy,whatMsg) {
		var lineStart = 0;
		var lineEnd = this.checker.lines.length;
		if(firstToken != null) {
			lineStart = this.checker.getLinePos(firstToken.pos.max).line;
		}
		if(secondToken != null) {
			lineEnd = this.checker.getLinePos(secondToken.pos.min).line;
		}
		this.checkBetween(emptyLines,lineStart,lineEnd,policy,whatMsg);
	}
	,checkBetween: function(emptyLines,lineStart,lineEnd,policy,whatMsg) {
		if(lineStart < 0) {
			lineStart = 0;
		}
		if(lineEnd < 0) {
			lineEnd = this.checker.lines.length;
		}
		var result = emptyLines.checkPolicySingleRange(policy,this.max,lineStart,lineEnd);
		this.logEmptyRange(policy,whatMsg,result);
	}
	,makePolicyAndWhat: function(policy,whatMsg) {
		return { policy : policy, whatMsg : whatMsg};
	}
	,logEmptyRange: function(policy,whatMsg,range) {
		if(range == null) {
			return;
		}
		switch(range._hx_index) {
		case 0:
			break;
		case 1:
			var line = range.line;
			if(this.isLineSuppressed(line)) {
				return;
			}
			this.log(this.formatMessage(policy,whatMsg),line + 1,0,line + 1,0);
			break;
		case 2:
			var end = range.end;
			var start = range.start;
			if(this.isLineSuppressed(start)) {
				return;
			}
			this.log(this.formatMessage(policy,whatMsg),start + 1,0,end + 1,0);
			break;
		}
	}
	,formatMessage: function(policy,what) {
		var line = "lines";
		if(this.max == 1) {
			line = "line";
		}
		switch(policy) {
		case "atleast":
			return "should have at least " + this.max + " empty " + line + " " + what;
		case "exact":
			return "should have exactly " + this.max + " empty " + line + " " + what;
		case "ignore":
			return "ignored empty lines " + what;
		case "none":
			return "should not have empty line(s) " + what;
		case "upto":
			return "should have upto " + this.max + " empty " + line + " " + what;
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [{ propertyName : "max", value : 1}], properties : [{ "propertyName" : "skipSingleLineTypes", "values" : [false,true]},{ "propertyName" : "defaultPolicy", "values" : ["none","exact","upto","atleast","ignore"]},{ "propertyName" : "none", "values" : [["beforePackage","betweenImports","beforeUsing","typeDefinition","afterLeftCurly","beforeRightCurly"]]}]}];
	}
	,__class__: checkstyle_checks_whitespace_ExtendedEmptyLinesCheck
});
var checkstyle_checks_whitespace_EmptyLinesFieldType = $hxEnums["checkstyle.checks.whitespace.EmptyLinesFieldType"] = { __ename__ : true, __constructs__ : ["VAR","FUNCTION","OTHER"]
	,VAR: {_hx_index:0,__enum__:"checkstyle.checks.whitespace.EmptyLinesFieldType",toString:$estr}
	,FUNCTION: {_hx_index:1,__enum__:"checkstyle.checks.whitespace.EmptyLinesFieldType",toString:$estr}
	,OTHER: {_hx_index:2,__enum__:"checkstyle.checks.whitespace.EmptyLinesFieldType",toString:$estr}
};
var checkstyle_checks_whitespace_IndentationCharacterCheck = function() {
	checkstyle_checks_whitespace_LineCheckBase.call(this);
	this.severity = "IGNORE";
	this.character = "tab";
	this.ignorePattern = "^$";
};
$hxClasses["checkstyle.checks.whitespace.IndentationCharacterCheck"] = checkstyle_checks_whitespace_IndentationCharacterCheck;
checkstyle_checks_whitespace_IndentationCharacterCheck.__name__ = "checkstyle.checks.whitespace.IndentationCharacterCheck";
checkstyle_checks_whitespace_IndentationCharacterCheck.__super__ = checkstyle_checks_whitespace_LineCheckBase;
checkstyle_checks_whitespace_IndentationCharacterCheck.prototype = $extend(checkstyle_checks_whitespace_LineCheckBase.prototype,{
	character: null
	,ignorePattern: null
	,actualRun: function() {
		var ignoreRE = new EReg(this.ignorePattern,"");
		var re = this.character == "tab" ? new EReg("^\t*(\\S.*| \\*.*)?$","") : new EReg("^ *(\\S.*)?$","");
		var _g = 0;
		var _g1 = this.checker.lines.length;
		while(_g < _g1) {
			var i = _g++;
			var line = this.checker.lines[i];
			var ranges = this.getRanges(line);
			var _g2 = [];
			var _g3 = 0;
			var _g4 = ranges;
			while(_g3 < _g4.length) {
				var v = _g4[_g3];
				++_g3;
				if(v.type == checkstyle_checks_whitespace_RangeType.TEXT && v.start == 0) {
					_g2.push(v);
				}
			}
			var startTextRange = _g2[0];
			if(startTextRange == null) {
				continue;
			}
			var startText = line.substring(startTextRange.start,startTextRange.end);
			if(ignoreRE.match(line) || this.isLineSuppressed(i)) {
				continue;
			}
			if(!re.match(startText)) {
				this.log("Wrong indentation character (should be " + this.character + ")",i + 1,0,i + 1,0);
			}
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "character", values : ["space","tab"]}]}];
	}
	,__class__: checkstyle_checks_whitespace_IndentationCharacterCheck
});
var checkstyle_checks_whitespace_IndentationCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.character = "tab";
	this.ignoreConditionals = false;
	this.ignoreComments = true;
	this.wrapPolicy = "larger";
	this.conditionalPolicy = "aligned";
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.whitespace.IndentationCheck"] = checkstyle_checks_whitespace_IndentationCheck;
checkstyle_checks_whitespace_IndentationCheck.__name__ = "checkstyle.checks.whitespace.IndentationCheck";
checkstyle_checks_whitespace_IndentationCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_whitespace_IndentationCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	character: null
	,ignoreConditionals: null
	,conditionalPolicy: null
	,ignoreComments: null
	,wrapPolicy: null
	,actualRun: function() {
		var lineIndentation = this.calcLineIndentation();
		var wrappedStatements = this.calcWrapStatements();
		var tolerateViolations = this.calcIgnoreLineIndentation();
		var ignoreCond = this.ignoreConditionals;
		if(this.conditionalPolicy == "ignore") {
			ignoreCond = true;
		}
		this.correctWrappedIndentation(lineIndentation,wrappedStatements);
		var splitChar = this.character;
		if(splitChar == "tab") {
			splitChar = "\t";
		}
		var _g = 0;
		var _g1 = this.checker.lines.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.isLineSuppressed(i)) {
				continue;
			}
			var line = this.checker.lines[i];
			if(new EReg("^\\s*$","").match(line)) {
				continue;
			}
			if(ignoreCond && new EReg("^\\s*#","").match(line)) {
				continue;
			}
			var e = new EReg("^(\\s*)","");
			e.match(line);
			var matched = e.matched(0);
			var actual = matched.split(splitChar).length - 1;
			var expected = lineIndentation[i];
			this.logMsg(expected,actual,tolerateViolations[i],wrappedStatements[i],i,matched.length);
		}
	}
	,logMsg: function(expected,actual,tolerate,wrapped,line,length) {
		if(actual == expected) {
			return;
		}
		if(tolerate) {
			return;
		}
		if(wrapped) {
			switch(this.wrapPolicy) {
			case "exact":
				break;
			case "larger":
				if(actual >= expected) {
					return;
				}
				break;
			case "none":
				break;
			}
		}
		var expectedText = this.buildReadableIndentCount(expected);
		var actualText = this.buildReadableIndentCount(actual);
		this.log("Indentation mismatch: expected: " + expectedText + ", actual: " + actualText,line + 1,0,line + 1,length);
	}
	,buildReadableIndentCount: function(count) {
		if(count == 0) {
			return "no indentation";
		}
		var indent = "";
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			indent += this.character;
		}
		indent = indent.split("tab").join("\\t");
		return "\"" + indent + "\"[" + count + "]";
	}
	,correctWrappedIndentation: function(lineIndentation,wrappedStatements) {
		if(this.wrapPolicy == "none") {
			return;
		}
		var currentIndent = 0;
		var _g = 0;
		var _g1 = lineIndentation.length;
		while(_g < _g1) {
			var i = _g++;
			if(!wrappedStatements[i]) {
				currentIndent = lineIndentation[i];
				continue;
			}
			if(currentIndent < lineIndentation[i]) {
				currentIndent = -1;
				continue;
			}
			if(currentIndent == lineIndentation[i]) {
				lineIndentation[i]++;
			}
		}
	}
	,calcLineIndentation: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.checker.lines.length;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(0);
		}
		var lineIndentation = _g;
		var tokenList = this.checker.getTokenTree().filterCallback(function(token,depth) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 3:case 4:case 5:case 6:case 7:case 15:case 16:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 3:
				switch(_g.s) {
				case "else":case "elseif":case "end":case "error":case "if":
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 15:case 17:
				return tokentree_FilterResult.FoundGoDeeper;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < tokenList.length) {
			var token = tokenList[_g];
			++_g;
			var _g1 = token.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 0:
					this.calcLineIndentationFunction(token,lineIndentation);
					break;
				case 3:case 4:
					this.calcLineIndentationIf(token,lineIndentation);
					break;
				case 5:case 6:case 7:
					this.calcLineIndentationLoops(token,lineIndentation);
					break;
				case 15:
					var child = token.getLastChild();
					if(child == null) {
						continue;
					}
					this.increaseRangeIndent(child.getPos(),lineIndentation);
					break;
				case 16:
					var child1 = token.getLastChild();
					if(child1 == null) {
						continue;
					}
					this.increaseRangeIndent(child1.getPos(),lineIndentation);
					break;
				default:
				}
				break;
			case 3:
				var _g2 = _g1.s;
				this.calcLineIndentationSharp(token,lineIndentation);
				break;
			case 15:
				this.calcLineIndentationBkOpen(token,lineIndentation);
				break;
			case 17:
				var brClose = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BrClose);
				this.increaseBlockIndent(token,brClose,lineIndentation);
				if(token.parent.tok._hx_index == 15) {
					continue;
				}
				break;
			default:
			}
		}
		return lineIndentation;
	}
	,calcLineIndentationBkOpen: function(token,lineIndentation) {
		var child = token.getFirstChild();
		if(child == null) {
			return;
		}
		if(child.matches(tokentree_TokenTreeDef.BrOpen) || child.matches(tokentree_TokenTreeDef.BkOpen)) {
			if(token.pos.min + 1 == child.pos.min) {
				return;
			}
		}
		var bkClose = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BkClose);
		this.increaseBlockIndent(token,bkClose,lineIndentation);
	}
	,calcLineIndentationFunction: function(token,lineIndentation) {
		var body = tokentree_TokenTreeAccessHelper.lastChild(tokentree_TokenTreeAccessHelper.firstChild(token));
		if(body == null) {
			return;
		}
		if(body.matches(tokentree_TokenTreeDef.BrOpen)) {
			return;
		}
		this.increaseIndentIfNextLine(token,body,lineIndentation);
	}
	,calcLineIndentationIf: function(token,lineIndentation) {
		var _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 3:
				var child = token.getLastChild();
				if(child == null) {
					return;
				}
				if(child.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse))) {
					child = token.children[token.children.length - 2];
				}
				if(child.matches(tokentree_TokenTreeDef.BrOpen)) {
					return;
				}
				this.increaseIndentIfNextLine(token,child,lineIndentation);
				break;
			case 4:
				var child = token.getFirstChild();
				if(child == null) {
					return;
				}
				if(child.matches(tokentree_TokenTreeDef.BrOpen)) {
					return;
				}
				this.increaseIndentIfNextLine(token,child,lineIndentation);
				break;
			default:
			}
		}
	}
	,calcLineIndentationSharp: function(token,lineIndentation) {
		var linePos = this.checker.getLinePos(token.pos.min);
		var line = this.checker.lines[linePos.line];
		var prefix = HxOverrides.substr(line,0,linePos.ofs + 1);
		var isFirst = new EReg("^\\s*#$","").match(prefix);
		switch(this.conditionalPolicy) {
		case "aligned":
			return;
		case "aligned_increase":
			break;
		case "fixed_zero":
			if(!isFirst) {
				return;
			}
			lineIndentation[linePos.line] = 0;
			return;
		case "ignore":
			return;
		}
		var _g = token.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "end":
				break;
			case "error":
				break;
			case "else":case "elseif":case "if":
				var _g = 0;
				var _g1 = token.children;
				while(_g < _g1.length) {
					var child = _g1[_g];
					++_g;
					var _g2 = child.tok;
					if(_g2._hx_index == 3) {
						var _g3 = _g2.s;
						this.increaseIndentBetween(token,child,lineIndentation);
						return;
					}
				}
				break;
			default:
			}
		}
	}
	,calcLineIndentationLoops: function(token,lineIndentation) {
		var _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 5:
				var child = token.getLastChild();
				if(child == null) {
					return;
				}
				if(child.matches(tokentree_TokenTreeDef.BrOpen)) {
					return;
				}
				this.increaseIndentIfNextLine(token,child,lineIndentation);
				break;
			case 6:
				var child = token.getFirstChild();
				if(child == null) {
					return;
				}
				if(child.matches(tokentree_TokenTreeDef.BrOpen)) {
					return;
				}
				this.increaseIndentIfNextLine(token,child,lineIndentation);
				break;
			case 7:
				var child = token.getLastChild();
				if(child == null) {
					return;
				}
				if(child.matches(tokentree_TokenTreeDef.BrOpen)) {
					return;
				}
				if(child.matches(tokentree_TokenTreeDef.BkOpen)) {
					return;
				}
				while(child.getLastChild() != null) child = child.getLastChild();
				var start = this.checker.getLinePos(token.pos.min).line + 1;
				var end = this.checker.getLinePos(child.pos.min).line + 1;
				this.increaseIndent(lineIndentation,start,end);
				break;
			default:
			}
		}
	}
	,calcWrapStatements: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.checker.lines.length;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(false);
		}
		var wrapped = _g;
		var tokenList = this.checker.getTokenTree().filterCallback(function(token,depth) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 10:case 15:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 6:
				var _g1 = _g.op;
				switch(_g1._hx_index) {
				case 4:case 22:
					return tokentree_FilterResult.FoundGoDeeper;
				case 20:
					switch(_g1.op._hx_index) {
					case 0:case 1:case 2:case 3:case 11:case 12:case 13:case 16:case 17:case 18:case 19:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
						return tokentree_FilterResult.GoDeeper;
					}
					break;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 11:case 19:
				return tokentree_FilterResult.FoundGoDeeper;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < tokenList.length) {
			var token = tokenList[_g];
			++_g;
			var pos = token.getPos();
			var child = token.getFirstChild();
			if(child == null) {
				continue;
			}
			var linePos = this.checker.getLinePos(token.pos.min);
			var line = this.checker.lines[linePos.line];
			var _g1 = token.tok;
			switch(_g1._hx_index) {
			case 1:
				if(_g1.k._hx_index == 10) {
					var isLast = new EReg("return\\s*$","").match(line);
					if(!isLast) {
						continue;
					}
					pos = token.parent.getPos();
				}
				break;
			case 6:
				if(_g1.op._hx_index == 4) {
					var isLast1 = new EReg("=\\s*$","").match(line);
					if(!isLast1) {
						continue;
					}
					var nextLine = this.checker.lines[linePos.line + 1];
					if(nextLine == null) {
						continue;
					}
					var isBracketOnly = new EReg("^\\s*[\\[\\(\\{<]$","").match(nextLine);
					if(isBracketOnly) {
						continue;
					}
					pos = token.parent.getPos();
				}
				break;
			case 11:
				var prefix = HxOverrides.substr(line,0,linePos.ofs + 1);
				var isFirst = new EReg("^\\s*\\.$","").match(prefix);
				if(!isFirst) {
					continue;
				}
				pos = token.parent.getPos();
				break;
			case 19:
				var pClose = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.PClose);
				if(pClose != null) {
					var prev = this.checker.tokens[pClose.index - 1];
					pos.max = prev.pos.max;
				}
				break;
			default:
			}
			this.ignoreRange(pos,wrapped);
		}
		return wrapped;
	}
	,calcIgnoreLineIndentation: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.checker.lines.length;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(false);
		}
		var ignoreIndentation = _g;
		var tokenList = this.checker.getTokenTree().filterCallback(function(token,depth) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 2) {
					var _g2 = _g1.kind;
					var _g2 = _g1.s;
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 7:
				var _g1 = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			case 8:
				var _g1 = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < tokenList.length) {
			var token = tokenList[_g];
			++_g;
			var _g1 = token.tok;
			switch(_g1._hx_index) {
			case 2:
				var _g2 = _g1.c;
				if(_g2._hx_index == 2) {
					var _g3 = _g2.kind;
					var _g4 = _g2.s;
					this.ignoreRange(token.getPos(),ignoreIndentation);
				}
				break;
			case 7:
				var text = _g1.s;
				if(this.ignoreComments) {
					this.ignoreRange(token.getPos(),ignoreIndentation,false);
					continue;
				}
				var startLine = this.checker.getLinePos(token.pos.min).line;
				var endLine = this.checker.getLinePos(token.pos.max).line;
				var _g5 = startLine + 1;
				var _g6 = endLine;
				while(_g5 < _g6) {
					var index = _g5++;
					ignoreIndentation[index] = true;
				}
				break;
			case 8:
				var _g7 = _g1.s;
				if(!this.ignoreComments) {
					continue;
				}
				var lineIndex = this.checker.getLinePos(token.pos.min).line;
				var line = this.checker.lines[lineIndex];
				if(new EReg("^\\s*//","").match(line)) {
					ignoreIndentation[lineIndex] = true;
				}
				break;
			default:
			}
		}
		return ignoreIndentation;
	}
	,increaseBlockIndent: function(blockStart,blockEnd,lineIndentation) {
		if(blockEnd == null) {
			blockEnd = blockStart.getLastChild();
		}
		this.increaseIndentBetween(blockStart,blockEnd,lineIndentation);
	}
	,increaseIndentBetween: function(blockStart,blockEnd,lineIndentation) {
		if(blockEnd == null) {
			return;
		}
		var start = this.checker.getLinePos(blockStart.pos.min).line + 1;
		var end = this.checker.getLinePos(blockEnd.pos.min).line;
		this.increaseIndent(lineIndentation,start,end);
	}
	,increaseRangeIndent: function(pos,lineIndentation) {
		var start = this.checker.getLinePos(pos.min).line + 1;
		var end = this.checker.getLinePos(pos.max).line + 1;
		this.increaseIndent(lineIndentation,start,end);
	}
	,increaseIndentIfNextLine: function(parent,child,lineIndentation) {
		if(child == null) {
			return;
		}
		var parentLine = this.checker.getLinePos(parent.pos.min).line;
		var childLine = this.checker.getLinePos(child.pos.min).line;
		if(parentLine == childLine) {
			return;
		}
		lineIndentation[childLine]++;
	}
	,ignoreRange: function(pos,ignoreIndentation,excludeStartLine) {
		if(excludeStartLine == null) {
			excludeStartLine = true;
		}
		var start = this.checker.getLinePos(pos.min).line;
		if(excludeStartLine) {
			++start;
		}
		var end = this.checker.getLinePos(pos.max).line + 1;
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var i = _g++;
			ignoreIndentation[i] = true;
		}
	}
	,increaseIndent: function(lineIndentation,start,end) {
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var i = _g++;
			lineIndentation[i]++;
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "character", values : ["tab","        ","       ","      ","     ","    ","   ","  "," "]},{ propertyName : "conditionalPolicy", values : ["fixed_zero","aligned","aligned_increase","ignore"]},{ propertyName : "ignoreConditionals", values : [true,false]},{ propertyName : "ignoreComments", values : [true,false]},{ propertyName : "wrapPolicy", values : ["none","exact","larger"]}]}];
	}
	,__class__: checkstyle_checks_whitespace_IndentationCheck
});
var checkstyle_checks_whitespace_RangeType = $hxEnums["checkstyle.checks.whitespace.RangeType"] = { __ename__ : true, __constructs__ : ["TEXT","COMMENT","STRING"]
	,TEXT: {_hx_index:0,__enum__:"checkstyle.checks.whitespace.RangeType",toString:$estr}
	,COMMENT: ($_=function(isBlock) { return {_hx_index:1,isBlock:isBlock,__enum__:"checkstyle.checks.whitespace.RangeType",toString:$estr}; },$_.__params__ = ["isBlock"],$_)
	,STRING: ($_=function(isInterpolated) { return {_hx_index:2,isInterpolated:isInterpolated,__enum__:"checkstyle.checks.whitespace.RangeType",toString:$estr}; },$_.__params__ = ["isInterpolated"],$_)
};
var checkstyle_checks_whitespace_ListOfEmptyLines = function() {
	this.lines = [];
	this.lineRanges = null;
};
$hxClasses["checkstyle.checks.whitespace.ListOfEmptyLines"] = checkstyle_checks_whitespace_ListOfEmptyLines;
checkstyle_checks_whitespace_ListOfEmptyLines.__name__ = "checkstyle.checks.whitespace.ListOfEmptyLines";
checkstyle_checks_whitespace_ListOfEmptyLines.detectEmptyLines = function(checker) {
	var emptyLines = new checkstyle_checks_whitespace_ListOfEmptyLines();
	var _g = 0;
	var _g1 = checker.lines.length;
	while(_g < _g1) {
		var index = _g++;
		if(new EReg("^\\s*$","").match(checker.lines[index])) {
			emptyLines.add(index);
		}
	}
	return emptyLines;
};
checkstyle_checks_whitespace_ListOfEmptyLines.prototype = {
	lineRanges: null
	,lines: null
	,add: function(line) {
		this.lines.push(line);
	}
	,checkRange: function(policy,max,range,line) {
		switch(policy) {
		case "atleast":
			return this.checkRangeAtLeast(range,max,line);
		case "exact":
			return this.checkRangeExact(range,max,line);
		case "ignore":
			return checkstyle_checks_whitespace_EmptyLineRange.NONE;
		case "none":
			return range;
		case "upto":
			return this.checkRangeUpto(range,max,line);
		}
	}
	,checkRangeExact: function(range,max,line) {
		switch(range._hx_index) {
		case 0:
			return checkstyle_checks_whitespace_EmptyLineRange.SINGLE(line);
		case 1:
			var l = range.line;
			if(max == 1) {
				return checkstyle_checks_whitespace_EmptyLineRange.NONE;
			}
			break;
		case 2:
			var rangeEnd = range.end;
			var rangeStart = range.start;
			if(1 + rangeEnd - rangeStart == max) {
				return checkstyle_checks_whitespace_EmptyLineRange.NONE;
			}
			break;
		}
		return range;
	}
	,checkRangeUpto: function(range,max,line) {
		switch(range._hx_index) {
		case 0:
			return checkstyle_checks_whitespace_EmptyLineRange.NONE;
		case 1:
			var l = range.line;
			if(max >= 1) {
				return checkstyle_checks_whitespace_EmptyLineRange.NONE;
			}
			break;
		case 2:
			var rangeEnd = range.end;
			var rangeStart = range.start;
			if(1 + rangeEnd - rangeStart <= max) {
				return checkstyle_checks_whitespace_EmptyLineRange.NONE;
			}
			break;
		}
		return range;
	}
	,checkRangeAtLeast: function(range,max,line) {
		switch(range._hx_index) {
		case 0:
			return checkstyle_checks_whitespace_EmptyLineRange.SINGLE(line);
		case 1:
			var l = range.line;
			if(max == 1) {
				return checkstyle_checks_whitespace_EmptyLineRange.NONE;
			}
			break;
		case 2:
			var rangeEnd = range.end;
			var rangeStart = range.start;
			if(1 + rangeEnd - rangeStart >= max) {
				return checkstyle_checks_whitespace_EmptyLineRange.NONE;
			}
			break;
		}
		return range;
	}
	,checkPolicySingleRange: function(policy,max,start,end) {
		if(start > end) {
			throw haxe_Exception.thrown("*** wrong order!! *** " + start + " " + end);
		}
		var range = this.getRanges(start,end);
		switch(policy) {
		case "atleast":
			if(range.length <= 0) {
				return checkstyle_checks_whitespace_EmptyLineRange.SINGLE(start);
			}
			if(range.length > 1) {
				return range[0];
			}
			return this.checkRangeAtLeast(range[0],max,start);
		case "exact":
			if(range.length <= 0) {
				return checkstyle_checks_whitespace_EmptyLineRange.SINGLE(end);
			}
			if(range.length != 1) {
				return range[0];
			}
			return this.checkRangeExact(range[0],max,end);
		case "ignore":
			return checkstyle_checks_whitespace_EmptyLineRange.NONE;
		case "none":
			if(range.length == 0) {
				return checkstyle_checks_whitespace_EmptyLineRange.NONE;
			}
			return range[0];
		case "upto":
			if(range.length <= 0) {
				return checkstyle_checks_whitespace_EmptyLineRange.NONE;
			}
			if(range.length > 1) {
				return range[0];
			}
			return this.checkRangeUpto(range[0],max,end);
		}
	}
	,getRanges: function(startLine,endLine) {
		if(this.lineRanges == null) {
			this.lineRanges = this.makeRanges();
		}
		var results = [];
		var _g = 0;
		var _g1 = this.lineRanges;
		while(_g < _g1.length) {
			var range = _g1[_g];
			++_g;
			switch(range._hx_index) {
			case 0:
				break;
			case 1:
				var line = range.line;
				if(startLine <= line && line <= endLine) {
					results.push(range);
				}
				break;
			case 2:
				var end = range.end;
				var start = range.start;
				if(end >= startLine && start <= endLine) {
					results.push(range);
				}
				break;
			}
		}
		return results;
	}
	,makeRanges: function() {
		var results = [];
		if(this.lines.length <= 0) {
			return [];
		}
		var start = this.lines[0];
		var current = start;
		var _g = 1;
		var _g1 = this.lines.length;
		while(_g < _g1) {
			var index = _g++;
			var val = this.lines[index];
			if(val == current + 1) {
				current = val;
				continue;
			}
			if(current == start) {
				results.push(checkstyle_checks_whitespace_EmptyLineRange.SINGLE(start));
			} else {
				results.push(checkstyle_checks_whitespace_EmptyLineRange.RANGE(start,current));
			}
			start = val;
			current = val;
		}
		if(current == start) {
			results.push(checkstyle_checks_whitespace_EmptyLineRange.SINGLE(start));
		} else {
			results.push(checkstyle_checks_whitespace_EmptyLineRange.RANGE(start,current));
		}
		return results;
	}
	,countEmptylinesBetween: function(startLine,endLine) {
		var count = 0;
		var _g = 0;
		var _g1 = this.lines;
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			if(line < startLine) {
				continue;
			}
			if(line > endLine) {
				continue;
			}
			++count;
		}
		return count;
	}
	,toString: function() {
		return this.lineRanges.toString();
	}
	,__class__: checkstyle_checks_whitespace_ListOfEmptyLines
};
var checkstyle_checks_whitespace_EmptyLineRange = $hxEnums["checkstyle.checks.whitespace.EmptyLineRange"] = { __ename__ : true, __constructs__ : ["NONE","SINGLE","RANGE"]
	,NONE: {_hx_index:0,__enum__:"checkstyle.checks.whitespace.EmptyLineRange",toString:$estr}
	,SINGLE: ($_=function(line) { return {_hx_index:1,line:line,__enum__:"checkstyle.checks.whitespace.EmptyLineRange",toString:$estr}; },$_.__params__ = ["line"],$_)
	,RANGE: ($_=function(start,end) { return {_hx_index:2,start:start,end:end,__enum__:"checkstyle.checks.whitespace.EmptyLineRange",toString:$estr}; },$_.__params__ = ["start","end"],$_)
};
var checkstyle_checks_whitespace_WhitespaceCheckBase = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.whitespace.WhitespaceCheckBase"] = checkstyle_checks_whitespace_WhitespaceCheckBase;
checkstyle_checks_whitespace_WhitespaceCheckBase.__name__ = "checkstyle.checks.whitespace.WhitespaceCheckBase";
checkstyle_checks_whitespace_WhitespaceCheckBase.__super__ = checkstyle_checks_Check;
checkstyle_checks_whitespace_WhitespaceCheckBase.prototype = $extend(checkstyle_checks_Check.prototype,{
	checkTokens: function(root,tokens,policy) {
		if(policy == null || policy == "ignore") {
			return;
		}
		var tokenList = root.filterCallback(function(token,depth) {
			if(token.matchesAny(tokens)) {
				return tokentree_FilterResult.FoundGoDeeper;
			}
			return tokentree_FilterResult.GoDeeper;
		});
		this.checkTokenList(tokenList,policy);
	}
	,checkTokenList: function(tokens,policy) {
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			if(this.isPosSuppressed(token.pos)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.isImportMult(token)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.filterOpSub(token)) {
				continue;
			}
			this.checkWhitespace(token,this.adjustPolicy(token,policy));
		}
	}
	,adjustPolicy: function(token,policy) {
		return policy;
	}
	,checkWhitespace: function(tok,policy) {
		var _gthis = this;
		this.checkWhitespaceExt(tok,function(before,after) {
			switch(policy) {
			case "after":
				if(!before && after) {
					return;
				}
				break;
			case "around":
				if(before && after) {
					return;
				}
				break;
			case "before":
				if(before && !after) {
					return;
				}
				break;
			case "none":
				if(!before && !after) {
					return;
				}
				break;
			default:
				return;
			}
			_gthis.violation(tok,Std.string(policy));
		});
	}
	,checkUnaryWhitespace: function(tok,policy) {
		var _gthis = this;
		var leftSide = tokentree_utils_TokenTreeCheckUtils.isUnaryLeftSided(tok);
		this.checkWhitespaceExt(tok,function(before,after) {
			switch(policy) {
			case "inner":
				if(leftSide && after) {
					return;
				}
				if(!leftSide && before) {
					return;
				}
				break;
			case "none":
				if(leftSide && !after) {
					return;
				}
				if(!leftSide && !before) {
					return;
				}
				break;
			default:
				return;
			}
			_gthis.violation(tok,Std.string(policy));
		});
	}
	,checkWhitespaceExt: function(tok,checkCallback) {
		var linePos = this.checker.getLinePos(tok.pos.min);
		var tokLen = tok.toString().length;
		var _g = tok.tok;
		var tmp;
		if(_g._hx_index == 9) {
			var _g1 = _g.s;
			tmp = true;
		} else {
			tmp = false;
		}
		if(tmp) {
			linePos = this.checker.getLinePos(tok.pos.max - 3);
			tokLen = 3;
		}
		var line = haxe_io_Bytes.ofString(this.checker.lines[linePos.line]);
		var before = line.sub(0,linePos.ofs).toString();
		var offs = linePos.ofs + tokLen;
		var after = line.sub(offs,line.length - offs).toString();
		var whitespaceBefore = new EReg("^(.*\\s|)$","").match(before);
		var whitespaceAfter = new EReg("^(\\s.*|)$","").match(after);
		checkCallback(whitespaceBefore,whitespaceAfter);
	}
	,violation: function(tok,policy) {
	}
	,__class__: checkstyle_checks_whitespace_WhitespaceCheckBase
});
var checkstyle_checks_whitespace_OperatorWhitespaceCheck = function() {
	checkstyle_checks_whitespace_WhitespaceCheckBase.call(this);
	this.assignOpPolicy = "around";
	this.unaryOpPolicy = "none";
	this.ternaryOpPolicy = "around";
	this.arithmeticOpPolicy = "around";
	this.compareOpPolicy = "around";
	this.bitwiseOpPolicy = "around";
	this.boolOpPolicy = "around";
	this.intervalOpPolicy = "none";
	this.arrowPolicy = "around";
	this.arrowFunctionPolicy = "around";
	this.oldFunctionTypePolicy = "around";
	this.newFunctionTypePolicy = "around";
};
$hxClasses["checkstyle.checks.whitespace.OperatorWhitespaceCheck"] = checkstyle_checks_whitespace_OperatorWhitespaceCheck;
checkstyle_checks_whitespace_OperatorWhitespaceCheck.__name__ = "checkstyle.checks.whitespace.OperatorWhitespaceCheck";
checkstyle_checks_whitespace_OperatorWhitespaceCheck.__super__ = checkstyle_checks_whitespace_WhitespaceCheckBase;
checkstyle_checks_whitespace_OperatorWhitespaceCheck.prototype = $extend(checkstyle_checks_whitespace_WhitespaceCheckBase.prototype,{
	assignOpPolicy: null
	,unaryOpPolicy: null
	,ternaryOpPolicy: null
	,arithmeticOpPolicy: null
	,compareOpPolicy: null
	,bitwiseOpPolicy: null
	,boolOpPolicy: null
	,intervalOpPolicy: null
	,arrowPolicy: null
	,arrowFunctionPolicy: null
	,oldFunctionTypePolicy: null
	,newFunctionTypePolicy: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		this.checkAssignOps(root);
		this.checkUnaryOps(root);
		this.checkTernaryOps(root);
		this.checkArithmeticOps(root);
		this.checkCompareOps(root);
		this.checkBitwiseOps(root);
		this.checkBoolOps(root);
		this.checkIntervalOps(root);
		this.checkArrowOps(root);
		this.checkFunctionArg(root);
	}
	,checkAssignOps: function(root) {
		this.checkTokens(root,[tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpSub)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpDiv)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMod)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShl)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpOr)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAnd)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpXor))],this.assignOpPolicy);
	}
	,checkUnaryOps: function(root) {
		if(this.unaryOpPolicy == null || this.unaryOpPolicy == "ignore") {
			return;
		}
		var tokens = root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 5) {
				switch(_g.op._hx_index) {
				case 0:case 1:case 2:case 4:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			if(this.isPosSuppressed(token.pos)) {
				continue;
			}
			this.checkUnaryWhitespace(token,this.unaryOpPolicy);
		}
	}
	,checkTernaryOps: function(root) {
		if(this.ternaryOpPolicy == null || this.ternaryOpPolicy == "ignore") {
			return;
		}
		var tokens = root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 21) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			if(this.isPosSuppressed(token.pos)) {
				continue;
			}
			if(!tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
				continue;
			}
			this.checkWhitespace(token,this.ternaryOpPolicy);
			this.checkWhitespace(token.getLastChild(),this.ternaryOpPolicy);
		}
	}
	,checkArithmeticOps: function(root) {
		this.checkTokens(root,[tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAdd),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpSub),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpMult),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpDiv),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpMod)],this.arithmeticOpPolicy);
	}
	,checkCompareOps: function(root) {
		this.checkTokens(root,[tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGte),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLte),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpEq),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpNotEq)],this.compareOpPolicy);
	}
	,checkBitwiseOps: function(root) {
		this.checkTokens(root,[tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpOr),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpXor),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShl),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpUShr)],this.bitwiseOpPolicy);
	}
	,checkBoolOps: function(root) {
		this.checkTokens(root,[tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpBoolAnd),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpBoolOr)],this.boolOpPolicy);
	}
	,checkIntervalOps: function(root) {
		if(this.intervalOpPolicy == null || this.intervalOpPolicy == "ignore") {
			return;
		}
		var tokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 6:
				if(_g.op._hx_index == 21) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 9:
				var _g1 = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		this.checkTokenList(tokens,this.intervalOpPolicy);
	}
	,checkArrowOps: function(root) {
		if(this.arrowPolicy == null || this.arrowPolicy == "ignore") {
			return;
		}
		var tokens = root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 6) {
				if(_g.op._hx_index == 22) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		this.checkTokenList(tokens,this.arrowPolicy);
	}
	,checkFunctionArg: function(root) {
		if((this.arrowFunctionPolicy == null || this.arrowFunctionPolicy == "ignore") && (this.oldFunctionTypePolicy == null || this.oldFunctionTypePolicy == "ignore") && (this.newFunctionTypePolicy == null || this.newFunctionTypePolicy == "ignore")) {
			return;
		}
		var tokens = root.filterCallback(function(token,depth) {
			if(token.tok._hx_index == 13) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			if(this.isPosSuppressed(token.pos)) {
				continue;
			}
			var type = tokentree_utils_TokenTreeCheckUtils.getArrowType(token);
			switch(type._hx_index) {
			case 0:
				this.checkWhitespace(token,this.arrowFunctionPolicy);
				break;
			case 1:
				this.checkWhitespace(token,this.oldFunctionTypePolicy);
				break;
			case 2:
				this.checkWhitespace(token,this.newFunctionTypePolicy);
				break;
			}
		}
	}
	,violation: function(tok,policy) {
		this.logPos("OperatorWhitespace policy \"" + policy + "\" violated by \"" + Std.string(tok) + "\"",tok.pos);
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "assignOpPolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "ternaryOpPolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "arithmeticOpPolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "unaryOpPolicy", values : ["inner","none","ignore"]},{ propertyName : "compareOpPolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "bitwiseOpPolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "boolOpPolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "intervalOpPolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "arrowPolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "oldFunctionTypePolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "newFunctionTypePolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "arrowFunctionPolicy", values : ["before","after","around","none","ignore"]}]}];
	}
	,__class__: checkstyle_checks_whitespace_OperatorWhitespaceCheck
});
var checkstyle_checks_whitespace_WrapCheckBase = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.option = "eol";
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.whitespace.WrapCheckBase"] = checkstyle_checks_whitespace_WrapCheckBase;
checkstyle_checks_whitespace_WrapCheckBase.__name__ = "checkstyle.checks.whitespace.WrapCheckBase";
checkstyle_checks_whitespace_WrapCheckBase.__super__ = checkstyle_checks_Check;
checkstyle_checks_whitespace_WrapCheckBase.prototype = $extend(checkstyle_checks_Check.prototype,{
	tokens: null
	,option: null
	,hasToken: function(token) {
		if(this.tokens.length != 0) {
			return this.tokens.indexOf(token) != -1;
		} else {
			return true;
		}
	}
	,checkTokens: function(tokenList) {
		var root = this.checker.getTokenTree();
		var allTokens = root.filterCallback(function(token,depth) {
			if(token.matchesAny(tokenList)) {
				return tokentree_FilterResult.FoundGoDeeper;
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < allTokens.length) {
			var tok = allTokens[_g];
			++_g;
			if(this.isPosSuppressed(tok.pos)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.isOpGtTypedefExtension(tok)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(tok)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.isImportMult(tok)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.filterOpSub(tok)) {
				continue;
			}
			var linePos = this.checker.getLinePos(tok.pos.min);
			var line = haxe_io_Bytes.ofString(this.checker.lines[linePos.line]);
			var before = line.sub(0,linePos.ofs).toString();
			var tokLen = tok.toString().length;
			var offs = linePos.ofs + tokLen;
			var after = line.sub(offs,line.length - offs).toString();
			if(new EReg("^\\s*$","").match(before)) {
				if(this.option != "nl") {
					this.logPos("Token \"" + Std.string(tok) + "\" must be at the end of the line",tok.pos);
					continue;
				}
			}
			if(new EReg("^\\s*(//.*|/\\*.*|)$","").match(after)) {
				if(this.option != "eol") {
					this.logPos("Token \"" + Std.string(tok) + "\" must be on a new line",tok.pos);
				}
			}
		}
	}
	,__class__: checkstyle_checks_whitespace_WrapCheckBase
});
var checkstyle_checks_whitespace_OperatorWrapCheck = function() {
	checkstyle_checks_whitespace_WrapCheckBase.call(this);
	this.tokens = ["=","+","-","*","/","%",">","<",">=","<=","==","!=","&","|","^","&&","||","<<",">>",">>>","+=","-=","*=","/=","%=","<<=",">>=",">>>=","|=","&=","^=","...","=>","++","--"];
};
$hxClasses["checkstyle.checks.whitespace.OperatorWrapCheck"] = checkstyle_checks_whitespace_OperatorWrapCheck;
checkstyle_checks_whitespace_OperatorWrapCheck.__name__ = "checkstyle.checks.whitespace.OperatorWrapCheck";
checkstyle_checks_whitespace_OperatorWrapCheck.__super__ = checkstyle_checks_whitespace_WrapCheckBase;
checkstyle_checks_whitespace_OperatorWrapCheck.prototype = $extend(checkstyle_checks_whitespace_WrapCheckBase.prototype,{
	actualRun: function() {
		var tokenList = [];
		if(this.hasToken("=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		}
		if(this.hasToken("+")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAdd));
		}
		if(this.hasToken("-")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpSub));
		}
		if(this.hasToken("*")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpMult));
		}
		if(this.hasToken("/")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpDiv));
		}
		if(this.hasToken("%")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpMod));
		}
		if(this.hasToken(">")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		}
		if(this.hasToken("<")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt));
		}
		if(this.hasToken(">=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGte));
		}
		if(this.hasToken("<=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLte));
		}
		if(this.hasToken("==")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpEq));
		}
		if(this.hasToken("!=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpNotEq));
		}
		if(this.hasToken("&")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd));
		}
		if(this.hasToken("|")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpOr));
		}
		if(this.hasToken("^")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpXor));
		}
		if(this.hasToken("&&")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpBoolAnd));
		}
		if(this.hasToken("||")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpBoolOr));
		}
		if(this.hasToken("<<")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShl));
		}
		if(this.hasToken(">>")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr));
		}
		if(this.hasToken(">>>")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpUShr));
		}
		if(this.hasToken("+=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd)));
		}
		if(this.hasToken("-=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpSub)));
		}
		if(this.hasToken("*=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult)));
		}
		if(this.hasToken("/=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpDiv)));
		}
		if(this.hasToken("%=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMod)));
		}
		if(this.hasToken("<<=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShl)));
		}
		if(this.hasToken(">>=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr)));
		}
		if(this.hasToken(">>>=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr)));
		}
		if(this.hasToken("|=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpOr)));
		}
		if(this.hasToken("&=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAnd)));
		}
		if(this.hasToken("^=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpXor)));
		}
		if(this.hasToken("...")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpInterval));
		}
		if(this.hasToken("=>")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpArrow));
		}
		if(this.hasToken("!")) {
			tokenList.push(tokentree_TokenTreeDef.Unop(haxe_macro_Unop.OpNot));
		}
		if(this.hasToken("++")) {
			tokenList.push(tokentree_TokenTreeDef.Unop(haxe_macro_Unop.OpIncrement));
		}
		if(this.hasToken("--")) {
			tokenList.push(tokentree_TokenTreeDef.Unop(haxe_macro_Unop.OpDecrement));
		}
		if(tokenList.length <= 0) {
			return;
		}
		this.checkTokens(tokenList);
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "option", values : ["eol","nl"]}]}];
	}
	,__class__: checkstyle_checks_whitespace_OperatorWrapCheck
});
var checkstyle_checks_whitespace_SeparatorWhitespaceCheck = function() {
	checkstyle_checks_whitespace_WhitespaceCheckBase.call(this);
	this.dotPolicy = "none";
	this.commaPolicy = "after";
	this.semicolonPolicy = "after";
	this.allowTrailingComma = false;
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.whitespace.SeparatorWhitespaceCheck"] = checkstyle_checks_whitespace_SeparatorWhitespaceCheck;
checkstyle_checks_whitespace_SeparatorWhitespaceCheck.__name__ = "checkstyle.checks.whitespace.SeparatorWhitespaceCheck";
checkstyle_checks_whitespace_SeparatorWhitespaceCheck.__super__ = checkstyle_checks_whitespace_WhitespaceCheckBase;
checkstyle_checks_whitespace_SeparatorWhitespaceCheck.prototype = $extend(checkstyle_checks_whitespace_WhitespaceCheckBase.prototype,{
	dotPolicy: null
	,commaPolicy: null
	,allowTrailingComma: null
	,semicolonPolicy: null
	,actualRun: function() {
		var root = this.checker.getTokenTree();
		this.checkTokens(root,[tokentree_TokenTreeDef.Dot],this.dotPolicy);
		this.checkTokens(root,[tokentree_TokenTreeDef.Comma],this.commaPolicy);
		this.checkTokens(root,[tokentree_TokenTreeDef.Semicolon],this.semicolonPolicy);
	}
	,adjustPolicy: function(token,policy) {
		if(token.tok._hx_index == 14) {
			if(this.allowTrailingComma) {
				var contentAfter = this.checker.getString(token.pos.max,token.pos.max + 1);
				switch(contentAfter) {
				case ")":case "]":case "}":
					switch(policy) {
					case "after":
						return "none";
					case "around":
						return "before";
					case "before":case "ignore":case "none":
						return policy;
					}
					break;
				default:
				}
			}
		}
		return policy;
	}
	,violation: function(tok,policy) {
		if(this.isWrapped(tok,js_Boot.__cast(policy , String))) {
			return;
		}
		this.logPos("SeparatorWhitespace policy \"" + policy + "\" violated by \"" + Std.string(tok) + "\"",tok.pos);
	}
	,isWrapped: function(tok,policy) {
		if(tok.tok._hx_index == 10) {
			return false;
		}
		if(policy == "around") {
			return false;
		}
		var index = tok.index;
		var tokPos = this.checker.getLinePos(tok.pos.min);
		var prevTok = this.checker.tokens[index - 1];
		var nextTok = this.checker.tokens[index + 1];
		var prevTokPos = this.checker.getLinePos(prevTok.pos.max);
		var nextTokPos = this.checker.getLinePos(nextTok.pos.min);
		var wrapBefore = prevTokPos.line != tokPos.line;
		var wrapAfter = tokPos.line != nextTokPos.line;
		switch(policy) {
		case "after":
			if(wrapBefore) {
				return true;
			}
			break;
		case "before":
			if(wrapAfter) {
				return true;
			}
			break;
		case "none":
			if(wrapBefore || wrapAfter) {
				return true;
			}
			break;
		default:
		}
		return false;
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "dotPolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "commaPolicy", values : ["before","after","around","none","ignore"]},{ propertyName : "semicolonPolicy", values : ["before","after","around","none","ignore"]}]}];
	}
	,__class__: checkstyle_checks_whitespace_SeparatorWhitespaceCheck
});
var checkstyle_checks_whitespace_SeparatorWrapCheck = function() {
	checkstyle_checks_whitespace_WrapCheckBase.call(this);
	this.tokens = [","];
};
$hxClasses["checkstyle.checks.whitespace.SeparatorWrapCheck"] = checkstyle_checks_whitespace_SeparatorWrapCheck;
checkstyle_checks_whitespace_SeparatorWrapCheck.__name__ = "checkstyle.checks.whitespace.SeparatorWrapCheck";
checkstyle_checks_whitespace_SeparatorWrapCheck.__super__ = checkstyle_checks_whitespace_WrapCheckBase;
checkstyle_checks_whitespace_SeparatorWrapCheck.prototype = $extend(checkstyle_checks_whitespace_WrapCheckBase.prototype,{
	actualRun: function() {
		var tokenList = [];
		if(this.hasToken(",")) {
			tokenList.push(tokentree_TokenTreeDef.Comma);
		}
		if(this.hasToken(".")) {
			tokenList.push(tokentree_TokenTreeDef.Dot);
		}
		if(tokenList.length <= 0) {
			return;
		}
		this.checkTokens(tokenList);
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "option", values : ["eol","nl"]}]}];
	}
	,__class__: checkstyle_checks_whitespace_SeparatorWrapCheck
});
var checkstyle_checks_whitespace_SpacingCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.spaceIfCondition = "should";
	this.spaceForLoop = "should";
	this.spaceWhileLoop = "should";
	this.spaceSwitchCase = "should";
	this.spaceCatch = "should";
	this.spaceAroundBinop = true;
	this.noSpaceAroundUnop = true;
	this.ignoreRangeOperator = true;
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.whitespace.SpacingCheck"] = checkstyle_checks_whitespace_SpacingCheck;
checkstyle_checks_whitespace_SpacingCheck.__name__ = "checkstyle.checks.whitespace.SpacingCheck";
checkstyle_checks_whitespace_SpacingCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_whitespace_SpacingCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	spaceAroundBinop: null
	,noSpaceAroundUnop: null
	,spaceIfCondition: null
	,spaceForLoop: null
	,spaceWhileLoop: null
	,spaceSwitchCase: null
	,spaceCatch: null
	,ignoreRangeOperator: null
	,actualRun: function() {
		var _gthis = this;
		var root = this.checker.getTokenTree();
		var acceptableTokens = root.filterCallback(function(token,depth) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 3:case 5:case 7:case 14:case 21:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < acceptableTokens.length) {
			var token = acceptableTokens[_g];
			++_g;
			var firstChild = token.getFirstChild();
			var _g1 = token.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 3:
					this.checkSpaceBetweenExpressions(token.toString(),token,firstChild,this.spaceIfCondition);
					break;
				case 5:
					this.checkSpaceBetweenExpressions(token.toString(),token,firstChild,this.spaceWhileLoop);
					break;
				case 7:
					this.checkSpaceBetweenExpressions(token.toString(),token,firstChild,this.spaceForLoop);
					break;
				case 14:
					this.checkSpaceBetweenExpressions(token.toString(),token,firstChild,this.spaceSwitchCase);
					break;
				case 21:
					this.checkSpaceBetweenExpressions(token.toString(),token,firstChild,this.spaceCatch);
					break;
				default:
				}
			}
		}
		var lastExpr = null;
		if(this.checker.ast == null) {
			return;
		}
		checkstyle_utils_ExprUtils.walkFile(this.checker.ast,function(e) {
			if(lastExpr == null) {
				lastExpr = e;
				return;
			}
			var _g = e.expr;
			switch(_g._hx_index) {
			case 2:
				var r = _g.e2;
				var l = _g.e1;
				var bo = _g.op;
				if(_gthis.spaceAroundBinop) {
					if(_gthis.ignoreRangeOperator && _gthis.binopString(bo) == "...") {
						return;
					}
					if(r.pos.min - l.pos.max < _gthis.binopSize(bo) + 2) {
						_gthis.logPos("No space around \"" + _gthis.binopString(bo) + "\"",e.pos);
					}
				}
				break;
			case 9:
				var e2 = _g.e;
				var post = _g.postFix;
				var uo = _g.op;
				if(_gthis.noSpaceAroundUnop) {
					var dist = 0;
					if(post) {
						dist = e.pos.max - e2.pos.max;
					} else {
						dist = e2.pos.min - e.pos.min;
					}
					if(dist > _gthis.unopSize(uo)) {
						_gthis.logPos("Space around \"" + _gthis.unopString(uo) + "\"",e.pos);
					}
				}
				break;
			default:
			}
			lastExpr = e;
		});
	}
	,checkSpaceBetweenExpressions: function(name,e1,e2,directive) {
		if(e2 == null) {
			return;
		}
		switch(directive) {
		case "any":
			break;
		case "should":
			if(e2.pos.max - e1.pos.max == 1) {
				this.logRange("No space between \"" + name + "\" and \"(\"",e1.pos.max,e2.pos.min);
			}
			break;
		case "should_not":
			if(e2.pos.max - e1.pos.max > 1) {
				this.logRange("Space between \"" + name + "\" and \"(\"",e2.pos.max,e2.pos.min);
			}
			break;
		}
	}
	,binopSize: function(bo) {
		return this.binopString(bo).length;
	}
	,binopString: function(bo) {
		return new haxe_macro_Printer().printBinop(bo);
	}
	,unopSize: function(uo) {
		return this.unopString(uo).length;
	}
	,unopString: function(uo) {
		return new haxe_macro_Printer().printUnop(uo);
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "spaceIfCondition", values : ["should","should_not","any"]},{ propertyName : "spaceForLoop", values : ["should","should_not","any"]},{ propertyName : "spaceWhileLoop", values : ["should","should_not","any"]},{ propertyName : "spaceWhileLoop", values : ["should","should_not","any"]},{ propertyName : "spaceSwitchCase", values : ["should","should_not","any"]},{ propertyName : "spaceCatch", values : ["should","should_not","any"]},{ propertyName : "ignoreRangeOperator", values : [true,false]},{ propertyName : "spaceAroundBinop", values : [true,false]},{ propertyName : "noSpaceAroundUnop", values : [true,false]}]}];
	}
	,__class__: checkstyle_checks_whitespace_SpacingCheck
});
var checkstyle_checks_whitespace_TabForAligningCheck = function() {
	checkstyle_checks_whitespace_LineCheckBase.call(this);
	this.severity = "IGNORE";
	this.ignorePattern = "^$";
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.whitespace.TabForAligningCheck"] = checkstyle_checks_whitespace_TabForAligningCheck;
checkstyle_checks_whitespace_TabForAligningCheck.__name__ = "checkstyle.checks.whitespace.TabForAligningCheck";
checkstyle_checks_whitespace_TabForAligningCheck.__super__ = checkstyle_checks_whitespace_LineCheckBase;
checkstyle_checks_whitespace_TabForAligningCheck.prototype = $extend(checkstyle_checks_whitespace_LineCheckBase.prototype,{
	ignorePattern: null
	,actualRun: function() {
		var ignoreRE = new EReg(this.ignorePattern,"");
		var _g = 0;
		var _g1 = this.checker.lines.length;
		while(_g < _g1) {
			var i = _g++;
			var line = this.checker.lines[i];
			var ranges = this.getRanges(line);
			if(ignoreRE.match(line)) {
				continue;
			}
			var _g2 = 0;
			var _g3 = [];
			var _g4 = 0;
			var _g5 = ranges;
			while(_g4 < _g5.length) {
				var v = _g5[_g4];
				++_g4;
				if(v.type == checkstyle_checks_whitespace_RangeType.TEXT) {
					_g3.push(v);
				}
			}
			var _g6 = _g3;
			while(_g2 < _g6.length) {
				var range = _g6[_g2];
				++_g2;
				var re = range.start == 0 ? new EReg("\\S[ ]*\t","") : new EReg("\t","");
				var rangeText = line.substring(range.start,range.end);
				if(re.match(rangeText)) {
					this.log("Tab after non-space character, use space for aligning",i + 1,0,i + 1,line.length);
				}
			}
		}
	}
	,__class__: checkstyle_checks_whitespace_TabForAligningCheck
});
var checkstyle_checks_whitespace_TrailingWhitespaceCheck = function() {
	checkstyle_checks_whitespace_LineCheckBase.call(this);
	this.severity = "IGNORE";
};
$hxClasses["checkstyle.checks.whitespace.TrailingWhitespaceCheck"] = checkstyle_checks_whitespace_TrailingWhitespaceCheck;
checkstyle_checks_whitespace_TrailingWhitespaceCheck.__name__ = "checkstyle.checks.whitespace.TrailingWhitespaceCheck";
checkstyle_checks_whitespace_TrailingWhitespaceCheck.__super__ = checkstyle_checks_whitespace_LineCheckBase;
checkstyle_checks_whitespace_TrailingWhitespaceCheck.prototype = $extend(checkstyle_checks_whitespace_LineCheckBase.prototype,{
	actualRun: function() {
		var re = new EReg("\\s+$","");
		var _g = 0;
		var _g1 = this.checker.lines.length;
		while(_g < _g1) {
			var i = _g++;
			var line = this.checker.lines[i];
			var ranges = this.getRanges(line);
			var _g2 = [];
			var _g3 = 0;
			var _g4 = ranges;
			while(_g3 < _g4.length) {
				var v = _g4[_g3];
				++_g3;
				if(v.type == checkstyle_checks_whitespace_RangeType.TEXT && v.end == line.length) {
					_g2.push(v);
				}
			}
			var endTextRange = _g2[0];
			if(endTextRange == null) {
				continue;
			}
			var endText = line.substring(endTextRange.start,endTextRange.end);
			if(re.match(endText)) {
				this.log("Trailing whitespace",i + 1,line.length,i + 1,line.length);
			}
		}
	}
	,detectableInstances: function() {
		return [{ fixed : [], properties : [{ propertyName : "severity", values : ["INFO"]}]}];
	}
	,__class__: checkstyle_checks_whitespace_TrailingWhitespaceCheck
});
var checkstyle_checks_whitespace_WhitespaceAfterCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.tokens = [",",";"];
	this.allowTrailingComma = false;
};
$hxClasses["checkstyle.checks.whitespace.WhitespaceAfterCheck"] = checkstyle_checks_whitespace_WhitespaceAfterCheck;
checkstyle_checks_whitespace_WhitespaceAfterCheck.__name__ = "checkstyle.checks.whitespace.WhitespaceAfterCheck";
checkstyle_checks_whitespace_WhitespaceAfterCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_whitespace_WhitespaceAfterCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	tokens: null
	,allowTrailingComma: null
	,hasToken: function(token) {
		if(this.tokens.length != 0) {
			return this.tokens.indexOf(token) != -1;
		} else {
			return true;
		}
	}
	,actualRun: function() {
		var tokenList = [];
		if(this.hasToken(",")) {
			tokenList.push(tokentree_TokenTreeDef.Comma);
		}
		if(this.hasToken(";")) {
			tokenList.push(tokentree_TokenTreeDef.Semicolon);
		}
		if(this.hasToken("(")) {
			tokenList.push(tokentree_TokenTreeDef.POpen);
		}
		if(this.hasToken("[")) {
			tokenList.push(tokentree_TokenTreeDef.BkOpen);
		}
		if(this.hasToken("{")) {
			tokenList.push(tokentree_TokenTreeDef.BrOpen);
		}
		if(this.hasToken(":")) {
			tokenList.push(tokentree_TokenTreeDef.DblDot);
		}
		if(this.hasToken(".")) {
			tokenList.push(tokentree_TokenTreeDef.Dot);
		}
		if(this.hasToken("=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		}
		if(this.hasToken("+")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAdd));
		}
		if(this.hasToken("-")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpSub));
		}
		if(this.hasToken("*")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpMult));
		}
		if(this.hasToken("/")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpDiv));
		}
		if(this.hasToken("%")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpMod));
		}
		if(this.hasToken(">")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		}
		if(this.hasToken("<")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt));
		}
		if(this.hasToken(">=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGte));
		}
		if(this.hasToken("<=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLte));
		}
		if(this.hasToken("==")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpEq));
		}
		if(this.hasToken("!=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpNotEq));
		}
		if(this.hasToken("&")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd));
		}
		if(this.hasToken("|")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpOr));
		}
		if(this.hasToken("^")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpXor));
		}
		if(this.hasToken("&&")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpBoolAnd));
		}
		if(this.hasToken("||")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpBoolOr));
		}
		if(this.hasToken("<<")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShl));
		}
		if(this.hasToken(">>")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr));
		}
		if(this.hasToken(">>>")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpUShr));
		}
		if(this.hasToken("+=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd)));
		}
		if(this.hasToken("-=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpSub)));
		}
		if(this.hasToken("*=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult)));
		}
		if(this.hasToken("/=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpDiv)));
		}
		if(this.hasToken("%=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMod)));
		}
		if(this.hasToken("<<=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShl)));
		}
		if(this.hasToken(">>=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr)));
		}
		if(this.hasToken(">>>=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr)));
		}
		if(this.hasToken("|=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpOr)));
		}
		if(this.hasToken("&=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAnd)));
		}
		if(this.hasToken("^=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpXor)));
		}
		if(this.hasToken("...")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpInterval));
		}
		if(this.hasToken("=>")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpArrow));
		}
		if(this.hasToken("!")) {
			tokenList.push(tokentree_TokenTreeDef.Unop(haxe_macro_Unop.OpNot));
		}
		if(this.hasToken("++")) {
			tokenList.push(tokentree_TokenTreeDef.Unop(haxe_macro_Unop.OpIncrement));
		}
		if(this.hasToken("--")) {
			tokenList.push(tokentree_TokenTreeDef.Unop(haxe_macro_Unop.OpDecrement));
		}
		if(tokenList.length <= 0) {
			return;
		}
		this.checkTokens(tokenList);
	}
	,checkTokens: function(tokenList) {
		var root = this.checker.getTokenTree();
		var allTokens = root.filterCallback(function(token,depth) {
			if(token.matchesAny(tokenList)) {
				return tokentree_FilterResult.FoundGoDeeper;
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < allTokens.length) {
			var tok = allTokens[_g];
			++_g;
			if(this.isPosSuppressed(tok.pos)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.filterOpSub(tok)) {
				continue;
			}
			var contentAfter = this.checker.getString(tok.pos.max,tok.pos.max + 1);
			if(new EReg("^(\\s|)$","").match(contentAfter)) {
				continue;
			}
			if(this.allowTrailingComma) {
				if(tok.tok._hx_index == 14) {
					switch(contentAfter) {
					case ")":case "]":case "}":
						continue;
					default:
					}
				}
			}
			this.logPos("No whitespace after \"" + Std.string(tok) + "\"",tok.pos);
		}
	}
	,__class__: checkstyle_checks_whitespace_WhitespaceAfterCheck
});
var checkstyle_checks_whitespace_WhitespaceAroundCheck = function() {
	checkstyle_checks_Check.call(this,checkstyle_checks_CheckType.TOKEN);
	this.tokens = ["=","+","-","*","/","%",">","<",">=","<=","==","!=","&","|","^","&&","||","<<",">>",">>>","+=","-=","*=","/=","%=","<<=",">>=",">>>=","|=","&=","^=","=>"];
	this.categories = ["Style","Clarity"];
};
$hxClasses["checkstyle.checks.whitespace.WhitespaceAroundCheck"] = checkstyle_checks_whitespace_WhitespaceAroundCheck;
checkstyle_checks_whitespace_WhitespaceAroundCheck.__name__ = "checkstyle.checks.whitespace.WhitespaceAroundCheck";
checkstyle_checks_whitespace_WhitespaceAroundCheck.__super__ = checkstyle_checks_Check;
checkstyle_checks_whitespace_WhitespaceAroundCheck.prototype = $extend(checkstyle_checks_Check.prototype,{
	tokens: null
	,hasToken: function(token) {
		if(this.tokens.length != 0) {
			return this.tokens.indexOf(token) != -1;
		} else {
			return true;
		}
	}
	,actualRun: function() {
		var tokenList = [];
		if(this.hasToken(",")) {
			tokenList.push(tokentree_TokenTreeDef.Comma);
		}
		if(this.hasToken(";")) {
			tokenList.push(tokentree_TokenTreeDef.Semicolon);
		}
		if(this.hasToken("(")) {
			tokenList.push(tokentree_TokenTreeDef.POpen);
		}
		if(this.hasToken(")")) {
			tokenList.push(tokentree_TokenTreeDef.PClose);
		}
		if(this.hasToken("[")) {
			tokenList.push(tokentree_TokenTreeDef.BkOpen);
		}
		if(this.hasToken("]")) {
			tokenList.push(tokentree_TokenTreeDef.BkClose);
		}
		if(this.hasToken("{")) {
			tokenList.push(tokentree_TokenTreeDef.BrOpen);
		}
		if(this.hasToken("}")) {
			tokenList.push(tokentree_TokenTreeDef.BrClose);
		}
		if(this.hasToken(":")) {
			tokenList.push(tokentree_TokenTreeDef.DblDot);
		}
		if(this.hasToken(".")) {
			tokenList.push(tokentree_TokenTreeDef.Dot);
		}
		if(this.hasToken("=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		}
		if(this.hasToken("+")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAdd));
		}
		if(this.hasToken("-")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpSub));
		}
		if(this.hasToken("*")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpMult));
		}
		if(this.hasToken("/")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpDiv));
		}
		if(this.hasToken("%")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpMod));
		}
		if(this.hasToken(">")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		}
		if(this.hasToken("<")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt));
		}
		if(this.hasToken(">=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGte));
		}
		if(this.hasToken("<=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLte));
		}
		if(this.hasToken("==")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpEq));
		}
		if(this.hasToken("!=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpNotEq));
		}
		if(this.hasToken("&")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd));
		}
		if(this.hasToken("|")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpOr));
		}
		if(this.hasToken("^")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpXor));
		}
		if(this.hasToken("&&")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpBoolAnd));
		}
		if(this.hasToken("||")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpBoolOr));
		}
		if(this.hasToken("<<")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShl));
		}
		if(this.hasToken(">>")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr));
		}
		if(this.hasToken(">>>")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpUShr));
		}
		if(this.hasToken("+=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd)));
		}
		if(this.hasToken("-=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpSub)));
		}
		if(this.hasToken("*=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult)));
		}
		if(this.hasToken("/=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpDiv)));
		}
		if(this.hasToken("%=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMod)));
		}
		if(this.hasToken("<<=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShl)));
		}
		if(this.hasToken(">>=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr)));
		}
		if(this.hasToken(">>>=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr)));
		}
		if(this.hasToken("|=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpOr)));
		}
		if(this.hasToken("&=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAnd)));
		}
		if(this.hasToken("^=")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpXor)));
		}
		if(this.hasToken("...")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpInterval));
		}
		if(this.hasToken("=>")) {
			tokenList.push(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpArrow));
		}
		if(this.hasToken("!")) {
			tokenList.push(tokentree_TokenTreeDef.Unop(haxe_macro_Unop.OpNot));
		}
		if(this.hasToken("++")) {
			tokenList.push(tokentree_TokenTreeDef.Unop(haxe_macro_Unop.OpIncrement));
		}
		if(this.hasToken("--")) {
			tokenList.push(tokentree_TokenTreeDef.Unop(haxe_macro_Unop.OpDecrement));
		}
		if(tokenList.length <= 0) {
			return;
		}
		this.checkTokens(tokenList);
	}
	,checkTokens: function(tokenList) {
		var root = this.checker.getTokenTree();
		var allTokens = root.filterCallback(function(token,depth) {
			if(token.matchesAny(tokenList)) {
				return tokentree_FilterResult.FoundGoDeeper;
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < allTokens.length) {
			var tok = allTokens[_g];
			++_g;
			if(this.isPosSuppressed(tok.pos)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(tok)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.isImportMult(tok)) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.filterOpSub(tok)) {
				continue;
			}
			var linePos = this.checker.getLinePos(tok.pos.min);
			var line = haxe_io_Bytes.ofString(this.checker.lines[linePos.line]);
			var before = line.sub(0,linePos.ofs).toString();
			var tokLen = tok.toString().length;
			var offs = linePos.ofs + tokLen;
			var after = line.sub(offs,line.length - offs).toString();
			if(!new EReg("^.*\\s$","").match(before)) {
				this.logPos("No whitespace around \"" + Std.string(tok) + "\"",tok.pos);
				continue;
			}
			if(!new EReg("^(\\s.*|)$","").match(after)) {
				this.logPos("No whitespace around \"" + Std.string(tok) + "\"",tok.pos);
				continue;
			}
		}
	}
	,__class__: checkstyle_checks_whitespace_WhitespaceAroundCheck
});
var checkstyle_config_ConfigParser = function(failCallback) {
	this.info = new checkstyle_ChecksInfo();
	this.checker = new checkstyle_Checker();
	this.failWithCallback = failCallback;
	this.paths = [];
	this.allExcludes = [];
	this.seenConfigPaths = [];
	this.excludesMap = new haxe_ds_StringMap();
	this.numberOfCheckerThreads = 5;
	this.overrideCheckerThreads = 0;
	this.validateMode = checkstyle_config_ConfigValidateMode.STRICT;
};
$hxClasses["checkstyle.config.ConfigParser"] = checkstyle_config_ConfigParser;
checkstyle_config_ConfigParser.__name__ = "checkstyle.config.ConfigParser";
checkstyle_config_ConfigParser.prototype = {
	paths: null
	,excludesMap: null
	,allExcludes: null
	,numberOfCheckerThreads: null
	,overrideCheckerThreads: null
	,info: null
	,checker: null
	,validateMode: null
	,seenConfigPaths: null
	,failWithCallback: null
	,loadConfig: function(path) {
		path = this.getAbsoluteConfigPath(path,process.cwd());
		if(path != null && sys_FileSystem.exists(path) && !sys_FileSystem.isDirectory(path)) {
			this.seenConfigPaths.push(path);
			this.parseAndValidateConfig(JSON.parse(js_node_Fs.readFileSync(path,{ encoding : "utf8"})),haxe_io_Path.directory(path));
		} else {
			this.addAllChecks();
		}
	}
	,getAbsoluteConfigPath: function(path,baseFolder) {
		if(path == null) {
			return null;
		}
		if(haxe_io_Path.isAbsolute(path)) {
			return path;
		}
		return haxe_io_Path.join([baseFolder,path]);
	}
	,parseAndValidateConfig: function(config,rootFolder) {
		this.validateAllowedFields(config,Reflect.fields(checkstyle_utils_ConfigUtils.getEmptyConfig()),"Config");
		if(config.version == null) {
			config.version = 1;
		}
		if(config.version != 1) {
			this.failWith("configuration file has unknown version: " + config.version);
		}
		if(!checkstyle_utils_StringUtils.isEmpty(config.extendsConfigPath)) {
			var path = this.getAbsoluteConfigPath(config.extendsConfigPath,rootFolder);
			if(this.seenConfigPaths.indexOf(path) != -1) {
				this.failWith("extendsConfig: config file loop detected!");
			}
			this.seenConfigPaths.push(path);
			if(sys_FileSystem.exists(path) && !sys_FileSystem.isDirectory(path)) {
				this.parseAndValidateConfig(JSON.parse(js_node_Fs.readFileSync(path,{ encoding : "utf8"})),haxe_io_Path.directory(path));
			} else {
				this.failWith("extendsConfig: Failed to load parent configuration file [" + config.extendsConfigPath + "]");
			}
		}
		if(config.exclude != null) {
			this.parseExcludes(config.exclude);
		}
		if(config.checks != null) {
			var _g = 0;
			var _g1 = config.checks;
			while(_g < _g1.length) {
				var checkConf = _g1[_g];
				++_g;
				var check = this.createCheck(checkConf);
				if(check != null) {
					this.setCheckProperties(check,checkConf,config.defaultSeverity);
				}
			}
		}
		if(config.baseDefines != null) {
			this.validateDefines(config.baseDefines);
			this.checker.baseDefines = config.baseDefines;
		}
		if(config.defineCombinations != null) {
			var _g = 0;
			var _g1 = config.defineCombinations;
			while(_g < _g1.length) {
				var combination = _g1[_g];
				++_g;
				this.validateDefines(combination);
			}
			this.checker.defineCombinations = config.defineCombinations;
		}
		this.validateCheckerThreads(config.numberOfCheckerThreads);
	}
	,loadExcludeConfig: function(path) {
		var config = JSON.parse(js_node_Fs.readFileSync(path,{ encoding : "utf8"}));
		this.parseExcludes(config);
	}
	,parseExcludes: function(config) {
		if(config.version == null) {
			config.version = 1;
		}
		if(config.version != 1) {
			this.failWith("exclude configuration file has unknown version: " + config.version);
		}
		var pathType = config.path;
		var excludes = Reflect.fields(config);
		var _g = 0;
		while(_g < excludes.length) {
			var exclude = excludes[_g];
			++_g;
			if(exclude == "path") {
				continue;
			}
			if(exclude == "version") {
				continue;
			}
			this.createExcludeMapElement(exclude);
			var excludeValues = Reflect.field(config,exclude);
			if(excludeValues == null || excludeValues.length == 0) {
				continue;
			}
			var _g1 = 0;
			while(_g1 < excludeValues.length) {
				var val = excludeValues[_g1];
				++_g1;
				this.updateExcludes(exclude,val,pathType);
			}
		}
	}
	,createExcludeMapElement: function(exclude) {
		if(this.excludesMap.h[exclude] == null) {
			this.excludesMap.h[exclude] = [];
		}
	}
	,updateExcludes: function(exclude,val,pathType) {
		var range = null;
		var index = val.lastIndexOf(":");
		if(index > 0) {
			range = HxOverrides.substr(val,index + 1,null);
			val = HxOverrides.substr(val,0,index);
		}
		if(pathType == null || pathType == "") {
			this.addNormalisedPathToExclude(exclude,val,range);
			return;
		}
		switch(pathType) {
		case "RELATIVE_TO_PROJECT":
			this.addNormalisedPathToExclude(exclude,val,range);
			break;
		case "RELATIVE_TO_SOURCE":
			var _g = 0;
			var _g1 = this.paths;
			while(_g < _g1.length) {
				var path = _g1[_g];
				++_g;
				this.addNormalisedPathToExclude(exclude,path + ":" + val,range);
			}
			break;
		}
	}
	,addNormalisedPathToExclude: function(exclude,path,range) {
		var path1 = this.normalisePath(path);
		this.addToExclude(exclude,path1,range);
	}
	,normalisePath: function(path) {
		var slashes_r = new RegExp("[/\\\\]","g".split("u").join(""));
		path = path.split(".").join(":");
		path = path.replace(slashes_r,":");
		return path;
	}
	,addToExclude: function(exclude,value,range) {
		if(exclude == "all") {
			checkstyle_config_ExcludeManager.addGlobalExclude(value,range);
		} else {
			checkstyle_config_ExcludeManager.addConfigExclude(exclude,value,range);
		}
	}
	,createCheck: function(checkConf) {
		var check = this.info.build(checkConf.type);
		if(check == null) {
			switch(this.validateMode._hx_index) {
			case 0:
				this.failWith("Unknown check \"" + checkConf.type + "\"");
				break;
			case 1:
				break;
			}
			return null;
		}
		this.checker.addCheck(check);
		return check;
	}
	,setCheckProperties: function(check,checkConf,defaultSeverity) {
		this.validateAllowedFields(checkConf,["type","props"],check.getModuleName());
		var props = checkConf.props == null ? [] : Reflect.fields(checkConf.props);
		var checkFields = Type.getInstanceFields(js_Boot.getClass(check));
		var _g = 0;
		while(_g < props.length) {
			var prop = props[_g];
			++_g;
			var val = Reflect.field(checkConf.props,prop);
			if(checkFields.indexOf(prop) == -1) {
				this.failWith("Check " + check.getModuleName() + " has no property named '" + prop + "'");
				continue;
			}
			try {
				check.configureProperty(prop,val);
			} catch( _g1 ) {
				haxe_NativeStackTrace.lastError = _g1;
				var e = haxe_Exception.caught(_g1).unwrap();
				var message = "Failed to configure " + prop + " setting for " + check.getModuleName() + ": ";
				message += ((e) instanceof checkstyle_errors_Error) ? e.message : Std.string(e);
				this.failWith(message);
			}
		}
		if(defaultSeverity != null && props.indexOf("severity") == -1) {
			check.severity = defaultSeverity;
		}
	}
	,validateAllowedFields: function(object,allowedFields,messagePrefix) {
		var _g = 0;
		var _g1 = Reflect.fields(object);
		while(_g < _g1.length) {
			var field = _g1[_g];
			++_g;
			if(allowedFields.indexOf(field) == -1) {
				this.failWith(messagePrefix + " has unknown field '" + field + "'");
			}
		}
	}
	,validateDefines: function(defines) {
		var _g = 0;
		while(_g < defines.length) {
			var define = defines[_g];
			++_g;
			if(define.split("=").length > 2) {
				this.failWith("Found a define with more than one = sign: '" + define + "'");
			}
		}
	}
	,validateCheckerThreads: function(checkerThreads) {
		if(checkerThreads != null) {
			this.numberOfCheckerThreads = checkerThreads;
		}
		if(this.overrideCheckerThreads > 0) {
			this.numberOfCheckerThreads = this.overrideCheckerThreads;
		}
		if(this.numberOfCheckerThreads <= 0) {
			this.numberOfCheckerThreads = 5;
		}
		if(this.numberOfCheckerThreads > 15) {
			this.numberOfCheckerThreads = 15;
		}
	}
	,addAllChecks: function() {
		var _g = 0;
		var _g1 = this.getSortedCheckInfos();
		while(_g < _g1.length) {
			var check = _g1[_g];
			++_g;
			if(!check.isAlias) {
				this.checker.addCheck(this.info.build(check.name));
			}
		}
	}
	,getSortedCheckInfos: function() {
		var _g = [];
		var check = this.info.checks();
		while(check.hasNext()) {
			var check1 = check.next();
			_g.push(check1);
		}
		var checks = _g;
		checks.sort(checkstyle_utils_ConfigUtils.checkInfoSort);
		return checks;
	}
	,getCheckCount: function() {
		var count = 0;
		var check = this.info.checks();
		while(check.hasNext()) {
			var check1 = check.next();
			if(new EReg("\\[DEPRECATED","").match(check1.description)) {
				continue;
			}
			++count;
		}
		return count;
	}
	,getUsedCheckCount: function() {
		var count = 0;
		var list = [];
		var _g = 0;
		var _g1 = this.checker.checks;
		while(_g < _g1.length) {
			var check = _g1[_g];
			++_g;
			var c = js_Boot.getClass(check);
			var name = c.__name__;
			if(list.indexOf(name) >= 0) {
				continue;
			}
			list.push(name);
			++count;
		}
		return count;
	}
	,failWith: function(msg) {
		switch(this.validateMode._hx_index) {
		case 0:
			this.failWithCallback(msg);
			break;
		case 1:
			break;
		}
	}
	,__class__: checkstyle_config_ConfigParser
};
var checkstyle_config_ConfigValidateMode = $hxEnums["checkstyle.config.ConfigValidateMode"] = { __ename__ : true, __constructs__ : ["STRICT","RELAXED"]
	,STRICT: {_hx_index:0,__enum__:"checkstyle.config.ConfigValidateMode",toString:$estr}
	,RELAXED: {_hx_index:1,__enum__:"checkstyle.config.ConfigValidateMode",toString:$estr}
};
var checkstyle_config_ExcludeDefinition = $hxEnums["checkstyle.config.ExcludeDefinition"] = { __ename__ : true, __constructs__ : ["FULL","LINE","RANGE","IDENTIFIER"]
	,FULL: ($_=function(filter) { return {_hx_index:0,filter:filter,__enum__:"checkstyle.config.ExcludeDefinition",toString:$estr}; },$_.__params__ = ["filter"],$_)
	,LINE: ($_=function(filter,line) { return {_hx_index:1,filter:filter,line:line,__enum__:"checkstyle.config.ExcludeDefinition",toString:$estr}; },$_.__params__ = ["filter","line"],$_)
	,RANGE: ($_=function(filter,lineStart,lineEnd) { return {_hx_index:2,filter:filter,lineStart:lineStart,lineEnd:lineEnd,__enum__:"checkstyle.config.ExcludeDefinition",toString:$estr}; },$_.__params__ = ["filter","lineStart","lineEnd"],$_)
	,IDENTIFIER: ($_=function(filter,name) { return {_hx_index:3,filter:filter,name:name,__enum__:"checkstyle.config.ExcludeDefinition",toString:$estr}; },$_.__params__ = ["filter","name"],$_)
};
var checkstyle_config_ExcludeManager = function() {
	this.clear();
};
$hxClasses["checkstyle.config.ExcludeManager"] = checkstyle_config_ExcludeManager;
checkstyle_config_ExcludeManager.__name__ = "checkstyle.config.ExcludeManager";
checkstyle_config_ExcludeManager.addGlobalExclude = function(filter,range) {
	checkstyle_config_ExcludeManager.INSTANCE.globalExclude.push(checkstyle_config_ExcludeManager.createExcludeDefinition(filter,range));
};
checkstyle_config_ExcludeManager.addConfigExclude = function(checkName,filter,range) {
	var list = checkstyle_config_ExcludeManager.INSTANCE.excludeMap.h[checkName];
	if(list == null) {
		list = [];
	}
	list.push(checkstyle_config_ExcludeManager.createExcludeDefinition(filter,range));
	checkstyle_config_ExcludeManager.INSTANCE.excludeMap.h[checkName] = list;
};
checkstyle_config_ExcludeManager.createExcludeDefinition = function(filter,range) {
	if(range == null || range == "") {
		return checkstyle_config_ExcludeDefinition.FULL(filter);
	}
	if(new EReg("^[1-9][0-9]*$","").match(range)) {
		return checkstyle_config_ExcludeDefinition.LINE(filter,Std.parseInt(range));
	}
	if(new EReg("^[1-9][0-9]*-[1-9][0-9]*$","").match(range)) {
		var parts = range.split("-");
		return checkstyle_config_ExcludeDefinition.RANGE(filter,Std.parseInt(parts[0]),Std.parseInt(parts[1]));
	}
	return checkstyle_config_ExcludeDefinition.IDENTIFIER(filter,range);
};
checkstyle_config_ExcludeManager.isExcludedFromAll = function(fileName) {
	return checkstyle_config_ExcludeManager.INSTANCE.checkFileExcluded(fileName,checkstyle_config_ExcludeManager.INSTANCE.globalExclude);
};
checkstyle_config_ExcludeManager.isExcludedFromCheck = function(fileName,checkName) {
	return checkstyle_config_ExcludeManager.INSTANCE.checkFileExcluded(fileName,checkstyle_config_ExcludeManager.INSTANCE.excludeMap.h[checkName]);
};
checkstyle_config_ExcludeManager.prototype = {
	globalExclude: null
	,excludeMap: null
	,clear: function() {
		this.globalExclude = [];
		this.excludeMap = new haxe_ds_StringMap();
	}
	,checkFileExcluded: function(fileName,list) {
		if(list == null) {
			return false;
		}
		var _g = 0;
		while(_g < list.length) {
			var exclude = list[_g];
			++_g;
			if(this.matchFullExlude(fileName,exclude)) {
				return true;
			}
		}
		return false;
	}
	,matchFullExlude: function(fileName,exclude) {
		switch(exclude._hx_index) {
		case 0:
			var filter = exclude.filter;
			return this.filterFileName(fileName,filter);
		case 1:
			var line = exclude.line;
			var filter = exclude.filter;
			return false;
		case 2:
			var lineEnd = exclude.lineEnd;
			var lineStart = exclude.lineStart;
			var filter = exclude.filter;
			return false;
		case 3:
			var name = exclude.name;
			var filter = exclude.filter;
			return false;
		}
	}
	,filterFileName: function(fileName,filter) {
		var cls = fileName.substring(0,fileName.indexOf(".hx"));
		if(filter == cls) {
			return true;
		}
		var slashes_r = new RegExp("[/\\\\]","g".split("u").join(""));
		cls = cls.replace(slashes_r,":");
		var r = new EReg(filter,"i");
		return r.match(cls);
	}
	,getPosExcludes: function(checker) {
		var posExcludes = this.getGlobalPosExcludes(checker);
		var checkName = haxe_ds_StringMap.keysIterator(this.excludeMap.h);
		while(checkName.hasNext()) {
			var checkName1 = checkName.next();
			var list = this.excludeMap.h[checkName1];
			if(list != null) {
				var _g = 0;
				while(_g < list.length) {
					var exclude = list[_g];
					++_g;
					switch(exclude._hx_index) {
					case 0:
						var filter = exclude.filter;
						continue;
					case 1:
						var line = exclude.line;
						var filter1 = exclude.filter;
						if(!this.filterFileName(checker.file.name,filter1)) {
							continue;
						}
						posExcludes.push(this.makeLinesExcludeRange(checker,checkName1,line - 1,line));
						break;
					case 2:
						var lineEnd = exclude.lineEnd;
						var lineStart = exclude.lineStart;
						var filter2 = exclude.filter;
						if(!this.filterFileName(checker.file.name,filter2)) {
							continue;
						}
						posExcludes.push(this.makeLinesExcludeRange(checker,checkName1,lineStart - 1,lineEnd - 1));
						break;
					case 3:
						var name = exclude.name;
						var filter3 = exclude.filter;
						if(!this.filterFileName(checker.file.name,filter3)) {
							continue;
						}
						posExcludes = posExcludes.concat(this.makeIdentifierRange(checker,checkName1,name));
						break;
					}
				}
			}
		}
		return this.makeExcludeRangMap(posExcludes.concat(this.getInlineExcludes(checker)));
	}
	,getGlobalPosExcludes: function(checker) {
		var posExcludes = [];
		var _g = 0;
		var _g1 = this.globalExclude;
		while(_g < _g1.length) {
			var exclude = _g1[_g];
			++_g;
			switch(exclude._hx_index) {
			case 0:
				var filter = exclude.filter;
				continue;
			case 1:
				var line = exclude.line;
				var filter1 = exclude.filter;
				if(!this.filterFileName(checker.file.name,filter1)) {
					continue;
				}
				var _g2 = 0;
				var _g3 = checker.checks;
				while(_g2 < _g3.length) {
					var check = _g3[_g2];
					++_g2;
					posExcludes.push(this.makeLinesExcludeRange(checker,check.getModuleName(),line - 1,line));
				}
				break;
			case 2:
				var lineEnd = exclude.lineEnd;
				var lineStart = exclude.lineStart;
				var filter2 = exclude.filter;
				if(!this.filterFileName(checker.file.name,filter2)) {
					continue;
				}
				var _g4 = 0;
				var _g5 = checker.checks;
				while(_g4 < _g5.length) {
					var check1 = _g5[_g4];
					++_g4;
					posExcludes.push(this.makeLinesExcludeRange(checker,check1.getModuleName(),lineStart - 1,lineEnd - 1));
				}
				break;
			case 3:
				var name = exclude.name;
				var filter3 = exclude.filter;
				if(!this.filterFileName(checker.file.name,filter3)) {
					continue;
				}
				var _g6 = 0;
				var _g7 = checker.checks;
				while(_g6 < _g7.length) {
					var check2 = _g7[_g6];
					++_g6;
					posExcludes = posExcludes.concat(this.makeIdentifierRange(checker,check2.getModuleName(),name));
				}
				break;
			}
		}
		return posExcludes;
	}
	,getInlineExcludes: function(checker) {
		var inlineExcludes = [];
		var root = checker.getTokenTree();
		var allAtTokens = root.filterCallback(function(token,depth) {
			if(token.tok._hx_index == 22) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allAtTokens.length) {
			var atToken = allAtTokens[_g];
			++_g;
			var child = atToken.getFirstChild();
			if(child == null) {
				continue;
			}
			if(!child.matches(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent("SuppressWarnings")))) {
				continue;
			}
			var pOpen = child.getFirstChild();
			if(pOpen == null) {
				continue;
			}
			if(!pOpen.matches(tokentree_TokenTreeDef.POpen)) {
				continue;
			}
			var checkNames = [[]];
			pOpen.filterCallback((function(checkNames) {
				return function(token,depth) {
					var _g = token.tok;
					if(_g._hx_index == 2) {
						var _g1 = _g.c;
						if(_g1._hx_index == 2) {
							var _g = _g1.kind;
							var name = _g1.s;
							if(!StringTools.startsWith(name,"checkstyle:")) {
								return tokentree_FilterResult.SkipSubtree;
							}
							checkNames[0].push(HxOverrides.substr(name,11,null));
							return tokentree_FilterResult.SkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				};
			})(checkNames));
			var _g1 = 0;
			while(_g1 < checkNames[0].length) {
				var name = checkNames[0][_g1];
				++_g1;
				inlineExcludes.push(this.makeTokenExcludeRange(checker,name,atToken.parent));
			}
		}
		return inlineExcludes;
	}
	,makeExcludeRangMap: function(list) {
		var map = new haxe_ds_StringMap();
		var _g = 0;
		while(_g < list.length) {
			var range = list[_g];
			++_g;
			var rangeList = map.h[range.checkName];
			if(rangeList == null) {
				rangeList = [];
			}
			rangeList.push(range);
			map.h[range.checkName] = rangeList;
		}
		return map;
	}
	,makeIdentifierRange: function(checker,checkName,name) {
		var identifierExcludes = [];
		var root = checker.getTokenTree();
		var filterTokens = [tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent(name))];
		if(name == "new") {
			filterTokens.push(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew));
		}
		var allTokens = root.filterCallback(function(token,depth) {
			if(token.matchesAny(filterTokens)) {
				return tokentree_FilterResult.FoundGoDeeper;
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < allTokens.length) {
			var token = allTokens[_g];
			++_g;
			identifierExcludes.push(this.makeTokenExcludeRange(checker,checkName,token));
		}
		return identifierExcludes;
	}
	,makeLinesExcludeRange: function(checker,checkName,lineStart,lineEnd) {
		if(lineStart < 0) {
			lineStart = 0;
		}
		if(lineEnd < 0) {
			lineEnd = lineStart;
		}
		if(lineStart > checker.lines.length) {
			lineStart = checker.lines.length - 1;
		}
		if(lineEnd > checker.lines.length) {
			lineEnd = checker.lines.length - 1;
		}
		return { checkName : checkName, linePosStart : { line : lineStart, ofs : 0}, linePosEnd : { line : lineEnd, ofs : 0}, charPosStart : checker.linesIdx[lineStart].l, charPosEnd : checker.linesIdx[lineEnd].r};
	}
	,makeTokenExcludeRange: function(checker,checkName,token) {
		var pos = token.getPos();
		return { checkName : checkName, linePosStart : checker.getLinePos(pos.min), linePosEnd : checker.getLinePos(pos.max), charPosStart : pos.min, charPosEnd : pos.max};
	}
	,__class__: checkstyle_config_ExcludeManager
};
var checkstyle_detect_DetectCodingStyle = function() { };
$hxClasses["checkstyle.detect.DetectCodingStyle"] = checkstyle_detect_DetectCodingStyle;
checkstyle_detect_DetectCodingStyle.__name__ = "checkstyle.detect.DetectCodingStyle";
checkstyle_detect_DetectCodingStyle.detectCodingStyle = function(checks,fileList) {
	var detectedChecks = [];
	haxe_ds_ArraySort.sort(checks,checkstyle_utils_ConfigUtils.checkSort);
	var _g = 0;
	while(_g < checks.length) {
		var check = checks[_g];
		++_g;
		checkstyle_detect_DetectCodingStyle.detectCheck(check,detectedChecks,fileList);
	}
	return detectedChecks;
};
checkstyle_detect_DetectCodingStyle.detectCheck = function(check,detectedChecks,fileList) {
	var detectableInstances = check.detectableInstances();
	if(detectableInstances.length <= 0) {
		return;
	}
	checkstyle_detect_DetectCodingStyle.printProgress(check.getModuleName() + ": ");
	if(check.severity == "IGNORE") {
		check.severity = "INFO";
	}
	var _g = 0;
	while(_g < detectableInstances.length) {
		var instance = detectableInstances[_g];
		++_g;
		var _g1 = 0;
		var _g2 = instance.fixed;
		while(_g1 < _g2.length) {
			var fixedProp = _g2[_g1];
			++_g1;
			check.configureProperty(fixedProp.propertyName,fixedProp.value);
		}
		var checkConfig = checkstyle_detect_DetectCodingStyle.detectPropertyIterations(check,instance.properties,fileList);
		if(checkConfig != null) {
			detectedChecks.push(checkConfig);
		}
	}
};
checkstyle_detect_DetectCodingStyle.detectPropertyIterations = function(check,detectableProperties,fileList) {
	var ignored = true;
	var _g = 0;
	while(_g < detectableProperties.length) {
		var property = detectableProperties[_g];
		++_g;
		check.reset();
		if(checkstyle_detect_DetectCodingStyle.detectInFiles(check,property,fileList)) {
			ignored = false;
		}
	}
	if(ignored) {
		checkstyle_detect_DetectCodingStyle.printProgress(" ignored",true);
		return null;
	} else {
		checkstyle_detect_DetectCodingStyle.printProgress(" ok",true);
		return checkstyle_utils_ConfigUtils.makeCheckConfig(check);
	}
};
checkstyle_detect_DetectCodingStyle.detectInFiles = function(check,property,fileList) {
	var detectedValue = null;
	var _g = 0;
	while(_g < fileList.length) {
		var file = fileList[_g];
		++_g;
		var result = checkstyle_detect_DetectCodingStyle.iterateProperty(check,property,file);
		switch(result._hx_index) {
		case 0:
			break;
		case 1:
			var value = result.value;
			check.configureProperty(property.propertyName,value);
			return true;
		case 2:
			var value1 = result.value;
			detectedValue = value1;
			break;
		}
	}
	if(detectedValue != null) {
		check.configureProperty(property.propertyName,detectedValue);
		return true;
	}
	return false;
};
checkstyle_detect_DetectCodingStyle.iterateProperty = function(check,property,file) {
	if(property.values.length <= 0) {
		return checkstyle_detect_DetectionResult.NO_CHANGE;
	}
	if(property.values.length == 1) {
		return checkstyle_detect_DetectionResult.CHANGE_DETECTED(property.values[0]);
	}
	var checker = new checkstyle_Checker();
	checker.addCheck(check);
	checker.loadFileContent(file);
	if(!checker.createContext(file)) {
		return checkstyle_detect_DetectionResult.NO_CHANGE;
	}
	var lastCount = -1;
	var lowestCountValue = null;
	var changed = false;
	var _g = 0;
	var _g1 = property.values;
	while(_g < _g1.length) {
		var value = _g1[_g];
		++_g;
		check.configureProperty(property.propertyName,value);
		var count = checkstyle_detect_DetectCodingStyle.runCheck(checker,[file]);
		if(lastCount == -1) {
			lastCount = count;
			lowestCountValue = value;
			continue;
		}
		if(count == lastCount) {
			continue;
		}
		checkstyle_detect_DetectCodingStyle.printProgress(".");
		if(count < lastCount) {
			lastCount = count;
			lowestCountValue = value;
		}
		changed = true;
	}
	if(changed) {
		var index = property.values.indexOf(lowestCountValue);
		if(index <= 0) {
			return checkstyle_detect_DetectionResult.CHANGE_DETECTED(lowestCountValue);
		}
		property.values = property.values.slice(index);
		if(property.values.length > 2) {
			return checkstyle_detect_DetectionResult.REDUCED_VALUE_LIST(lowestCountValue);
		}
		return checkstyle_detect_DetectionResult.CHANGE_DETECTED(lowestCountValue);
	}
	return checkstyle_detect_DetectionResult.NO_CHANGE;
};
checkstyle_detect_DetectCodingStyle.runCheck = function(checker,fileList) {
	checkstyle_reporter_ReporterManager.INSTANCE.clear();
	var reporter = new checkstyle_detect_DetectionReporter();
	checkstyle_reporter_ReporterManager.INSTANCE.addReporter(reporter);
	checker.run();
	return reporter.messageCount;
};
checkstyle_detect_DetectCodingStyle.printProgress = function(text,nl) {
	if(nl == null) {
		nl = false;
	}
	if(nl) {
		process.stdout.write(Std.string(text));
		process.stdout.write("\n");
	} else {
		process.stdout.write(Std.string(text));
	}
};
var checkstyle_reporter_IReporter = function() { };
$hxClasses["checkstyle.reporter.IReporter"] = checkstyle_reporter_IReporter;
checkstyle_reporter_IReporter.__name__ = "checkstyle.reporter.IReporter";
checkstyle_reporter_IReporter.__isInterface__ = true;
checkstyle_reporter_IReporter.prototype = {
	start: null
	,finish: null
	,fileStart: null
	,fileFinish: null
	,addMessage: null
	,__class__: checkstyle_reporter_IReporter
};
var checkstyle_detect_DetectionReporter = function() {
	this.messageCount = 0;
};
$hxClasses["checkstyle.detect.DetectionReporter"] = checkstyle_detect_DetectionReporter;
checkstyle_detect_DetectionReporter.__name__ = "checkstyle.detect.DetectionReporter";
checkstyle_detect_DetectionReporter.__interfaces__ = [checkstyle_reporter_IReporter];
checkstyle_detect_DetectionReporter.prototype = {
	messageCount: null
	,start: function() {
	}
	,finish: function() {
	}
	,fileStart: function(f) {
	}
	,fileFinish: function(f) {
	}
	,addMessage: function(m) {
		this.messageCount++;
	}
	,__class__: checkstyle_detect_DetectionReporter
};
var checkstyle_detect_DetectionResult = $hxEnums["checkstyle.detect.DetectionResult"] = { __ename__ : true, __constructs__ : ["NO_CHANGE","CHANGE_DETECTED","REDUCED_VALUE_LIST"]
	,NO_CHANGE: {_hx_index:0,__enum__:"checkstyle.detect.DetectionResult",toString:$estr}
	,CHANGE_DETECTED: ($_=function(value) { return {_hx_index:1,value:value,__enum__:"checkstyle.detect.DetectionResult",toString:$estr}; },$_.__params__ = ["value"],$_)
	,REDUCED_VALUE_LIST: ($_=function(value) { return {_hx_index:2,value:value,__enum__:"checkstyle.detect.DetectionResult",toString:$estr}; },$_.__params__ = ["value"],$_)
};
var checkstyle_errors_Error = function(message) {
	this.message = message;
};
$hxClasses["checkstyle.errors.Error"] = checkstyle_errors_Error;
checkstyle_errors_Error.__name__ = "checkstyle.errors.Error";
checkstyle_errors_Error.prototype = {
	message: null
	,toString: function() {
		return this.message;
	}
	,__class__: checkstyle_errors_Error
};
var checkstyle_reporter_BaseReporter = function(fileCount,checkCount,usedCheckCount,path,ns) {
	this.numFiles = fileCount;
	this.numChecks = checkCount;
	this.numUsedChecks = usedCheckCount;
	this.noStyle = ns;
	if(path != null) {
		var folder = haxe_io_Path.directory(path);
		if(folder.length > 0 && !sys_FileSystem.exists(folder)) {
			sys_FileSystem.createDirectory(folder);
		}
		this.file = new sys_io_FileOutput(js_node_Fs.openSync(path,"w"));
		this.report = new StringBuf();
	}
};
$hxClasses["checkstyle.reporter.BaseReporter"] = checkstyle_reporter_BaseReporter;
checkstyle_reporter_BaseReporter.__name__ = "checkstyle.reporter.BaseReporter";
checkstyle_reporter_BaseReporter.__interfaces__ = [checkstyle_reporter_IReporter];
checkstyle_reporter_BaseReporter.severityString = function(s) {
	switch(s) {
	case "ERROR":
		return "Error";
	case "IGNORE":
		return "Ignore";
	case "INFO":
		return "Info";
	case "WARNING":
		return "Warning";
	}
};
checkstyle_reporter_BaseReporter.prototype = {
	errors: null
	,warnings: null
	,infos: null
	,total: null
	,report: null
	,file: null
	,numFiles: null
	,numChecks: null
	,numUsedChecks: null
	,noStyle: null
	,start: function() {
		this.errors = 0;
		this.warnings = 0;
		this.infos = 0;
		this.total = 0;
		var version = "2.7.0";
		process.stdout.write("");
		process.stdout.write("\n");
		var fileString = this.numFiles == 1 ? "file" : "files";
		var v = this.styleText("Running Checkstyle v" + version + " using " + this.numUsedChecks + "/" + this.numChecks + " checks on " + this.numFiles + " source " + fileString + "...",1);
		process.stdout.write(Std.string(v));
		process.stdout.write("\n");
		process.stdout.write("");
		process.stdout.write("\n");
	}
	,finish: function() {
		if(this.file != null) {
			this.file.writeString(this.report.b);
			this.file.close();
		}
		this.total = this.errors + this.warnings + this.infos;
		if(this.total > 0) {
			var v = this.styleText("\nTotal Issues: " + this.total + " (",1) + this.styleText("Errors: " + this.errors,91) + this.styleText(", ",1) + this.styleText("Warnings: " + this.warnings,95) + this.styleText(", ",1) + this.styleText("Infos: " + this.infos,94) + this.styleText(")",1);
			process.stdout.write(Std.string(v));
			process.stdout.write("\n");
		} else {
			var v = this.styleText("No issues found.",1);
			process.stdout.write(Std.string(v));
			process.stdout.write("\n");
		}
	}
	,fileStart: function(f) {
	}
	,fileFinish: function(f) {
	}
	,addMessage: function(m) {
	}
	,styleText: function(s,style) {
		if(Sys.systemName() == "Windows" || this.noStyle) {
			return s;
		}
		return "\x1B[" + style + "m" + s + "\x1B[0m";
	}
	,applyColour: function(msg,s) {
		switch(s) {
		case "ERROR":
			return this.styleText(msg,91);
		case "IGNORE":
			return this.styleText(msg,94);
		case "INFO":
			return this.styleText(msg,94);
		case "WARNING":
			return this.styleText(msg,95);
		}
	}
	,getMessage: function(m) {
		var sb = new StringBuf();
		sb.b += Std.string(m.fileName);
		sb.b += ":";
		sb.b += Std.string(m.startLine);
		if(m.startColumn >= 0) {
			var isRange = m.startColumn != m.endColumn;
			sb.b += Std.string(": character" + (isRange ? "s" : "") + " ");
			sb.b += Std.string(m.startColumn);
			if(isRange) {
				sb.b += "-";
				sb.b += Std.string(m.endColumn);
			}
			sb.b += " ";
		}
		sb.b += ": ";
		sb.b += Std.string(m.moduleName);
		sb.b += " - ";
		var x = checkstyle_reporter_BaseReporter.severityString(m.severity);
		sb.b += Std.string(x);
		sb.b += ": ";
		sb.b += Std.string(m.message);
		sb.b += "\n";
		return sb;
	}
	,__class__: checkstyle_reporter_BaseReporter
};
var checkstyle_reporter_CodeClimateReporter = function(fileCount,checkCount,usedCheckCount,path,ns) {
	checkstyle_reporter_BaseReporter.call(this,fileCount,checkCount,usedCheckCount,path,ns);
};
$hxClasses["checkstyle.reporter.CodeClimateReporter"] = checkstyle_reporter_CodeClimateReporter;
checkstyle_reporter_CodeClimateReporter.__name__ = "checkstyle.reporter.CodeClimateReporter";
checkstyle_reporter_CodeClimateReporter.__super__ = checkstyle_reporter_BaseReporter;
checkstyle_reporter_CodeClimateReporter.prototype = $extend(checkstyle_reporter_BaseReporter.prototype,{
	start: function() {
	}
	,finish: function() {
	}
	,addMessage: function(m) {
		var _this_r = new RegExp("^/code/","".split("u").join(""));
		var file = m.fileName.replace(_this_r,"");
		var _this_r = new RegExp("//","".split("u").join(""));
		file = file.replace(_this_r,"/");
		var issue = { type : "issue", check_name : m.moduleName, description : StringTools.replace(m.message,"\"","`"), content : { body : m.desc}, severity : this.getSeverity(m.severity), categories : m.categories, remediation_points : m.points * 50000, location : { path : file, positions : { begin : { line : m.startLine, column : m.startColumn}, end : { line : m.endLine, column : m.endColumn}}}};
		var v = JSON.stringify(issue);
		process.stdout.write(Std.string(v));
		new _$Sys_FileOutput(1).writeByte(0);
	}
	,getSeverity: function(severity) {
		switch(severity) {
		case "ERROR":
			return "critical";
		case "INFO":
			return "info";
		case "WARNING":
			return "normal";
		default:
			return "info";
		}
	}
	,__class__: checkstyle_reporter_CodeClimateReporter
});
var checkstyle_reporter_ExitCodeReporter = function() {
	this.failCheckCount = 0;
};
$hxClasses["checkstyle.reporter.ExitCodeReporter"] = checkstyle_reporter_ExitCodeReporter;
checkstyle_reporter_ExitCodeReporter.__name__ = "checkstyle.reporter.ExitCodeReporter";
checkstyle_reporter_ExitCodeReporter.__interfaces__ = [checkstyle_reporter_IReporter];
checkstyle_reporter_ExitCodeReporter.prototype = {
	failCheckCount: null
	,start: function() {
	}
	,finish: function() {
		checkstyle_Main.setExitCode(this.failCheckCount);
	}
	,fileStart: function(f) {
	}
	,fileFinish: function(f) {
	}
	,addMessage: function(m) {
		if(m.severity == "ERROR") {
			this.failCheckCount++;
		}
	}
	,__class__: checkstyle_reporter_ExitCodeReporter
};
var checkstyle_reporter_JSONReporter = function(fileCount,checkCount,usedCheckCount,path,ns) {
	checkstyle_reporter_BaseReporter.call(this,fileCount,checkCount,usedCheckCount,path,ns);
};
$hxClasses["checkstyle.reporter.JSONReporter"] = checkstyle_reporter_JSONReporter;
checkstyle_reporter_JSONReporter.__name__ = "checkstyle.reporter.JSONReporter";
checkstyle_reporter_JSONReporter.__super__ = checkstyle_reporter_BaseReporter;
checkstyle_reporter_JSONReporter.prototype = $extend(checkstyle_reporter_BaseReporter.prototype,{
	jsonReport: null
	,fileReport: null
	,start: function() {
		this.jsonReport = [];
		checkstyle_reporter_BaseReporter.prototype.start.call(this);
	}
	,fileStart: function(f) {
		this.fileReport = { fileName : f.name, messages : []};
		this.jsonReport.push(this.fileReport);
	}
	,finish: function() {
		if(this.file != null) {
			var _this = this.report;
			var x = JSON.stringify(this.jsonReport);
			_this.b += Std.string(x);
		}
		checkstyle_reporter_BaseReporter.prototype.finish.call(this);
	}
	,addMessage: function(m) {
		var reportMessage = { line : m.startLine, column : m.startColumn, severity : checkstyle_reporter_BaseReporter.severityString(m.severity), message : m.message};
		this.fileReport.messages.push(reportMessage);
		switch(m.severity) {
		case "ERROR":
			this.errors++;
			break;
		case "INFO":
			this.infos++;
			break;
		case "WARNING":
			this.warnings++;
			break;
		default:
		}
		var v = this.applyColour(this.getMessage(m).b,m.severity);
		process.stdout.write(Std.string(v));
	}
	,__class__: checkstyle_reporter_JSONReporter
});
var checkstyle_reporter_ProgressReporter = function(numFiles) {
	this.numFiles = numFiles;
};
$hxClasses["checkstyle.reporter.ProgressReporter"] = checkstyle_reporter_ProgressReporter;
checkstyle_reporter_ProgressReporter.__name__ = "checkstyle.reporter.ProgressReporter";
checkstyle_reporter_ProgressReporter.__interfaces__ = [checkstyle_reporter_IReporter];
checkstyle_reporter_ProgressReporter.prototype = {
	lineLength: null
	,numFiles: null
	,start: function() {
	}
	,finish: function() {
		this.clear();
	}
	,fileStart: function(f) {
		this.clear();
		var percentage = Math.floor((f.index + 1) / this.numFiles * 100);
		var line = "" + percentage + "% - " + f.name;
		this.lineLength = line.length;
		process.stdout.write(Std.string(line));
		if(f.index == this.numFiles - 1) {
			process.stdout.write("\n");
		}
	}
	,clear: function() {
		process.stdout.write("\r");
		var _g = 0;
		var _g1 = this.lineLength;
		while(_g < _g1) {
			var count = _g++;
			process.stdout.write(" ");
		}
		process.stdout.write("\r");
	}
	,fileFinish: function(f) {
	}
	,addMessage: function(m) {
	}
	,__class__: checkstyle_reporter_ProgressReporter
};
var checkstyle_reporter_ReporterManager = function() {
	this.clear();
	this.lock = new checkstyle_utils_DummyMutex();
};
$hxClasses["checkstyle.reporter.ReporterManager"] = checkstyle_reporter_ReporterManager;
checkstyle_reporter_ReporterManager.__name__ = "checkstyle.reporter.ReporterManager";
checkstyle_reporter_ReporterManager.prototype = {
	reporters: null
	,lock: null
	,clear: function() {
		this.reporters = [];
	}
	,addReporter: function(r) {
		this.reporters.push(r);
	}
	,start: function() {
		var _g = 0;
		var _g1 = this.reporters;
		while(_g < _g1.length) {
			var reporter = _g1[_g];
			++_g;
			reporter.start();
		}
	}
	,finish: function() {
		var _g = 0;
		var _g1 = this.reporters;
		while(_g < _g1.length) {
			var reporter = _g1[_g];
			++_g;
			reporter.finish();
		}
	}
	,fileStart: function(f) {
		this.lock.acquire();
		var _g = 0;
		var _g1 = this.reporters;
		while(_g < _g1.length) {
			var reporter = _g1[_g];
			++_g;
			reporter.fileStart(f);
		}
		this.lock.release();
	}
	,fileFinish: function(f) {
		this.lock.acquire();
		var _g = 0;
		var _g1 = this.reporters;
		while(_g < _g1.length) {
			var reporter = _g1[_g];
			++_g;
			reporter.fileFinish(f);
		}
		this.lock.release();
	}
	,addError: function(f,e,name) {
		if(!checkstyle_reporter_ReporterManager.SHOW_PARSE_ERRORS) {
			return;
		}
		this.lock.acquire();
		var _g = 0;
		var _g1 = this.reporters;
		while(_g < _g1.length) {
			var reporter = _g1[_g];
			++_g;
			reporter.addMessage(this.getErrorMessage(e,f.name,"Check " + name));
		}
		this.lock.release();
	}
	,addMessages: function(messages) {
		if(messages == null || messages.length <= 0) {
			return;
		}
		this.lock.acquire();
		messages = this.filterDuplicateMessages(messages);
		var _g = 0;
		var _g1 = this.reporters;
		while(_g < _g1.length) {
			var reporter = _g1[_g];
			++_g;
			var _g2 = 0;
			while(_g2 < messages.length) {
				var m = messages[_g2];
				++_g2;
				reporter.addMessage(m);
			}
		}
		this.lock.release();
	}
	,filterDuplicateMessages: function(messages) {
		var filteredMessages = [];
		var _g = 0;
		while(_g < messages.length) {
			var message = messages[_g];
			++_g;
			var anyDuplicates = false;
			var _g1 = 0;
			while(_g1 < filteredMessages.length) {
				var filteredMessage = filteredMessages[_g1];
				++_g1;
				if(this.areMessagesSame(message,filteredMessage)) {
					anyDuplicates = true;
					break;
				}
			}
			if(!anyDuplicates) {
				filteredMessages.push(message);
			}
		}
		return filteredMessages;
	}
	,areMessagesSame: function(message1,message2) {
		if(message1.fileName == message2.fileName && message1.message == message2.message && message1.code == message2.code && message1.startLine == message2.startLine && message1.startColumn == message2.startColumn && message1.endLine == message2.endLine && message1.endColumn == message2.endColumn && message1.severity == message2.severity) {
			return message1.moduleName == message2.moduleName;
		} else {
			return false;
		}
	}
	,getErrorMessage: function(e,fileName,step) {
		return { fileName : fileName, startLine : 1, endLine : 1, startColumn : 0, endColumn : 0, severity : "ERROR", moduleName : "Checker", categories : ["Style"], points : 1, desc : "", code : "" + (e == null ? "null" : Std.string(e)), message : "" + step + " failed: " + (e == null ? "null" : Std.string(e)) + "\nPlease file a github issue at https://github.com/HaxeCheckstyle/haxe-checkstyle/issues"};
	}
	,__class__: checkstyle_reporter_ReporterManager
};
var checkstyle_reporter_TextReporter = function(fileCount,checkCount,usedCheckCount,path,ns) {
	checkstyle_reporter_BaseReporter.call(this,fileCount,checkCount,usedCheckCount,path,ns);
};
$hxClasses["checkstyle.reporter.TextReporter"] = checkstyle_reporter_TextReporter;
checkstyle_reporter_TextReporter.__name__ = "checkstyle.reporter.TextReporter";
checkstyle_reporter_TextReporter.__super__ = checkstyle_reporter_BaseReporter;
checkstyle_reporter_TextReporter.prototype = $extend(checkstyle_reporter_BaseReporter.prototype,{
	addMessage: function(m) {
		var sb = this.getMessage(m);
		var output = new _$Sys_FileOutput(2);
		switch(m.severity) {
		case "ERROR":
			this.errors++;
			break;
		case "INFO":
			this.infos++;
			output = new _$Sys_FileOutput(1);
			break;
		case "WARNING":
			this.warnings++;
			break;
		default:
		}
		var line = sb.b;
		if(Sys.systemName() == "Windows") {
			output.writeString(line);
		} else {
			var v = this.applyColour(line,m.severity);
			process.stdout.write(Std.string(v));
		}
		if(this.file != null) {
			this.report.b += line == null ? "null" : "" + line;
		}
	}
	,__class__: checkstyle_reporter_TextReporter
});
var checkstyle_reporter_XMLReporter = function(numFiles,checkCount,usedCheckCount,path,s,ns) {
	checkstyle_reporter_BaseReporter.call(this,numFiles,checkCount,usedCheckCount,path,ns);
	this.messageCache = new haxe_ds_StringMap();
	this.style = s;
};
$hxClasses["checkstyle.reporter.XMLReporter"] = checkstyle_reporter_XMLReporter;
checkstyle_reporter_XMLReporter.__name__ = "checkstyle.reporter.XMLReporter";
checkstyle_reporter_XMLReporter.replace = function(str,re) {
	return re.map(str,function(re) {
		var this1 = checkstyle_reporter_XMLReporter.ENTITY_MAP;
		var key = re.matched(0);
		return this1.h[key];
	});
};
checkstyle_reporter_XMLReporter.escapeXML = function(string) {
	return checkstyle_reporter_XMLReporter.replace(string,checkstyle_reporter_XMLReporter.ENTITY_RE);
};
checkstyle_reporter_XMLReporter.__super__ = checkstyle_reporter_BaseReporter;
checkstyle_reporter_XMLReporter.prototype = $extend(checkstyle_reporter_BaseReporter.prototype,{
	style: null
	,messageCache: null
	,start: function() {
		var sb_b = "";
		sb_b += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
		if(this.style != "") {
			sb_b += Std.string("<?xml-stylesheet type=\"text/xsl\" href=\"" + this.style + "\" ?>\n");
		}
		sb_b += "<checkstyle version=\"5.7\">\n";
		if(this.file != null) {
			this.report.b += Std.string(sb_b);
		}
		checkstyle_reporter_BaseReporter.prototype.start.call(this);
	}
	,finish: function() {
		var sb_b = "";
		sb_b += "</checkstyle>\n";
		if(this.file != null) {
			this.report.b += Std.string(sb_b);
		}
		checkstyle_reporter_BaseReporter.prototype.finish.call(this);
	}
	,encode: function(s) {
		return checkstyle_reporter_XMLReporter.escapeXML(s);
	}
	,fileStart: function(f) {
		this.messageCache.h[f.name] = [];
	}
	,fileFinish: function(f) {
		var sb_b = "";
		sb_b += "\t<file name=\"";
		sb_b += Std.string(this.encode(f.name));
		sb_b += "\">\n";
		var messages = this.messageCache.h[f.name];
		var _g = 0;
		while(_g < messages.length) {
			var m = messages[_g];
			++_g;
			sb_b += Std.string(this.formatMessage(m));
		}
		var key = f.name;
		var _this = this.messageCache;
		if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
			delete(_this.h[key]);
		}
		sb_b += "\t</file>\n";
		if(this.file != null) {
			this.report.b += Std.string(sb_b);
		}
	}
	,addMessage: function(m) {
		if(!Object.prototype.hasOwnProperty.call(this.messageCache.h,m.fileName)) {
			this.messageCache.h[m.fileName] = [m];
		} else {
			this.messageCache.h[m.fileName].push(m);
		}
	}
	,formatMessage: function(m) {
		var sb_b = "";
		sb_b += "\t\t<error line=\"";
		sb_b += Std.string(m.startLine);
		sb_b += "\"";
		if(m.startColumn >= 0) {
			sb_b += " column=\"";
			sb_b += Std.string(m.startColumn);
			sb_b += "\"";
		}
		sb_b += " severity=\"";
		sb_b += Std.string(checkstyle_reporter_BaseReporter.severityString(m.severity));
		sb_b += "\"";
		sb_b += " message=\"";
		sb_b += Std.string(this.encode(m.moduleName) + " - " + this.encode(m.message));
		sb_b += "\"";
		sb_b += " source=\"";
		sb_b += Std.string(this.encode(m.fileName));
		sb_b += "\"/>\n";
		switch(m.severity) {
		case "ERROR":
			this.errors++;
			break;
		case "INFO":
			this.infos++;
			break;
		case "WARNING":
			this.warnings++;
			break;
		default:
		}
		var v = this.applyColour(this.getMessage(m).b,m.severity);
		process.stdout.write(Std.string(v));
		return sb_b;
	}
	,__class__: checkstyle_reporter_XMLReporter
});
var checkstyle_utils_ArrayUtils = function() { };
$hxClasses["checkstyle.utils.ArrayUtils"] = checkstyle_utils_ArrayUtils;
checkstyle_utils_ArrayUtils.__name__ = "checkstyle.utils.ArrayUtils";
checkstyle_utils_ArrayUtils.contains = function(a,el) {
	return a.indexOf(el) != -1;
};
checkstyle_utils_ArrayUtils.sortStrings = function(texts) {
	haxe_ds_ArraySort.sort(texts,function(a,b) {
		if(a > b) {
			return 1;
		}
		if(a < b) {
			return -1;
		}
		return 0;
	});
};
var checkstyle_utils_ConfigUtils = function() { };
$hxClasses["checkstyle.utils.ConfigUtils"] = checkstyle_utils_ConfigUtils;
checkstyle_utils_ConfigUtils.__name__ = "checkstyle.utils.ConfigUtils";
checkstyle_utils_ConfigUtils.getEmptyConfig = function() {
	return { defaultSeverity : "INFO", extendsConfigPath : "", numberOfCheckerThreads : 5, baseDefines : [], defineCombinations : [], checks : [], exclude : { }, version : 1};
};
checkstyle_utils_ConfigUtils.saveConfig = function(checker,path) {
	var file = new sys_io_FileOutput(js_node_Fs.openSync(path,"w"));
	file.writeString(JSON.stringify(checkstyle_utils_ConfigUtils.makeConfigFromChecker(checker),null,"\t"));
	file.close();
};
checkstyle_utils_ConfigUtils.saveCheckConfigList = function(list,path) {
	var file = new sys_io_FileOutput(js_node_Fs.openSync(path,"w"));
	file.writeString(JSON.stringify(checkstyle_utils_ConfigUtils.makeConfigFromList(list),null,"\t"));
	file.close();
};
checkstyle_utils_ConfigUtils.makeConfigFromChecker = function(checker) {
	var list = [];
	var _g = 0;
	var _g1 = checker.checks;
	while(_g < _g1.length) {
		var check = _g1[_g];
		++_g;
		list.push(checkstyle_utils_ConfigUtils.makeCheckConfig(check));
	}
	return checkstyle_utils_ConfigUtils.makeConfigFromList(list);
};
checkstyle_utils_ConfigUtils.makeConfigFromList = function(list) {
	var config = checkstyle_utils_ConfigUtils.getEmptyConfig();
	config.checks = list;
	haxe_ds_ArraySort.sort(config.checks,checkstyle_utils_ConfigUtils.checkConfigSort);
	return config;
};
checkstyle_utils_ConfigUtils.checkConfigSort = function(a,b) {
	if(a.type == b.type) {
		return 0;
	}
	if(a.type < b.type) {
		return -1;
	}
	return 1;
};
checkstyle_utils_ConfigUtils.checkSort = function(a,b) {
	if(a.getModuleName() == b.getModuleName()) {
		return 0;
	}
	if(a.getModuleName() < b.getModuleName()) {
		return -1;
	}
	return 1;
};
checkstyle_utils_ConfigUtils.checkInfoSort = function(a,b) {
	if(a.name == b.name) {
		return 0;
	}
	if(a.name < b.name) {
		return -1;
	}
	return 1;
};
checkstyle_utils_ConfigUtils.makeCheckConfig = function(check) {
	var propsNotAllowed = ["moduleName","severity","type","categories","points","desc","currentState","skipOverStringStart","commentStartRE","commentBlockEndRE","stringStartRE","stringInterpolatedEndRE","stringLiteralEndRE","formatRE","skipOverInitialQuote","messages","checker","placemap","metaName","ignoreRE"];
	var checkConfig = { type : check.getModuleName(), props : { }};
	var _g = 0;
	var _g1 = Type.getInstanceFields(js_Boot.getClass(check));
	while(_g < _g1.length) {
		var prop = _g1[_g];
		++_g;
		if(propsNotAllowed.indexOf(prop) != -1) {
			continue;
		}
		var value = Reflect.field(check,prop);
		if(Reflect.isFunction(value)) {
			continue;
		}
		checkConfig.props[prop] = value;
	}
	return checkConfig;
};
var checkstyle_utils_ErrorUtils = function() { };
$hxClasses["checkstyle.utils.ErrorUtils"] = checkstyle_utils_ErrorUtils;
checkstyle_utils_ErrorUtils.__name__ = "checkstyle.utils.ErrorUtils";
checkstyle_utils_ErrorUtils.handleException = function(e,file,name) {
	checkstyle_reporter_ReporterManager.INSTANCE.addError(file,e,name);
};
var checkstyle_utils_ExprUtils = function() { };
$hxClasses["checkstyle.utils.ExprUtils"] = checkstyle_utils_ExprUtils;
checkstyle_utils_ExprUtils.__name__ = "checkstyle.utils.ExprUtils";
checkstyle_utils_ExprUtils.walkFile = function(file,cb) {
	var _g = 0;
	var _g1 = file.decls;
	while(_g < _g1.length) {
		var decl = _g1[_g];
		++_g;
		checkstyle_utils_ExprUtils.walkTypeDecl(decl,cb);
	}
};
checkstyle_utils_ExprUtils.walkTypeDecl = function(td,cb) {
	var _g = td.decl;
	switch(_g._hx_index) {
	case 0:
		var d = _g.d;
		checkstyle_utils_ExprUtils.walkClass(d,cb);
		break;
	case 1:
		var d = _g.d;
		checkstyle_utils_ExprUtils.walkEnum(d,cb);
		break;
	case 2:
		var d = _g.d;
		checkstyle_utils_ExprUtils.walkTypedef(d,cb);
		break;
	case 3:
		var a = _g.a;
		checkstyle_utils_ExprUtils.walkAbstract(a,cb);
		break;
	case 4:
		var s = _g.s;
		checkstyle_utils_ExprUtils.walkStatic(s,td.pos,cb);
		break;
	case 5:
		var mode = _g.mode;
		var sl = _g.sl;
		checkstyle_utils_ExprUtils.walkImport(sl,mode,cb);
		break;
	case 6:
		var path = _g.path;
		checkstyle_utils_ExprUtils.walkTypePath(path,cb);
		break;
	}
};
checkstyle_utils_ExprUtils.walkMeta = function(meta,cb) {
	var _g = 0;
	while(_g < meta.length) {
		var m = meta[_g];
		++_g;
		var _g1 = 0;
		var _g2 = m.params;
		while(_g1 < _g2.length) {
			var p = _g2[_g1];
			++_g1;
			checkstyle_utils_ExprUtils.walkExpr(p,cb);
		}
	}
};
checkstyle_utils_ExprUtils.walkCommonDefinition = function(d,cb) {
	var _g = 0;
	var _g1 = d.params;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		checkstyle_utils_ExprUtils.walkTypeParamDecl(p,cb);
	}
	checkstyle_utils_ExprUtils.walkMeta(d.meta,cb);
};
checkstyle_utils_ExprUtils.walkClass = function(d,cb) {
	checkstyle_utils_ExprUtils.walkCommonDefinition(d,cb);
	var _g = 0;
	var _g1 = d.flags;
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		switch(f._hx_index) {
		case 3:
			var t = f.t;
			checkstyle_utils_ExprUtils.walkTypePath(t,cb);
			break;
		case 4:
			var t1 = f.t;
			checkstyle_utils_ExprUtils.walkTypePath(t1,cb);
			break;
		default:
		}
	}
	var _g = 0;
	var _g1 = d.data;
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		checkstyle_utils_ExprUtils.walkField(f,cb);
	}
};
checkstyle_utils_ExprUtils.walkEnum = function(d,cb) {
	checkstyle_utils_ExprUtils.walkCommonDefinition(d,cb);
	var _g = 0;
	var _g1 = d.data;
	while(_g < _g1.length) {
		var ec = _g1[_g];
		++_g;
		checkstyle_utils_ExprUtils.walkMeta(ec.meta,cb);
		var _g2 = 0;
		var _g3 = ec.args;
		while(_g2 < _g3.length) {
			var arg = _g3[_g2];
			++_g2;
			checkstyle_utils_ExprUtils.walkComplexType(arg.type,cb);
		}
		var _g4 = 0;
		var _g5 = ec.params;
		while(_g4 < _g5.length) {
			var param = _g5[_g4];
			++_g4;
			checkstyle_utils_ExprUtils.walkTypeParamDecl(param,cb);
		}
		if(ec.type != null) {
			checkstyle_utils_ExprUtils.walkComplexType(ec.type,cb);
		}
	}
};
checkstyle_utils_ExprUtils.walkAbstract = function(d,cb) {
	checkstyle_utils_ExprUtils.walkCommonDefinition(d,cb);
	var _g = 0;
	var _g1 = d.flags;
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		switch(f._hx_index) {
		case 1:
			var ct = f.ct;
			checkstyle_utils_ExprUtils.walkComplexType(ct,cb);
			break;
		case 2:
			var ct1 = f.ct;
			checkstyle_utils_ExprUtils.walkComplexType(ct1,cb);
			break;
		case 3:
			var ct2 = f.ct;
			checkstyle_utils_ExprUtils.walkComplexType(ct2,cb);
			break;
		default:
		}
	}
	var _g = 0;
	var _g1 = d.data;
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		checkstyle_utils_ExprUtils.walkField(f,cb);
	}
};
checkstyle_utils_ExprUtils.walkImport = function(sl,mode,cb) {
};
checkstyle_utils_ExprUtils.walkTypedef = function(d,cb) {
	checkstyle_utils_ExprUtils.walkCommonDefinition(d,cb);
	checkstyle_utils_ExprUtils.walkComplexType(d.data,cb);
};
checkstyle_utils_ExprUtils.walkTypePath = function(tp,cb) {
	if(tp.params != null) {
		var _g = 0;
		var _g1 = tp.params;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			switch(p._hx_index) {
			case 0:
				var t = p.t;
				checkstyle_utils_ExprUtils.walkComplexType(t,cb);
				break;
			case 1:
				var e = p.e;
				checkstyle_utils_ExprUtils.walkExpr(e,cb);
				break;
			}
		}
	}
};
checkstyle_utils_ExprUtils.walkStatic = function(s,pos,cb) {
	checkstyle_utils_ExprUtils.walkField(s,cb);
};
checkstyle_utils_ExprUtils.walkVar = function(v,cb) {
	if(v.type != null) {
		checkstyle_utils_ExprUtils.walkComplexType(v.type,cb);
	}
	if(v.expr != null) {
		checkstyle_utils_ExprUtils.walkExpr(v.expr,cb);
	}
};
checkstyle_utils_ExprUtils.walkTypeParamDecl = function(tp,cb) {
	if(tp.constraints != null) {
		var _g = 0;
		var _g1 = tp.constraints;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			checkstyle_utils_ExprUtils.walkComplexType(c,cb);
		}
	}
	if(tp.params != null) {
		var _g = 0;
		var _g1 = tp.params;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			checkstyle_utils_ExprUtils.walkTypeParamDecl(t,cb);
		}
	}
};
checkstyle_utils_ExprUtils.walkFunction = function(f,cb) {
	var _g = 0;
	var _g1 = f.args;
	while(_g < _g1.length) {
		var a = _g1[_g];
		++_g;
		if(a.type != null) {
			checkstyle_utils_ExprUtils.walkComplexType(a.type,cb);
		}
		if(a.value != null) {
			checkstyle_utils_ExprUtils.walkExpr(a.value,cb);
		}
	}
	if(f.ret != null) {
		checkstyle_utils_ExprUtils.walkComplexType(f.ret,cb);
	}
	if(f.expr != null) {
		checkstyle_utils_ExprUtils.walkExpr(f.expr,cb);
	}
	if(f.params != null) {
		var _g = 0;
		var _g1 = f.params;
		while(_g < _g1.length) {
			var tp = _g1[_g];
			++_g;
			checkstyle_utils_ExprUtils.walkTypeParamDecl(tp,cb);
		}
	}
};
checkstyle_utils_ExprUtils.walkCase = function(c,cb) {
	var _g = 0;
	var _g1 = c.values;
	while(_g < _g1.length) {
		var v = _g1[_g];
		++_g;
		checkstyle_utils_ExprUtils.walkExpr(v,cb);
	}
	if(c.guard != null) {
		checkstyle_utils_ExprUtils.walkExpr(c.guard,cb);
	}
	if(c.expr != null) {
		checkstyle_utils_ExprUtils.walkExpr(c.expr,cb);
	}
};
checkstyle_utils_ExprUtils.walkCatch = function(c,cb) {
	checkstyle_utils_ExprUtils.walkComplexType(c.type,cb);
	checkstyle_utils_ExprUtils.walkExpr(c.expr,cb);
};
checkstyle_utils_ExprUtils.walkField = function(f,cb) {
	var _g = f.kind;
	switch(_g._hx_index) {
	case 0:
		var e = _g.e;
		var t = _g.t;
		if(t != null) {
			checkstyle_utils_ExprUtils.walkComplexType(t,cb);
		}
		if(e != null) {
			checkstyle_utils_ExprUtils.walkExpr(e,cb);
		}
		break;
	case 1:
		var f = _g.f;
		checkstyle_utils_ExprUtils.walkFunction(f,cb);
		break;
	case 2:
		var e = _g.e;
		var t = _g.t;
		var set = _g.set;
		var get = _g.get;
		if(t != null) {
			checkstyle_utils_ExprUtils.walkComplexType(t,cb);
		}
		if(e != null) {
			checkstyle_utils_ExprUtils.walkExpr(e,cb);
		}
		break;
	}
};
checkstyle_utils_ExprUtils.walkComplexType = function(t,cb) {
	if(t == null) {
		return;
	}
	switch(t._hx_index) {
	case 0:
		var p = t.p;
		checkstyle_utils_ExprUtils.walkTypePath(p,cb);
		break;
	case 1:
		var ret = t.ret;
		var args = t.args;
		var _g = 0;
		while(_g < args.length) {
			var a = args[_g];
			++_g;
			checkstyle_utils_ExprUtils.walkComplexType(a,cb);
		}
		checkstyle_utils_ExprUtils.walkComplexType(ret,cb);
		break;
	case 2:
		var fields = t.fields;
		var _g = 0;
		while(_g < fields.length) {
			var f = fields[_g];
			++_g;
			checkstyle_utils_ExprUtils.walkField(f,cb);
		}
		break;
	case 3:
		var t1 = t.t;
		checkstyle_utils_ExprUtils.walkComplexType(t1,cb);
		break;
	case 4:
		var fields = t.fields;
		var p = t.p;
		var _g = 0;
		while(_g < p.length) {
			var tp = p[_g];
			++_g;
			checkstyle_utils_ExprUtils.walkTypePath(tp,cb);
		}
		var _g = 0;
		while(_g < fields.length) {
			var f = fields[_g];
			++_g;
			checkstyle_utils_ExprUtils.walkField(f,cb);
		}
		break;
	case 5:
		var t1 = t.t;
		checkstyle_utils_ExprUtils.walkComplexType(t1,cb);
		break;
	case 6:
		var t1 = t.t;
		var n = t.n;
		checkstyle_utils_ExprUtils.walkComplexType(t1,cb);
		break;
	case 7:
		var types = t.tl;
		var _g = 0;
		while(_g < types.length) {
			var t = types[_g];
			++_g;
			checkstyle_utils_ExprUtils.walkComplexType(t,cb);
		}
		break;
	}
};
checkstyle_utils_ExprUtils.walkExpr = function(e,cb) {
	cb(e);
	var _g = e.expr;
	switch(_g._hx_index) {
	case 0:
		var c = _g.c;
		break;
	case 1:
		var e2 = _g.e2;
		var e1 = _g.e1;
		checkstyle_utils_ExprUtils.walkExpr(e1,cb);
		checkstyle_utils_ExprUtils.walkExpr(e2,cb);
		break;
	case 2:
		var e2 = _g.e2;
		var e1 = _g.e1;
		var op = _g.op;
		checkstyle_utils_ExprUtils.walkExpr(e1,cb);
		checkstyle_utils_ExprUtils.walkExpr(e2,cb);
		break;
	case 3:
		var field = _g.field;
		var e = _g.e;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		break;
	case 4:
		var e = _g.e;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		break;
	case 5:
		var fields = _g.fields;
		var _g1 = 0;
		while(_g1 < fields.length) {
			var f = fields[_g1];
			++_g1;
			checkstyle_utils_ExprUtils.walkExpr(f.expr,cb);
		}
		break;
	case 6:
		var values = _g.values;
		var _g1 = 0;
		while(_g1 < values.length) {
			var v = values[_g1];
			++_g1;
			checkstyle_utils_ExprUtils.walkExpr(v,cb);
		}
		break;
	case 7:
		var params = _g.params;
		var e = _g.e;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			checkstyle_utils_ExprUtils.walkExpr(p,cb);
		}
		break;
	case 8:
		var params = _g.params;
		var t = _g.t;
		checkstyle_utils_ExprUtils.walkTypePath(t,cb);
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			checkstyle_utils_ExprUtils.walkExpr(p,cb);
		}
		break;
	case 9:
		var e = _g.e;
		var postFix = _g.postFix;
		var op = _g.op;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		break;
	case 10:
		var vars = _g.vars;
		var _g1 = 0;
		while(_g1 < vars.length) {
			var v = vars[_g1];
			++_g1;
			checkstyle_utils_ExprUtils.walkVar(v,cb);
		}
		break;
	case 11:
		var f = _g.f;
		var name = _g.kind;
		checkstyle_utils_ExprUtils.walkFunction(f,cb);
		break;
	case 12:
		var exprs = _g.exprs;
		var _g1 = 0;
		while(_g1 < exprs.length) {
			var e = exprs[_g1];
			++_g1;
			checkstyle_utils_ExprUtils.walkExpr(e,cb);
		}
		break;
	case 13:
		var expr = _g.expr;
		var it = _g.it;
		checkstyle_utils_ExprUtils.walkExpr(it,cb);
		checkstyle_utils_ExprUtils.walkExpr(expr,cb);
		break;
	case 14:
		var eelse = _g.eelse;
		var eif = _g.eif;
		var econd = _g.econd;
		checkstyle_utils_ExprUtils.walkExpr(econd,cb);
		checkstyle_utils_ExprUtils.walkExpr(eif,cb);
		if(eelse != null) {
			checkstyle_utils_ExprUtils.walkExpr(eelse,cb);
		}
		break;
	case 15:
		var normalWhile = _g.normalWhile;
		var e = _g.e;
		var econd = _g.econd;
		checkstyle_utils_ExprUtils.walkExpr(econd,cb);
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		break;
	case 16:
		var edef = _g.edef;
		var cases = _g.cases;
		var e = _g.e;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		var _g1 = 0;
		while(_g1 < cases.length) {
			var c = cases[_g1];
			++_g1;
			checkstyle_utils_ExprUtils.walkCase(c,cb);
		}
		if(edef != null && edef.expr != null) {
			checkstyle_utils_ExprUtils.walkExpr(edef,cb);
		}
		break;
	case 17:
		var catches = _g.catches;
		var e = _g.e;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		var _g1 = 0;
		while(_g1 < catches.length) {
			var c = catches[_g1];
			++_g1;
			checkstyle_utils_ExprUtils.walkCatch(c,cb);
		}
		break;
	case 18:
		var e = _g.e;
		if(e != null) {
			checkstyle_utils_ExprUtils.walkExpr(e,cb);
		}
		break;
	case 19:
		break;
	case 20:
		break;
	case 21:
		var e = _g.e;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		break;
	case 22:
		var e = _g.e;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		break;
	case 23:
		var t = _g.t;
		var e = _g.e;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		if(t != null) {
			checkstyle_utils_ExprUtils.walkComplexType(t,cb);
		}
		break;
	case 24:
		var displayKind = _g.displayKind;
		var e = _g.e;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		break;
	case 25:
		var t = _g.t;
		checkstyle_utils_ExprUtils.walkTypePath(t,cb);
		break;
	case 26:
		var eelse = _g.eelse;
		var eif = _g.eif;
		var econd = _g.econd;
		checkstyle_utils_ExprUtils.walkExpr(econd,cb);
		checkstyle_utils_ExprUtils.walkExpr(eif,cb);
		checkstyle_utils_ExprUtils.walkExpr(eelse,cb);
		break;
	case 27:
		var t = _g.t;
		var e = _g.e;
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		checkstyle_utils_ExprUtils.walkComplexType(t,cb);
		break;
	case 28:
		var e = _g.e;
		var s = _g.s;
		if(s.params != null) {
			var _g = 0;
			var _g1 = s.params;
			while(_g < _g1.length) {
				var mp = _g1[_g];
				++_g;
				checkstyle_utils_ExprUtils.walkExpr(mp,cb);
			}
		}
		checkstyle_utils_ExprUtils.walkExpr(e,cb);
		break;
	}
};
checkstyle_utils_ExprUtils.hasMeta = function(meta,name) {
	var _g = 0;
	while(_g < meta.length) {
		var entry = meta[_g];
		++_g;
		if(entry.name == name) {
			return true;
		}
	}
	return false;
};
var checkstyle_utils_FieldUtils = function() { };
$hxClasses["checkstyle.utils.FieldUtils"] = checkstyle_utils_FieldUtils;
checkstyle_utils_FieldUtils.__name__ = "checkstyle.utils.FieldUtils";
checkstyle_utils_FieldUtils.isPublic = function(f,p) {
	if(f.access.indexOf(haxe_macro_Access.APublic) != -1) {
		return true;
	}
	if(f.access.indexOf(haxe_macro_Access.APrivate) != -1) {
		return false;
	}
	return !checkstyle_utils_FieldUtils.isDefaultPrivate(f,p);
};
checkstyle_utils_FieldUtils.isPrivate = function(f,p) {
	if(f.access.indexOf(haxe_macro_Access.APrivate) != -1) {
		return true;
	}
	if(f.access.indexOf(haxe_macro_Access.APublic) != -1) {
		return false;
	}
	return checkstyle_utils_FieldUtils.isDefaultPrivate(f,p);
};
checkstyle_utils_FieldUtils.isInline = function(f,p) {
	if(f.access.indexOf(haxe_macro_Access.AInline) == -1) {
		return p.kind == checkstyle_utils_FieldParentKind.ENUM_ABSTRACT;
	} else {
		return true;
	}
};
checkstyle_utils_FieldUtils.isStatic = function(f,p) {
	return f.access.indexOf(haxe_macro_Access.AStatic) != -1;
};
checkstyle_utils_FieldUtils.isDefaultPrivate = function(f,p) {
	if(p.kind == checkstyle_utils_FieldParentKind.INTERFACE) {
		return false;
	}
	var tmp;
	if(p.kind == checkstyle_utils_FieldParentKind.ENUM_ABSTRACT && f.access.indexOf(haxe_macro_Access.AStatic) == -1) {
		var _g = f.kind;
		if(_g._hx_index == 0) {
			var _g1 = _g.e;
			var _g1 = _g.t;
			tmp = true;
		} else {
			tmp = false;
		}
	} else {
		tmp = false;
	}
	if(tmp) {
		return false;
	}
	var _g = p.decl;
	if(_g._hx_index == 0) {
		var d = _g.d;
		if(checkstyle_utils_ExprUtils.hasMeta(d.meta,":publicFields")) {
			return false;
		}
	}
	return true;
};
checkstyle_utils_FieldUtils.isGetter = function(f) {
	return StringTools.startsWith(f.name,"get_");
};
checkstyle_utils_FieldUtils.isSetter = function(f) {
	return StringTools.startsWith(f.name,"set_");
};
checkstyle_utils_FieldUtils.isConstructor = function(f) {
	return f.name == "new";
};
checkstyle_utils_FieldUtils.toParentType = function(decl) {
	switch(decl._hx_index) {
	case 0:
		var d = decl.d;
		var kind = d.flags.indexOf(haxeparser_ClassFlag.HInterface) != -1 ? checkstyle_utils_FieldParentKind.INTERFACE : checkstyle_utils_FieldParentKind.CLASS;
		return { decl : decl, kind : kind};
	case 2:
		var d = decl.d;
		return { decl : decl, kind : checkstyle_utils_FieldParentKind.TYPEDEF};
	case 3:
		var a = decl.a;
		var metaName = ":enum";
		var kind = checkstyle_utils_ExprUtils.hasMeta(a.meta,metaName) ? checkstyle_utils_FieldParentKind.ENUM_ABSTRACT : checkstyle_utils_FieldParentKind.ABSTRACT;
		return { decl : decl, kind : kind};
	default:
		return null;
	}
};
var checkstyle_utils_FieldParentKind = $hxEnums["checkstyle.utils.FieldParentKind"] = { __ename__ : true, __constructs__ : ["CLASS","INTERFACE","ABSTRACT","ENUM_ABSTRACT","TYPEDEF"]
	,CLASS: {_hx_index:0,__enum__:"checkstyle.utils.FieldParentKind",toString:$estr}
	,INTERFACE: {_hx_index:1,__enum__:"checkstyle.utils.FieldParentKind",toString:$estr}
	,ABSTRACT: {_hx_index:2,__enum__:"checkstyle.utils.FieldParentKind",toString:$estr}
	,ENUM_ABSTRACT: {_hx_index:3,__enum__:"checkstyle.utils.FieldParentKind",toString:$estr}
	,TYPEDEF: {_hx_index:4,__enum__:"checkstyle.utils.FieldParentKind",toString:$estr}
};
var checkstyle_utils_PosHelper = function() { };
$hxClasses["checkstyle.utils.PosHelper"] = checkstyle_utils_PosHelper;
checkstyle_utils_PosHelper.__name__ = "checkstyle.utils.PosHelper";
checkstyle_utils_PosHelper.makeFieldSignaturePosition = function(field) {
	var pos = { file : field.pos.file, min : field.pos.min, max : field.pos.max};
	var _g = field.kind;
	switch(_g._hx_index) {
	case 0:
		var _g1 = _g.e;
		var _g1 = _g.t;
		break;
	case 1:
		var fun = _g.f;
		if(fun.expr != null) {
			pos.max = fun.expr.pos.min;
		}
		break;
	case 2:
		var _g1 = _g.e;
		var _g1 = _g.t;
		var _g1 = _g.set;
		var _g1 = _g.get;
		break;
	}
	return pos;
};
checkstyle_utils_PosHelper.getReportPos = function(token) {
	var pos = token.getPos();
	var body = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.POpen);
	if(body == null) {
		return pos;
	}
	body = body.nextSibling;
	if(body == null) {
		return pos;
	}
	switch(body.tok._hx_index) {
	case 12:
		body = body.nextSibling;
		break;
	case 17:
		break;
	default:
		return pos;
	}
	if(body == null) {
		return pos;
	}
	pos.max = body.pos.min;
	return pos;
};
var checkstyle_utils_StringUtils = function() { };
$hxClasses["checkstyle.utils.StringUtils"] = checkstyle_utils_StringUtils;
checkstyle_utils_StringUtils.__name__ = "checkstyle.utils.StringUtils";
checkstyle_utils_StringUtils.isStringInterpolation = function(s,fileContent,pos) {
	var code = fileContent;
	var quote = code.sub(pos.min,1).toString();
	if(quote != "'") {
		return false;
	}
	var regex = new EReg("(^|[^$])\\$(\\{|[a-zA-Z0-9_]+)","");
	return regex.match(s);
};
checkstyle_utils_StringUtils.isEmpty = function(s) {
	if(s != null) {
		return s.length <= 0;
	} else {
		return true;
	}
};
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__ : true, __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"]
	,CFunction: {_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["v"],$_)
};
var haxe_CallStack = {};
haxe_CallStack.callStack = function() {
	return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
};
haxe_CallStack.exceptionStack = function() {
	var eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack());
	return haxe_CallStack.subtract(eStack,haxe_CallStack.callStack());
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	var _g1 = stack;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.subtract = function(this1,stack) {
	var startIndex = -1;
	var i = -1;
	while(++i < this1.length) {
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var j = _g++;
			if(haxe_CallStack.equalItems(this1[i],stack[j])) {
				if(startIndex < 0) {
					startIndex = i;
				}
				++i;
				if(i >= this1.length) {
					break;
				}
			} else {
				startIndex = -1;
			}
		}
		if(startIndex >= 0) {
			break;
		}
	}
	if(startIndex >= 0) {
		return this1.slice(0,startIndex);
	} else {
		return this1;
	}
};
haxe_CallStack.equalItems = function(item1,item2) {
	if(item1 == null) {
		if(item2 == null) {
			return true;
		} else {
			return false;
		}
	} else {
		switch(item1._hx_index) {
		case 0:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 0) {
				return true;
			} else {
				return false;
			}
			break;
		case 1:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 1) {
				var m1 = item1.m;
				var m2 = item2.m;
				return m1 == m2;
			} else {
				return false;
			}
			break;
		case 2:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 2) {
				var item11 = item1.s;
				var file1 = item1.file;
				var line1 = item1.line;
				var col1 = item1.column;
				var col2 = item2.column;
				var line2 = item2.line;
				var file2 = item2.file;
				var item21 = item2.s;
				if(file1 == file2 && line1 == line2 && col1 == col2) {
					return haxe_CallStack.equalItems(item11,item21);
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 3:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 3) {
				var class1 = item1.classname;
				var method1 = item1.method;
				var method2 = item2.method;
				var class2 = item2.classname;
				if(class1 == class2) {
					return method1 == method2;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 4:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 4) {
				var v1 = item1.v;
				var v2 = item2.v;
				return v1 == v2;
			} else {
				return false;
			}
			break;
		}
	}
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s.m;
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var col = s.column;
		var line = s.line;
		var file = s.file;
		var s1 = s.s;
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(col != null) {
			b.b += " column ";
			b.b += col == null ? "null" : "" + col;
		}
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var meth = s.method;
		var cname = s.classname;
		b.b += Std.string(cname == null ? "<unknown>" : cname);
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s.v;
		b.b += "local function #";
		b.b += n == null ? "null" : "" + n;
		break;
	}
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
haxe_IMap.prototype = {
	get: null
	,set: null
	,exists: null
	,__class__: haxe_IMap
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	__skipStack: null
	,__nativeException: null
	,__previousException: null
	,unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_NativeStackTrace = function() { };
$hxClasses["haxe.NativeStackTrace"] = haxe_NativeStackTrace;
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
haxe_NativeStackTrace.saveStack = function(e) {
	haxe_NativeStackTrace.lastError = e;
};
haxe_NativeStackTrace.callStack = function() {
	var e = new Error("");
	var stack = haxe_NativeStackTrace.tryHaxeStack(e);
	if(typeof(stack) == "undefined") {
		try {
			throw e;
		} catch( _g ) {
		}
		stack = e.stack;
	}
	return haxe_NativeStackTrace.normalize(stack,2);
};
haxe_NativeStackTrace.exceptionStack = function() {
	return haxe_NativeStackTrace.normalize(haxe_NativeStackTrace.tryHaxeStack(haxe_NativeStackTrace.lastError));
};
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.tryHaxeStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
	var stack = e.stack;
	Error.prepareStackTrace = oldValue;
	return stack;
};
haxe_NativeStackTrace.prepareHxStackTrace = function(e,callsites) {
	var stack = [];
	var _g = 0;
	while(_g < callsites.length) {
		var site = callsites[_g];
		++_g;
		if(haxe_NativeStackTrace.wrapCallSite != null) {
			site = haxe_NativeStackTrace.wrapCallSite(site);
		}
		var method = null;
		var fullName = site.getFunctionName();
		if(fullName != null) {
			var idx = fullName.lastIndexOf(".");
			if(idx >= 0) {
				var className = fullName.substring(0,idx);
				var methodName = fullName.substring(idx + 1);
				method = haxe_StackItem.Method(className,methodName);
			} else {
				method = haxe_StackItem.Method(null,fullName);
			}
		}
		var fileName = site.getFileName();
		var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
		if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
			fileName = fileName.substring(fileAddr + 6);
		}
		stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
	}
	return stack;
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	value: null
	,unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_ds_ArraySort = function() { };
$hxClasses["haxe.ds.ArraySort"] = haxe_ds_ArraySort;
haxe_ds_ArraySort.__name__ = "haxe.ds.ArraySort";
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		var _g1 = to;
		while(_g < _g1) {
			var i = _g++;
			var j = i;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_GenericCell = function(elt,next) {
	this.elt = elt;
	this.next = next;
};
$hxClasses["haxe.ds.GenericCell"] = haxe_ds_GenericCell;
haxe_ds_GenericCell.__name__ = "haxe.ds.GenericCell";
haxe_ds_GenericCell.prototype = {
	elt: null
	,next: null
	,__class__: haxe_ds_GenericCell
};
var haxe_ds_List = function() {
	this.length = 0;
};
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = "haxe.ds.List";
haxe_ds_List.prototype = {
	h: null
	,q: null
	,length: null
	,push: function(item) {
		var x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
haxe_ds__$List_ListNode.prototype = {
	item: null
	,next: null
	,__class__: haxe_ds__$List_ListNode
};
var haxe_ds_Option = $hxEnums["haxe.ds.Option"] = { __ename__ : true, __constructs__ : ["Some","None"]
	,Some: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Option",toString:$estr}; },$_.__params__ = ["v"],$_)
	,None: {_hx_index:1,__enum__:"haxe.ds.Option",toString:$estr}
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.keysIterator = function(h) {
	var keys = Object.keys(h);
	var len = keys.length;
	var idx = 0;
	return { hasNext : function() {
		return idx < len;
	}, next : function() {
		idx += 1;
		return keys[idx - 1];
	}};
};
haxe_ds_StringMap.valueIterator = function(h) {
	var keys = Object.keys(h);
	var len = keys.length;
	var idx = 0;
	return { hasNext : function() {
		return idx < len;
	}, next : function() {
		idx += 1;
		return h[keys[idx - 1]];
	}};
};
haxe_ds_StringMap.prototype = {
	h: null
	,exists: function(key) {
		return Object.prototype.hasOwnProperty.call(this.h,key);
	}
	,get: function(key) {
		return this.h[key];
	}
	,set: function(key,value) {
		this.h[key] = value;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	length: null
	,b: null
	,sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Eof = function() {
};
$hxClasses["haxe.io.Eof"] = haxe_io_Eof;
haxe_io_Eof.__name__ = "haxe.io.Eof";
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
$hxClasses["haxe.io.Path"] = haxe_io_Path;
haxe_io_Path.__name__ = "haxe.io.Path";
haxe_io_Path.withoutDirectory = function(path) {
	var s = new haxe_io_Path(path);
	s.dir = null;
	return s.toString();
};
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	var _g2 = paths;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	var paths = _g;
	if(paths.length == 0) {
		return "";
	}
	var path = paths[0];
	var _g = 1;
	var _g1 = paths.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = tmp;
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.isAbsolute = function(path) {
	if(StringTools.startsWith(path,"/")) {
		return true;
	}
	if(path.charAt(1) == ":") {
		return true;
	}
	if(StringTools.startsWith(path,"\\\\")) {
		return true;
	}
	return false;
};
haxe_io_Path.prototype = {
	dir: null
	,file: null
	,ext: null
	,backslash: null
	,toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	,__class__: haxe_io_Path
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	array: null
	,current: null
	,hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_macro_StringLiteralKind = $hxEnums["haxe.macro.StringLiteralKind"] = { __ename__ : true, __constructs__ : ["DoubleQuotes","SingleQuotes"]
	,DoubleQuotes: {_hx_index:0,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
	,SingleQuotes: {_hx_index:1,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
};
var haxe_macro_Constant = $hxEnums["haxe.macro.Constant"] = { __ename__ : true, __constructs__ : ["CInt","CFloat","CString","CIdent","CRegexp"]
	,CInt: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["f"],$_)
	,CString: ($_=function(s,kind) { return {_hx_index:2,s:s,kind:kind,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s","kind"],$_)
	,CIdent: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CRegexp: ($_=function(r,opt) { return {_hx_index:4,r:r,opt:opt,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["r","opt"],$_)
};
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__ : true, __constructs__ : ["OpAdd","OpMult","OpDiv","OpSub","OpAssign","OpEq","OpNotEq","OpGt","OpGte","OpLt","OpLte","OpAnd","OpOr","OpXor","OpBoolAnd","OpBoolOr","OpShl","OpShr","OpUShr","OpMod","OpAssignOp","OpInterval","OpArrow","OpIn"]
	,OpAdd: {_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
};
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__ : true, __constructs__ : ["OpIncrement","OpDecrement","OpNot","OpNeg","OpNegBits"]
	,OpIncrement: {_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
};
var haxe_macro_QuoteStatus = $hxEnums["haxe.macro.QuoteStatus"] = { __ename__ : true, __constructs__ : ["Unquoted","Quoted"]
	,Unquoted: {_hx_index:0,__enum__:"haxe.macro.QuoteStatus",toString:$estr}
	,Quoted: {_hx_index:1,__enum__:"haxe.macro.QuoteStatus",toString:$estr}
};
var haxe_macro_FunctionKind = $hxEnums["haxe.macro.FunctionKind"] = { __ename__ : true, __constructs__ : ["FAnonymous","FNamed","FArrow"]
	,FAnonymous: {_hx_index:0,__enum__:"haxe.macro.FunctionKind",toString:$estr}
	,FNamed: ($_=function(name,inlined) { return {_hx_index:1,name:name,inlined:inlined,__enum__:"haxe.macro.FunctionKind",toString:$estr}; },$_.__params__ = ["name","inlined"],$_)
	,FArrow: {_hx_index:2,__enum__:"haxe.macro.FunctionKind",toString:$estr}
};
var haxe_macro_ExprDef = $hxEnums["haxe.macro.ExprDef"] = { __ename__ : true, __constructs__ : ["EConst","EArray","EBinop","EField","EParenthesis","EObjectDecl","EArrayDecl","ECall","ENew","EUnop","EVars","EFunction","EBlock","EFor","EIf","EWhile","ESwitch","ETry","EReturn","EBreak","EContinue","EUntyped","EThrow","ECast","EDisplay","EDisplayNew","ETernary","ECheckType","EMeta"]
	,EConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["c"],$_)
	,EArray: ($_=function(e1,e2) { return {_hx_index:1,e1:e1,e2:e2,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e1","e2"],$_)
	,EBinop: ($_=function(op,e1,e2) { return {_hx_index:2,op:op,e1:e1,e2:e2,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["op","e1","e2"],$_)
	,EField: ($_=function(e,field) { return {_hx_index:3,e:e,field:field,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","field"],$_)
	,EParenthesis: ($_=function(e) { return {_hx_index:4,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,EObjectDecl: ($_=function(fields) { return {_hx_index:5,fields:fields,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["fields"],$_)
	,EArrayDecl: ($_=function(values) { return {_hx_index:6,values:values,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["values"],$_)
	,ECall: ($_=function(e,params) { return {_hx_index:7,e:e,params:params,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","params"],$_)
	,ENew: ($_=function(t,params) { return {_hx_index:8,t:t,params:params,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["t","params"],$_)
	,EUnop: ($_=function(op,postFix,e) { return {_hx_index:9,op:op,postFix:postFix,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["op","postFix","e"],$_)
	,EVars: ($_=function(vars) { return {_hx_index:10,vars:vars,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["vars"],$_)
	,EFunction: ($_=function(kind,f) { return {_hx_index:11,kind:kind,f:f,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["kind","f"],$_)
	,EBlock: ($_=function(exprs) { return {_hx_index:12,exprs:exprs,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["exprs"],$_)
	,EFor: ($_=function(it,expr) { return {_hx_index:13,it:it,expr:expr,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["it","expr"],$_)
	,EIf: ($_=function(econd,eif,eelse) { return {_hx_index:14,econd:econd,eif:eif,eelse:eelse,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["econd","eif","eelse"],$_)
	,EWhile: ($_=function(econd,e,normalWhile) { return {_hx_index:15,econd:econd,e:e,normalWhile:normalWhile,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["econd","e","normalWhile"],$_)
	,ESwitch: ($_=function(e,cases,edef) { return {_hx_index:16,e:e,cases:cases,edef:edef,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","cases","edef"],$_)
	,ETry: ($_=function(e,catches) { return {_hx_index:17,e:e,catches:catches,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","catches"],$_)
	,EReturn: ($_=function(e) { return {_hx_index:18,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,EBreak: {_hx_index:19,__enum__:"haxe.macro.ExprDef",toString:$estr}
	,EContinue: {_hx_index:20,__enum__:"haxe.macro.ExprDef",toString:$estr}
	,EUntyped: ($_=function(e) { return {_hx_index:21,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,EThrow: ($_=function(e) { return {_hx_index:22,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,ECast: ($_=function(e,t) { return {_hx_index:23,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","t"],$_)
	,EDisplay: ($_=function(e,displayKind) { return {_hx_index:24,e:e,displayKind:displayKind,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","displayKind"],$_)
	,EDisplayNew: ($_=function(t) { return {_hx_index:25,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["t"],$_)
	,ETernary: ($_=function(econd,eif,eelse) { return {_hx_index:26,econd:econd,eif:eif,eelse:eelse,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["econd","eif","eelse"],$_)
	,ECheckType: ($_=function(e,t) { return {_hx_index:27,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","t"],$_)
	,EMeta: ($_=function(s,e) { return {_hx_index:28,s:s,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["s","e"],$_)
};
var haxe_macro_DisplayKind = $hxEnums["haxe.macro.DisplayKind"] = { __ename__ : true, __constructs__ : ["DKCall","DKDot","DKStructure","DKMarked","DKPattern"]
	,DKCall: {_hx_index:0,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKDot: {_hx_index:1,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKStructure: {_hx_index:2,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKMarked: {_hx_index:3,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKPattern: ($_=function(outermost) { return {_hx_index:4,outermost:outermost,__enum__:"haxe.macro.DisplayKind",toString:$estr}; },$_.__params__ = ["outermost"],$_)
};
var haxe_macro_ComplexType = $hxEnums["haxe.macro.ComplexType"] = { __ename__ : true, __constructs__ : ["TPath","TFunction","TAnonymous","TParent","TExtend","TOptional","TNamed","TIntersection"]
	,TPath: ($_=function(p) { return {_hx_index:0,p:p,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["p"],$_)
	,TFunction: ($_=function(args,ret) { return {_hx_index:1,args:args,ret:ret,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["args","ret"],$_)
	,TAnonymous: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["fields"],$_)
	,TParent: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TExtend: ($_=function(p,fields) { return {_hx_index:4,p:p,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["p","fields"],$_)
	,TOptional: ($_=function(t) { return {_hx_index:5,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TNamed: ($_=function(n,t) { return {_hx_index:6,n:n,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["n","t"],$_)
	,TIntersection: ($_=function(tl) { return {_hx_index:7,tl:tl,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["tl"],$_)
};
var haxe_macro_TypeParam = $hxEnums["haxe.macro.TypeParam"] = { __ename__ : true, __constructs__ : ["TPType","TPExpr"]
	,TPType: ($_=function(t) { return {_hx_index:0,t:t,__enum__:"haxe.macro.TypeParam",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TPExpr: ($_=function(e) { return {_hx_index:1,e:e,__enum__:"haxe.macro.TypeParam",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_macro_Access = $hxEnums["haxe.macro.Access"] = { __ename__ : true, __constructs__ : ["APublic","APrivate","AStatic","AOverride","ADynamic","AInline","AMacro","AFinal","AExtern"]
	,APublic: {_hx_index:0,__enum__:"haxe.macro.Access",toString:$estr}
	,APrivate: {_hx_index:1,__enum__:"haxe.macro.Access",toString:$estr}
	,AStatic: {_hx_index:2,__enum__:"haxe.macro.Access",toString:$estr}
	,AOverride: {_hx_index:3,__enum__:"haxe.macro.Access",toString:$estr}
	,ADynamic: {_hx_index:4,__enum__:"haxe.macro.Access",toString:$estr}
	,AInline: {_hx_index:5,__enum__:"haxe.macro.Access",toString:$estr}
	,AMacro: {_hx_index:6,__enum__:"haxe.macro.Access",toString:$estr}
	,AFinal: {_hx_index:7,__enum__:"haxe.macro.Access",toString:$estr}
	,AExtern: {_hx_index:8,__enum__:"haxe.macro.Access",toString:$estr}
};
var haxe_macro_FieldType = $hxEnums["haxe.macro.FieldType"] = { __ename__ : true, __constructs__ : ["FVar","FFun","FProp"]
	,FVar: ($_=function(t,e) { return {_hx_index:0,t:t,e:e,__enum__:"haxe.macro.FieldType",toString:$estr}; },$_.__params__ = ["t","e"],$_)
	,FFun: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.FieldType",toString:$estr}; },$_.__params__ = ["f"],$_)
	,FProp: ($_=function(get,set,t,e) { return {_hx_index:2,get:get,set:set,t:t,e:e,__enum__:"haxe.macro.FieldType",toString:$estr}; },$_.__params__ = ["get","set","t","e"],$_)
};
var haxe_macro_ExprTools = function() { };
$hxClasses["haxe.macro.ExprTools"] = haxe_macro_ExprTools;
haxe_macro_ExprTools.__name__ = "haxe.macro.ExprTools";
haxe_macro_ExprTools.toString = function(e) {
	return new haxe_macro_Printer().printExpr(e);
};
var haxe_macro_PositionTools = function() { };
$hxClasses["haxe.macro.PositionTools"] = haxe_macro_PositionTools;
haxe_macro_PositionTools.__name__ = "haxe.macro.PositionTools";
haxe_macro_PositionTools.make = function(inf) {
	return inf;
};
var haxe_macro_Printer = function(tabString) {
	if(tabString == null) {
		tabString = "\t";
	}
	this.tabs = "";
	this.tabString = tabString;
};
$hxClasses["haxe.macro.Printer"] = haxe_macro_Printer;
haxe_macro_Printer.__name__ = "haxe.macro.Printer";
haxe_macro_Printer.prototype = {
	tabs: null
	,tabString: null
	,printUnop: function(op) {
		switch(op._hx_index) {
		case 0:
			return "++";
		case 1:
			return "--";
		case 2:
			return "!";
		case 3:
			return "-";
		case 4:
			return "~";
		}
	}
	,printBinop: function(op) {
		switch(op._hx_index) {
		case 0:
			return "+";
		case 1:
			return "*";
		case 2:
			return "/";
		case 3:
			return "-";
		case 4:
			return "=";
		case 5:
			return "==";
		case 6:
			return "!=";
		case 7:
			return ">";
		case 8:
			return ">=";
		case 9:
			return "<";
		case 10:
			return "<=";
		case 11:
			return "&";
		case 12:
			return "|";
		case 13:
			return "^";
		case 14:
			return "&&";
		case 15:
			return "||";
		case 16:
			return "<<";
		case 17:
			return ">>";
		case 18:
			return ">>>";
		case 19:
			return "%";
		case 20:
			var op1 = op.op;
			return this.printBinop(op1) + "=";
		case 21:
			return "...";
		case 22:
			return "=>";
		case 23:
			return "in";
		}
	}
	,escapeString: function(s,delim) {
		return delim + StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(s,"\n","\\n"),"\t","\\t"),"\r","\\r"),"'","\\'"),"\"","\\\"") + delim;
	}
	,printString: function(s) {
		return this.escapeString(s,"\"");
	}
	,printConstant: function(c) {
		switch(c._hx_index) {
		case 0:
			var s = c.v;
			return s;
		case 1:
			var s = c.f;
			return s;
		case 2:
			var _g = c.kind;
			var s = c.s;
			return this.printString(s);
		case 3:
			var s = c.s;
			return s;
		case 4:
			var opt = c.opt;
			var s = c.r;
			return "~/" + s + "/" + opt;
		}
	}
	,printTypeParam: function(param) {
		switch(param._hx_index) {
		case 0:
			var ct = param.t;
			return this.printComplexType(ct);
		case 1:
			var e = param.e;
			return this.printExpr(e);
		}
	}
	,printTypePath: function(tp) {
		var tmp = (tp.pack.length > 0 ? tp.pack.join(".") + "." : "") + tp.name + (tp.sub != null ? "." + tp.sub : "");
		var tmp1;
		if(tp.params == null) {
			tmp1 = "";
		} else if(tp.params.length > 0) {
			var _this = tp.params;
			var f = $bind(this,this.printTypeParam);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp1 = "<" + result.join(", ") + ">";
		} else {
			tmp1 = "";
		}
		return tmp + tmp1;
	}
	,printComplexType: function(ct) {
		switch(ct._hx_index) {
		case 0:
			var tp = ct.p;
			return this.printTypePath(tp);
		case 1:
			var ret = ct.ret;
			var args = ct.args;
			var wrapArgumentsInParentheses;
			if(args.length == 1) {
				var _g = args[0];
				switch(_g._hx_index) {
				case 0:
					var _g1 = _g.p;
					wrapArgumentsInParentheses = false;
					break;
				case 3:
					var t = _g.t;
					wrapArgumentsInParentheses = false;
					break;
				case 5:
					var _g1 = _g.t;
					if(_g1._hx_index == 0) {
						var _g = _g1.p;
						wrapArgumentsInParentheses = false;
					} else {
						wrapArgumentsInParentheses = true;
					}
					break;
				default:
					wrapArgumentsInParentheses = true;
				}
			} else {
				wrapArgumentsInParentheses = true;
			}
			var f = $bind(this,this.printComplexType);
			var result = new Array(args.length);
			var _g = 0;
			var _g1 = args.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(args[i]);
			}
			var argStr = result.join(", ");
			var tmp;
			if(ret._hx_index == 1) {
				var _g = ret.ret;
				var _g = ret.args;
				tmp = "(" + this.printComplexType(ret) + ")";
			} else {
				tmp = this.printComplexType(ret);
			}
			return (wrapArgumentsInParentheses ? "(" + argStr + ")" : argStr) + " -> " + tmp;
		case 2:
			var fields = ct.fields;
			var _g = [];
			var _g1 = 0;
			while(_g1 < fields.length) {
				var f = fields[_g1];
				++_g1;
				_g.push(this.printField(f) + "; ");
			}
			return "{ " + _g.join("") + "}";
		case 3:
			var ct1 = ct.t;
			return "(" + this.printComplexType(ct1) + ")";
		case 4:
			var fields = ct.fields;
			var tpl = ct.p;
			var f = $bind(this,this.printTypePath);
			var result = new Array(tpl.length);
			var _g = 0;
			var _g1 = tpl.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(tpl[i]);
			}
			var tmp = "{> " + result.join(" >, ") + ", ";
			var f = $bind(this,this.printField);
			var result = new Array(fields.length);
			var _g = 0;
			var _g1 = fields.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(fields[i]);
			}
			return tmp + result.join(", ") + " }";
		case 5:
			var ct1 = ct.t;
			return "?" + this.printComplexType(ct1);
		case 6:
			var ct1 = ct.t;
			var n = ct.n;
			return n + ":" + this.printComplexType(ct1);
		case 7:
			var tl = ct.tl;
			var f = $bind(this,this.printComplexType);
			var result = new Array(tl.length);
			var _g = 0;
			var _g1 = tl.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(tl[i]);
			}
			return result.join(" & ");
		}
	}
	,printMetadata: function(meta) {
		return "@" + meta.name + (meta.params != null && meta.params.length > 0 ? "(" + this.printExprs(meta.params,", ") + ")" : "");
	}
	,printAccess: function(access) {
		switch(access._hx_index) {
		case 0:
			return "public";
		case 1:
			return "private";
		case 2:
			return "static";
		case 3:
			return "override";
		case 4:
			return "dynamic";
		case 5:
			return "inline";
		case 6:
			return "macro";
		case 7:
			return "final";
		case 8:
			return "extern";
		}
	}
	,printField: function(field) {
		var tmp = field.doc != null && field.doc != "" ? "/**\n" + this.tabs + this.tabString + StringTools.replace(field.doc,"\n","\n" + this.tabs + this.tabString) + "\n" + this.tabs + "**/\n" + this.tabs : "";
		var tmp1;
		if(field.meta != null && field.meta.length > 0) {
			var _this = field.meta;
			var f = $bind(this,this.printMetadata);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp1 = result.join("\n" + this.tabs) + ("\n" + this.tabs);
		} else {
			tmp1 = "";
		}
		var tmp2 = tmp + tmp1;
		var tmp;
		if(field.access != null && field.access.length > 0) {
			var access = field.access;
			var _this;
			if(Lambda.has(access,haxe_macro_Access.AFinal)) {
				var _g = [];
				var _g1 = 0;
				var _g2 = access;
				while(_g1 < _g2.length) {
					var v = _g2[_g1];
					++_g1;
					if(v._hx_index != 7) {
						_g.push(v);
					}
				}
				_this = _g.concat([haxe_macro_Access.AFinal]);
			} else {
				_this = access;
			}
			var f = $bind(this,this.printAccess);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp = result.join(" ") + " ";
		} else {
			tmp = "";
		}
		var tmp1 = tmp2 + tmp;
		var _g = field.kind;
		var tmp;
		switch(_g._hx_index) {
		case 0:
			var eo = _g.e;
			var t = _g.t;
			tmp = (field.access != null && Lambda.has(field.access,haxe_macro_Access.AFinal) ? "" : "var ") + ("" + field.name) + this.opt(t,$bind(this,this.printComplexType)," : ") + this.opt(eo,$bind(this,this.printExpr)," = ");
			break;
		case 1:
			var func = _g.f;
			tmp = "function " + field.name + this.printFunction(func);
			break;
		case 2:
			var eo = _g.e;
			var t = _g.t;
			var set = _g.set;
			var get = _g.get;
			tmp = "var " + field.name + "(" + get + ", " + set + ")" + this.opt(t,$bind(this,this.printComplexType)," : ") + this.opt(eo,$bind(this,this.printExpr)," = ");
			break;
		}
		return tmp1 + tmp;
	}
	,printTypeParamDecl: function(tpd) {
		var tpd1 = tpd.name;
		var tmp;
		if(tpd.params != null && tpd.params.length > 0) {
			var _this = tpd.params;
			var f = $bind(this,this.printTypeParamDecl);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp = "<" + result.join(", ") + ">";
		} else {
			tmp = "";
		}
		var tmp1 = tpd1 + tmp;
		var tmp;
		if(tpd.constraints != null && tpd.constraints.length > 0) {
			var _this = tpd.constraints;
			var f = $bind(this,this.printComplexType);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp = ":(" + result.join(", ") + ")";
		} else {
			tmp = "";
		}
		return tmp1 + tmp;
	}
	,printFunctionArg: function(arg) {
		return (arg.opt ? "?" : "") + arg.name + this.opt(arg.type,$bind(this,this.printComplexType),":") + this.opt(arg.value,$bind(this,this.printExpr)," = ");
	}
	,printFunction: function(func,kind) {
		var skipParentheses;
		var _g = func.args;
		if(_g.length == 1) {
			var _g1 = _g[0];
			var _g = _g1.value;
			var _g = _g1.opt;
			var _g = _g1.name;
			var _g = _g1.meta;
			skipParentheses = _g1.type == null && kind == haxe_macro_FunctionKind.FArrow;
		} else {
			skipParentheses = false;
		}
		var tmp;
		if(func.params == null) {
			tmp = "";
		} else if(func.params.length > 0) {
			var _this = func.params;
			var f = $bind(this,this.printTypeParamDecl);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			tmp = "<" + result.join(", ") + ">";
		} else {
			tmp = "";
		}
		var tmp1 = tmp + (skipParentheses ? "" : "(");
		var _this = func.args;
		var f = $bind(this,this.printFunctionArg);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		return tmp1 + result.join(", ") + (skipParentheses ? "" : ")") + (kind == haxe_macro_FunctionKind.FArrow ? " ->" : "") + this.opt(func.ret,$bind(this,this.printComplexType),":") + this.opt(func.expr,$bind(this,this.printExpr)," ");
	}
	,printVar: function(v) {
		return v.name + this.opt(v.type,$bind(this,this.printComplexType),":") + this.opt(v.expr,$bind(this,this.printExpr)," = ");
	}
	,printObjectFieldKey: function(of) {
		var _g = of.quotes;
		if(_g == null) {
			return of.field;
		} else {
			switch(_g._hx_index) {
			case 0:
				return of.field;
			case 1:
				return "\"" + of.field + "\"";
			}
		}
	}
	,printObjectField: function(of) {
		return "" + this.printObjectFieldKey(of) + " : " + this.printExpr(of.expr);
	}
	,printExpr: function(e) {
		var _gthis = this;
		if(e == null) {
			return "#NULL";
		} else {
			var _g = e.expr;
			switch(_g._hx_index) {
			case 0:
				var c = _g.c;
				return this.printConstant(c);
			case 1:
				var e2 = _g.e2;
				var e1 = _g.e1;
				return "" + this.printExpr(e1) + "[" + this.printExpr(e2) + "]";
			case 2:
				var e2 = _g.e2;
				var e1 = _g.e1;
				var op = _g.op;
				return "" + this.printExpr(e1) + " " + this.printBinop(op) + " " + this.printExpr(e2);
			case 3:
				var n = _g.field;
				var e1 = _g.e;
				return "" + this.printExpr(e1) + "." + n;
			case 4:
				var e1 = _g.e;
				return "(" + this.printExpr(e1) + ")";
			case 5:
				var fl = _g.fields;
				var result = new Array(fl.length);
				var _g1 = 0;
				var _g2 = fl.length;
				while(_g1 < _g2) {
					var i = _g1++;
					result[i] = _gthis.printObjectField(fl[i]);
				}
				return "{ " + result.join(", ") + " }";
			case 6:
				var el = _g.values;
				return "[" + this.printExprs(el,", ") + "]";
			case 7:
				var el = _g.params;
				var e1 = _g.e;
				return "" + this.printExpr(e1) + "(" + this.printExprs(el,", ") + ")";
			case 8:
				var el = _g.params;
				var tp = _g.t;
				return "new " + this.printTypePath(tp) + "(" + this.printExprs(el,", ") + ")";
			case 9:
				var _g1 = _g.e;
				var _g2 = _g.op;
				if(_g.postFix) {
					var e1 = _g1;
					var op = _g2;
					return this.printExpr(e1) + this.printUnop(op);
				} else {
					var e1 = _g1;
					var op = _g2;
					return this.printUnop(op) + this.printExpr(e1);
				}
				break;
			case 10:
				var vl = _g.vars;
				var f = $bind(this,this.printVar);
				var result = new Array(vl.length);
				var _g1 = 0;
				var _g2 = vl.length;
				while(_g1 < _g2) {
					var i = _g1++;
					result[i] = f(vl[i]);
				}
				return "var " + result.join(", ");
			case 11:
				var _g1 = _g.f;
				var _g2 = _g.kind;
				if(_g2 == null) {
					var func = _g1;
					var kind = _g2;
					return (kind != haxe_macro_FunctionKind.FArrow ? "function" : "") + this.printFunction(func,kind);
				} else if(_g2._hx_index == 1) {
					var func = _g1;
					var inlined = _g2.inlined;
					var no = _g2.name;
					return (inlined ? "inline " : "") + ("function " + no) + this.printFunction(func);
				} else {
					var func = _g1;
					var kind = _g2;
					return (kind != haxe_macro_FunctionKind.FArrow ? "function" : "") + this.printFunction(func,kind);
				}
				break;
			case 12:
				var _g1 = _g.exprs;
				if(_g1.length == 0) {
					return "{ }";
				} else {
					var el = _g1;
					var old = this.tabs;
					this.tabs += this.tabString;
					var s = "{\n" + this.tabs + this.printExprs(el,";\n" + this.tabs);
					this.tabs = old;
					return s + (";\n" + this.tabs + "}");
				}
				break;
			case 13:
				var e2 = _g.expr;
				var e1 = _g.it;
				return "for (" + this.printExpr(e1) + ") " + this.printExpr(e2);
			case 14:
				var _g1 = _g.eelse;
				var _g2 = _g.eif;
				var _g3 = _g.econd;
				if(_g1 == null) {
					var econd = _g3;
					var eif = _g2;
					return "if (" + this.printExpr(econd) + ") " + this.printExpr(eif);
				} else {
					var econd = _g3;
					var eif = _g2;
					var eelse = _g1;
					return "if (" + this.printExpr(econd) + ") " + this.printExpr(eif) + " else " + this.printExpr(eelse);
				}
				break;
			case 15:
				var _g1 = _g.e;
				var _g2 = _g.econd;
				if(_g.normalWhile) {
					var econd = _g2;
					var e1 = _g1;
					return "while (" + this.printExpr(econd) + ") " + this.printExpr(e1);
				} else {
					var econd = _g2;
					var e1 = _g1;
					return "do " + this.printExpr(e1) + " while (" + this.printExpr(econd) + ")";
				}
				break;
			case 16:
				var edef = _g.edef;
				var cl = _g.cases;
				var e1 = _g.e;
				var old = this.tabs;
				this.tabs += this.tabString;
				var s = "switch " + this.printExpr(e1) + " {\n" + this.tabs;
				var result = new Array(cl.length);
				var _g1 = 0;
				var _g2 = cl.length;
				while(_g1 < _g2) {
					var i = _g1++;
					var c = cl[i];
					result[i] = "case " + _gthis.printExprs(c.values,", ") + (c.guard != null ? " if (" + _gthis.printExpr(c.guard) + "):" : ":") + (c.expr != null ? _gthis.opt(c.expr,$bind(_gthis,_gthis.printExpr)) + ";" : "");
				}
				var s1 = s + result.join("\n" + this.tabs);
				if(edef != null) {
					s1 += "\n" + this.tabs + "default:" + (edef.expr == null ? "" : this.printExpr(edef) + ";");
				}
				this.tabs = old;
				return s1 + ("\n" + this.tabs + "}");
			case 17:
				var cl = _g.catches;
				var e1 = _g.e;
				var tmp = "try " + this.printExpr(e1);
				var result = new Array(cl.length);
				var _g1 = 0;
				var _g2 = cl.length;
				while(_g1 < _g2) {
					var i = _g1++;
					var c = cl[i];
					result[i] = " catch(" + c.name + (c.type == null ? "" : ":" + _gthis.printComplexType(c.type)) + ") " + _gthis.printExpr(c.expr);
				}
				return tmp + result.join("");
			case 18:
				var eo = _g.e;
				return "return" + this.opt(eo,$bind(this,this.printExpr)," ");
			case 19:
				return "break";
			case 20:
				return "continue";
			case 21:
				var e1 = _g.e;
				return "untyped " + this.printExpr(e1);
			case 22:
				var e1 = _g.e;
				return "throw " + this.printExpr(e1);
			case 23:
				var _g1 = _g.e;
				var cto = _g.t;
				var e1 = _g1;
				if(cto != null) {
					return "cast(" + this.printExpr(e1) + ", " + this.printComplexType(cto) + ")";
				} else {
					var e1 = _g1;
					return "cast " + this.printExpr(e1);
				}
				break;
			case 24:
				var _g1 = _g.displayKind;
				var e1 = _g.e;
				return "#DISPLAY(" + this.printExpr(e1) + ")";
			case 25:
				var tp = _g.t;
				return "#DISPLAY(" + this.printTypePath(tp) + ")";
			case 26:
				var eelse = _g.eelse;
				var eif = _g.eif;
				var econd = _g.econd;
				return "" + this.printExpr(econd) + " ? " + this.printExpr(eif) + " : " + this.printExpr(eelse);
			case 27:
				var ct = _g.t;
				var e1 = _g.e;
				return "(" + this.printExpr(e1) + " : " + this.printComplexType(ct) + ")";
			case 28:
				var _g1 = _g.e;
				var _g2 = _g.s;
				var _g = _g2.pos;
				var _g = _g2.params;
				if(_g2.name == ":implicitReturn") {
					var _g = _g1.pos;
					var _g = _g1.expr;
					if(_g._hx_index == 18) {
						var e1 = _g.e;
						return this.printExpr(e1);
					} else {
						var meta = _g2;
						var e1 = _g1;
						return this.printMetadata(meta) + " " + this.printExpr(e1);
					}
				} else {
					var e1 = _g1;
					var meta = _g2;
					return this.printMetadata(meta) + " " + this.printExpr(e1);
				}
				break;
			}
		}
	}
	,printExprs: function(el,sep) {
		var f = $bind(this,this.printExpr);
		var result = new Array(el.length);
		var _g = 0;
		var _g1 = el.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(el[i]);
		}
		return result.join(sep);
	}
	,opt: function(v,f,prefix) {
		if(prefix == null) {
			prefix = "";
		}
		if(v == null) {
			return "";
		} else {
			return prefix + f(v);
		}
	}
	,__class__: haxe_macro_Printer
};
var haxe_rtti_Meta = function() { };
$hxClasses["haxe.rtti.Meta"] = haxe_rtti_Meta;
haxe_rtti_Meta.__name__ = "haxe.rtti.Meta";
haxe_rtti_Meta.getType = function(t) {
	var meta = haxe_rtti_Meta.getMeta(t);
	if(meta == null || meta.obj == null) {
		return { };
	} else {
		return meta.obj;
	}
};
haxe_rtti_Meta.getMeta = function(t) {
	return t.__meta__;
};
var haxeparser_Keyword = $hxEnums["haxeparser.Keyword"] = { __ename__ : true, __constructs__ : ["KwdFunction","KwdClass","KwdVar","KwdIf","KwdElse","KwdWhile","KwdDo","KwdFor","KwdBreak","KwdContinue","KwdReturn","KwdExtends","KwdImplements","KwdImport","KwdSwitch","KwdCase","KwdDefault","KwdStatic","KwdPublic","KwdPrivate","KwdTry","KwdCatch","KwdNew","KwdThis","KwdThrow","KwdExtern","KwdEnum","KwdInterface","KwdUntyped","KwdCast","KwdOverride","KwdTypedef","KwdDynamic","KwdPackage","KwdInline","KwdUsing","KwdNull","KwdTrue","KwdFalse","KwdAbstract","KwdMacro","KwdFinal","KwdOperator","KwdOverload"]
	,KwdFunction: {_hx_index:0,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdClass: {_hx_index:1,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdVar: {_hx_index:2,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdIf: {_hx_index:3,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdElse: {_hx_index:4,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdWhile: {_hx_index:5,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDo: {_hx_index:6,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFor: {_hx_index:7,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdBreak: {_hx_index:8,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdContinue: {_hx_index:9,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdReturn: {_hx_index:10,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtends: {_hx_index:11,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImplements: {_hx_index:12,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImport: {_hx_index:13,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdSwitch: {_hx_index:14,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCase: {_hx_index:15,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDefault: {_hx_index:16,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdStatic: {_hx_index:17,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPublic: {_hx_index:18,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPrivate: {_hx_index:19,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTry: {_hx_index:20,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCatch: {_hx_index:21,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNew: {_hx_index:22,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThis: {_hx_index:23,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThrow: {_hx_index:24,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtern: {_hx_index:25,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdEnum: {_hx_index:26,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInterface: {_hx_index:27,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUntyped: {_hx_index:28,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCast: {_hx_index:29,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOverride: {_hx_index:30,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTypedef: {_hx_index:31,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDynamic: {_hx_index:32,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPackage: {_hx_index:33,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInline: {_hx_index:34,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUsing: {_hx_index:35,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNull: {_hx_index:36,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTrue: {_hx_index:37,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFalse: {_hx_index:38,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdAbstract: {_hx_index:39,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdMacro: {_hx_index:40,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFinal: {_hx_index:41,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOperator: {_hx_index:42,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOverload: {_hx_index:43,__enum__:"haxeparser.Keyword",toString:$estr}
};
var haxeparser_KeywordPrinter = function() { };
$hxClasses["haxeparser.KeywordPrinter"] = haxeparser_KeywordPrinter;
haxeparser_KeywordPrinter.__name__ = "haxeparser.KeywordPrinter";
haxeparser_KeywordPrinter.toString = function(kwd) {
	switch(kwd._hx_index) {
	case 0:
		return "function";
	case 1:
		return "class";
	case 2:
		return "var";
	case 3:
		return "if";
	case 4:
		return "else";
	case 5:
		return "while";
	case 6:
		return "do";
	case 7:
		return "for";
	case 8:
		return "break";
	case 9:
		return "continue";
	case 10:
		return "return";
	case 11:
		return "extends";
	case 12:
		return "implements";
	case 13:
		return "import";
	case 14:
		return "switch";
	case 15:
		return "case";
	case 16:
		return "default";
	case 17:
		return "static";
	case 18:
		return "public";
	case 19:
		return "private";
	case 20:
		return "try";
	case 21:
		return "catch";
	case 22:
		return "new";
	case 23:
		return "this";
	case 24:
		return "throw";
	case 25:
		return "extern";
	case 26:
		return "enum";
	case 27:
		return "interface";
	case 28:
		return "untyped";
	case 29:
		return "cast";
	case 30:
		return "override";
	case 31:
		return "typedef";
	case 32:
		return "dynamic";
	case 33:
		return "package";
	case 34:
		return "inline";
	case 35:
		return "using";
	case 36:
		return "null";
	case 37:
		return "true";
	case 38:
		return "false";
	case 39:
		return "abstract";
	case 40:
		return "macro";
	case 41:
		return "final";
	case 42:
		return "operator";
	case 43:
		return "overload";
	}
};
var haxeparser_TokenDef = $hxEnums["haxeparser.TokenDef"] = { __ename__ : true, __constructs__ : ["Kwd","Const","Sharp","Dollar","Unop","Binop","Comment","CommentLine","IntInterval","Semicolon","Dot","DblDot","Arrow","Comma","BkOpen","BkClose","BrOpen","BrClose","POpen","PClose","Question","At","Eof"]
	,Kwd: ($_=function(k) { return {_hx_index:0,k:k,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["k"],$_)
	,Const: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:2,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Dollar: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Unop: ($_=function(op) { return {_hx_index:4,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Binop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Comment: ($_=function(s) { return {_hx_index:6,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:7,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,IntInterval: ($_=function(s) { return {_hx_index:8,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Semicolon: {_hx_index:9,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Dot: {_hx_index:10,__enum__:"haxeparser.TokenDef",toString:$estr}
	,DblDot: {_hx_index:11,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Arrow: {_hx_index:12,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Comma: {_hx_index:13,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkOpen: {_hx_index:14,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkClose: {_hx_index:15,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrOpen: {_hx_index:16,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrClose: {_hx_index:17,__enum__:"haxeparser.TokenDef",toString:$estr}
	,POpen: {_hx_index:18,__enum__:"haxeparser.TokenDef",toString:$estr}
	,PClose: {_hx_index:19,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Question: {_hx_index:20,__enum__:"haxeparser.TokenDef",toString:$estr}
	,At: {_hx_index:21,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Eof: {_hx_index:22,__enum__:"haxeparser.TokenDef",toString:$estr}
};
var haxeparser_TokenDefPrinter = function() { };
$hxClasses["haxeparser.TokenDefPrinter"] = haxeparser_TokenDefPrinter;
haxeparser_TokenDefPrinter.__name__ = "haxeparser.TokenDefPrinter";
haxeparser_TokenDefPrinter.toString = function(def) {
	switch(def._hx_index) {
	case 0:
		var k = def.k;
		return HxOverrides.substr($hxEnums[k.__enum__].__constructs__[k._hx_index],3,null).toLowerCase();
	case 1:
		var _g = def.c;
		switch(_g._hx_index) {
		case 0:
			var s = _g.v;
			return s;
		case 1:
			var s = _g.f;
			return s;
		case 2:
			var _g1 = _g.kind;
			var s = _g.s;
			return "\"" + s + "\"";
		case 3:
			var s = _g.s;
			return s;
		case 4:
			var opt = _g.opt;
			var r = _g.r;
			return "~/" + r + "/" + opt;
		}
		break;
	case 2:
		var s = def.s;
		return "#" + s;
	case 3:
		var s = def.s;
		return "$" + s;
	case 4:
		var op = def.op;
		return new haxe_macro_Printer("").printUnop(op);
	case 5:
		var op = def.op;
		return new haxe_macro_Printer("").printBinop(op);
	case 6:
		var s = def.s;
		return "/*" + s + "*/";
	case 7:
		var s = def.s;
		return "//" + s;
	case 8:
		var s = def.s;
		return "" + s + "...";
	case 9:
		return ";";
	case 10:
		return ".";
	case 11:
		return ":";
	case 12:
		return "->";
	case 13:
		return ",";
	case 14:
		return "[";
	case 15:
		return "]";
	case 16:
		return "{";
	case 17:
		return "}";
	case 18:
		return "(";
	case 19:
		return ")";
	case 20:
		return "?";
	case 21:
		return "@";
	case 22:
		return "<eof>";
	}
};
haxeparser_TokenDefPrinter.print = function(def) {
	return haxeparser_TokenDefPrinter.toString(def);
};
var haxeparser_Token = function(tok,pos) {
	this.tok = tok;
	this.pos = pos;
};
$hxClasses["haxeparser.Token"] = haxeparser_Token;
haxeparser_Token.__name__ = "haxeparser.Token";
haxeparser_Token.prototype = {
	tok: null
	,pos: null
	,toString: function() {
		return haxeparser_TokenDefPrinter.toString(this.tok);
	}
	,__class__: haxeparser_Token
};
var haxeparser_TypeDef = $hxEnums["haxeparser.TypeDef"] = { __ename__ : true, __constructs__ : ["EClass","EEnum","ETypedef","EAbstract","EStatic","EImport","EUsing"]
	,EClass: ($_=function(d) { return {_hx_index:0,d:d,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["d"],$_)
	,EEnum: ($_=function(d) { return {_hx_index:1,d:d,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["d"],$_)
	,ETypedef: ($_=function(d) { return {_hx_index:2,d:d,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["d"],$_)
	,EAbstract: ($_=function(a) { return {_hx_index:3,a:a,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["a"],$_)
	,EStatic: ($_=function(s) { return {_hx_index:4,s:s,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,EImport: ($_=function(sl,mode) { return {_hx_index:5,sl:sl,mode:mode,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["sl","mode"],$_)
	,EUsing: ($_=function(path) { return {_hx_index:6,path:path,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["path"],$_)
};
var haxeparser_ClassFlag = $hxEnums["haxeparser.ClassFlag"] = { __ename__ : true, __constructs__ : ["HInterface","HExtern","HPrivate","HExtends","HImplements","HFinal","HAbstract"]
	,HInterface: {_hx_index:0,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HExtern: {_hx_index:1,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HPrivate: {_hx_index:2,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HExtends: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxeparser.ClassFlag",toString:$estr}; },$_.__params__ = ["t"],$_)
	,HImplements: ($_=function(t) { return {_hx_index:4,t:t,__enum__:"haxeparser.ClassFlag",toString:$estr}; },$_.__params__ = ["t"],$_)
	,HFinal: {_hx_index:5,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HAbstract: {_hx_index:6,__enum__:"haxeparser.ClassFlag",toString:$estr}
};
var haxeparser_AbstractFlag = $hxEnums["haxeparser.AbstractFlag"] = { __ename__ : true, __constructs__ : ["APrivAbstract","AFromType","AToType","AIsType","AExtern"]
	,APrivAbstract: {_hx_index:0,__enum__:"haxeparser.AbstractFlag",toString:$estr}
	,AFromType: ($_=function(ct) { return {_hx_index:1,ct:ct,__enum__:"haxeparser.AbstractFlag",toString:$estr}; },$_.__params__ = ["ct"],$_)
	,AToType: ($_=function(ct) { return {_hx_index:2,ct:ct,__enum__:"haxeparser.AbstractFlag",toString:$estr}; },$_.__params__ = ["ct"],$_)
	,AIsType: ($_=function(ct) { return {_hx_index:3,ct:ct,__enum__:"haxeparser.AbstractFlag",toString:$estr}; },$_.__params__ = ["ct"],$_)
	,AExtern: {_hx_index:4,__enum__:"haxeparser.AbstractFlag",toString:$estr}
};
var haxeparser_EnumFlag = $hxEnums["haxeparser.EnumFlag"] = { __ename__ : true, __constructs__ : ["EPrivate","EExtern"]
	,EPrivate: {_hx_index:0,__enum__:"haxeparser.EnumFlag",toString:$estr}
	,EExtern: {_hx_index:1,__enum__:"haxeparser.EnumFlag",toString:$estr}
};
var haxeparser_StaticFlag = $hxEnums["haxeparser.StaticFlag"] = { __ename__ : true, __constructs__ : ["SDynamic","SFinal","SInline","SMacro","SPrivate","SOverload"]
	,SDynamic: {_hx_index:0,__enum__:"haxeparser.StaticFlag",toString:$estr}
	,SFinal: {_hx_index:1,__enum__:"haxeparser.StaticFlag",toString:$estr}
	,SInline: {_hx_index:2,__enum__:"haxeparser.StaticFlag",toString:$estr}
	,SMacro: {_hx_index:3,__enum__:"haxeparser.StaticFlag",toString:$estr}
	,SPrivate: {_hx_index:4,__enum__:"haxeparser.StaticFlag",toString:$estr}
	,SOverload: {_hx_index:5,__enum__:"haxeparser.StaticFlag",toString:$estr}
};
var haxeparser_ImportMode = $hxEnums["haxeparser.ImportMode"] = { __ename__ : true, __constructs__ : ["INormal","IAsName","IAll"]
	,INormal: {_hx_index:0,__enum__:"haxeparser.ImportMode",toString:$estr}
	,IAsName: ($_=function(s) { return {_hx_index:1,s:s,__enum__:"haxeparser.ImportMode",toString:$estr}; },$_.__params__ = ["s"],$_)
	,IAll: {_hx_index:2,__enum__:"haxeparser.ImportMode",toString:$estr}
};
var haxeparser_LexerErrorMsg = $hxEnums["haxeparser.LexerErrorMsg"] = { __ename__ : true, __constructs__ : ["UnterminatedString","UnterminatedRegExp","UnclosedComment","UnterminatedEscapeSequence","InvalidEscapeSequence","UnknownEscapeSequence","UnclosedCode"]
	,UnterminatedString: {_hx_index:0,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedRegExp: {_hx_index:1,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnclosedComment: {_hx_index:2,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedEscapeSequence: {_hx_index:3,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,InvalidEscapeSequence: ($_=function(c) { return {_hx_index:4,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_.__params__ = ["c"],$_)
	,UnknownEscapeSequence: ($_=function(c) { return {_hx_index:5,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_.__params__ = ["c"],$_)
	,UnclosedCode: {_hx_index:6,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
};
var haxeparser_LexerError = function(msg,pos) {
	this.msg = msg;
	this.pos = pos;
};
$hxClasses["haxeparser.LexerError"] = haxeparser_LexerError;
haxeparser_LexerError.__name__ = "haxeparser.LexerError";
haxeparser_LexerError.prototype = {
	msg: null
	,pos: null
	,__class__: haxeparser_LexerError
};
var hxparse_Lexer = function(input,sourceName) {
	if(sourceName == null) {
		sourceName = "<null>";
	}
	this.current = "";
	this.input = input;
	this.source = sourceName;
	this.pos = 0;
};
$hxClasses["hxparse.Lexer"] = hxparse_Lexer;
hxparse_Lexer.__name__ = "hxparse.Lexer";
hxparse_Lexer.buildRuleset = function(rules,name) {
	if(name == null) {
		name = "";
	}
	var cases = [];
	var functions = [];
	var eofFunction = null;
	var _g = 0;
	while(_g < rules.length) {
		var rule = rules[_g];
		++_g;
		if(rule.rule == "") {
			eofFunction = rule.func;
		} else {
			cases.push(hxparse_LexEngine.parse(rule.rule));
			functions.push(rule.func);
		}
	}
	return new hxparse_Ruleset(new hxparse_LexEngine(cases).firstState(),functions,eofFunction,name);
};
hxparse_Lexer.prototype = {
	current: null
	,input: null
	,source: null
	,pos: null
	,curPos: function() {
		return new hxparse_Position(this.source,this.pos - this.current.length,this.pos);
	}
	,token: function(ruleset) {
		if(this.pos == this.input.length) {
			if(ruleset.eofFunction != null) {
				return ruleset.eofFunction(this);
			} else {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			}
		}
		var state = ruleset.state;
		var lastMatch = null;
		var lastMatchPos = this.pos;
		var start = this.pos;
		while(true) {
			if(state.finalId > -1) {
				lastMatch = state;
				lastMatchPos = this.pos;
			}
			if(this.pos == this.input.length) {
				break;
			}
			var i = this.input.b[this.pos];
			++this.pos;
			state = state.trans[i];
			if(state == null) {
				break;
			}
		}
		this.pos = lastMatchPos;
		this.current = this.input.getString(start,this.pos - start);
		if(lastMatch == null || lastMatch.finalId == -1) {
			var code = this.input.b[this.pos];
			throw haxe_Exception.thrown(new hxparse_UnexpectedChar(String.fromCodePoint(code),new hxparse_Position(this.source,this.pos - this.current.length,this.pos)));
		}
		return ruleset.functions[lastMatch.finalId](this);
	}
	,__class__: hxparse_Lexer
};
var hxparse_RuleBuilder = function() { };
$hxClasses["hxparse.RuleBuilder"] = hxparse_RuleBuilder;
hxparse_RuleBuilder.__name__ = "hxparse.RuleBuilder";
hxparse_RuleBuilder.__isInterface__ = true;
var hxparse__$LexEngine_CharRange = function(min,max) {
	this.min = min;
	this.max = max;
};
$hxClasses["hxparse._LexEngine.CharRange"] = hxparse__$LexEngine_CharRange;
hxparse__$LexEngine_CharRange.__name__ = "hxparse._LexEngine.CharRange";
hxparse__$LexEngine_CharRange.prototype = {
	min: null
	,max: null
	,__class__: hxparse__$LexEngine_CharRange
};
var hxparse_LexEngine = function(patterns) {
	this.nodes = [];
	this.finals = [];
	this.states = [];
	this.hstates = new haxe_ds_StringMap();
	this.uid = 0;
	var pid = 0;
	var _g = 0;
	while(_g < patterns.length) {
		var p = patterns[_g];
		++_g;
		var id = pid++;
		var f = new hxparse__$LexEngine_Node(this.uid++,id);
		var n = this.initNode(p,f,id);
		this.nodes.push(n);
		this.finals.push(f);
	}
	this.makeState(this.addNodes([],this.nodes));
};
$hxClasses["hxparse.LexEngine"] = hxparse_LexEngine;
hxparse_LexEngine.__name__ = "hxparse.LexEngine";
hxparse_LexEngine.single = function(c) {
	return [new hxparse__$LexEngine_CharRange(c,c)];
};
hxparse_LexEngine.parse = function(pattern) {
	var this1 = haxe_io_Bytes.ofString(pattern);
	var p = hxparse_LexEngine.parseInner(this1);
	if(p == null) {
		throw haxe_Exception.thrown("Invalid pattern '" + pattern + "'");
	}
	return p.pattern;
};
hxparse_LexEngine.next = function(a,b) {
	if(a == hxparse__$LexEngine_Pattern.Empty) {
		return b;
	} else {
		return hxparse__$LexEngine_Pattern.Next(a,b);
	}
};
hxparse_LexEngine.plus = function(r) {
	if(r._hx_index == 4) {
		var r2 = r.p2;
		var r1 = r.p1;
		return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.plus(r2));
	} else {
		return hxparse__$LexEngine_Pattern.Plus(r);
	}
};
hxparse_LexEngine.star = function(r) {
	if(r._hx_index == 4) {
		var r2 = r.p2;
		var r1 = r.p1;
		return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.star(r2));
	} else {
		return hxparse__$LexEngine_Pattern.Star(r);
	}
};
hxparse_LexEngine.opt = function(r) {
	if(r._hx_index == 4) {
		var r2 = r.p2;
		var r1 = r.p1;
		return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.opt(r2));
	} else {
		return hxparse__$LexEngine_Pattern.Choice(r,hxparse__$LexEngine_Pattern.Empty);
	}
};
hxparse_LexEngine.cinter = function(c1,c2) {
	return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),hxparse_LexEngine.ccomplement(c2)));
};
hxparse_LexEngine.cdiff = function(c1,c2) {
	return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),c2));
};
hxparse_LexEngine.ccomplement = function(c) {
	var first = c[0];
	var start = first != null && first.min == -1 ? c.shift().max + 1 : -1;
	var out = [];
	var _g = 0;
	while(_g < c.length) {
		var k = c[_g];
		++_g;
		out.push(new hxparse__$LexEngine_CharRange(start,k.min - 1));
		start = k.max + 1;
	}
	if(start <= 255) {
		out.push(new hxparse__$LexEngine_CharRange(start,255));
	}
	return out;
};
hxparse_LexEngine.cunion = function(ca,cb) {
	var i = 0;
	var j = 0;
	var out = [];
	var a = ca[i++];
	var b = cb[j++];
	while(true) {
		if(a == null) {
			out.push(b);
			while(j < cb.length) out.push(cb[j++]);
			break;
		}
		if(b == null) {
			out.push(a);
			while(i < ca.length) out.push(ca[i++]);
			break;
		}
		if(a.min <= b.min) {
			if(a.max + 1 < b.min) {
				out.push(a);
				a = ca[i++];
			} else if(a.max < b.max) {
				b = new hxparse__$LexEngine_CharRange(a.min,b.max);
				a = ca[i++];
			} else {
				b = cb[j++];
			}
		} else {
			var tmp = ca;
			ca = cb;
			cb = tmp;
			var tmp1 = j;
			j = i;
			i = tmp1;
			var tmp2 = a;
			a = b;
			b = tmp2;
		}
	}
	return out;
};
hxparse_LexEngine.parseInner = function(pattern,i,pDepth) {
	if(pDepth == null) {
		pDepth = 0;
	}
	if(i == null) {
		i = 0;
	}
	var readChar = function() {
		i += 1;
		var c = pattern.b[i - 1];
		if(c != c) {
			c = 92;
		} else if(c == 120) {
			c = Std.parseInt("0x" + pattern.getString(i,2));
			i += 2;
		} else if(c >= 48 && c <= 57) {
			var v = c - 48;
			while(true) {
				var cNext = pattern.b[i];
				if(cNext >= 48 && cNext <= 57) {
					v = v * 10 + (cNext - 48);
					i += 1;
				} else {
					break;
				}
			}
			c = v;
		}
		return c;
	};
	var r = hxparse__$LexEngine_Pattern.Empty;
	var l = pattern.length;
	while(i < l) {
		i += 1;
		var c = pattern.b[i - 1];
		if(c > 255) {
			throw haxe_Exception.thrown(c);
		}
		switch(c) {
		case 40:
			var r2 = hxparse_LexEngine.parseInner(pattern,i,pDepth + 1);
			i = r2.pos;
			r = hxparse_LexEngine.next(r,r2.pattern);
			break;
		case 41:
			if(r == hxparse__$LexEngine_Pattern.Empty) {
				throw haxe_Exception.thrown("Empty group");
			}
			return { pattern : hxparse__$LexEngine_Pattern.Group(r), pos : i};
		case 42:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.star(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 43:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.plus(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 46:
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(hxparse_LexEngine.ALL_CHARS));
			break;
		case 63:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.opt(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 91:
			if(pattern.length > 1) {
				var range = 0;
				var acc = [];
				var not = pattern.b[i] == 94;
				if(not) {
					i += 1;
				}
				while(true) {
					i += 1;
					var c1 = pattern.b[i - 1];
					if(c1 == 93) {
						if(range != 0) {
							return null;
						}
						break;
					} else if(c1 == 45) {
						if(range != 0) {
							return null;
						}
						var last = acc.pop();
						if(last == null) {
							acc.push(new hxparse__$LexEngine_CharRange(c1,c1));
						} else {
							if(last.min != last.max) {
								return null;
							}
							range = last.min;
						}
					} else {
						if(c1 == 92) {
							c1 = readChar();
						}
						if(range == 0) {
							acc.push(new hxparse__$LexEngine_CharRange(c1,c1));
						} else {
							acc.push(new hxparse__$LexEngine_CharRange(range,c1));
							range = 0;
						}
					}
				}
				var g = [];
				var _g = 0;
				while(_g < acc.length) {
					var k = acc[_g];
					++_g;
					g = hxparse_LexEngine.cunion(g,[k]);
				}
				if(not) {
					g = hxparse_LexEngine.cdiff(hxparse_LexEngine.ALL_CHARS,g);
				}
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(g));
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 92:
			c = readChar();
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			break;
		case 124:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				var r21 = hxparse_LexEngine.parseInner(pattern,i);
				return { pattern : hxparse__$LexEngine_Pattern.Choice(r,r21.pattern), pos : r21.pos};
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		default:
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
		}
	}
	if(pDepth != 0) {
		throw haxe_Exception.thrown("Found unclosed parenthesis while parsing \"" + Std.string(pattern) + "\"");
	}
	return { pattern : r, pos : i};
};
hxparse_LexEngine.prototype = {
	uid: null
	,nodes: null
	,finals: null
	,states: null
	,hstates: null
	,firstState: function() {
		return this.states[0];
	}
	,makeState: function(nodes) {
		var _gthis = this;
		var buf_b = "";
		var _g = 0;
		while(_g < nodes.length) {
			var n = nodes[_g];
			++_g;
			buf_b += Std.string(n.id);
			buf_b += String.fromCodePoint(45);
		}
		var key = buf_b;
		var s = this.hstates.h[key];
		if(s != null) {
			return s;
		}
		s = new hxparse_State();
		this.states.push(s);
		this.hstates.h[key] = s;
		var trans = this.getTransitions(nodes);
		var _g = 0;
		while(_g < trans.length) {
			var t = trans[_g];
			++_g;
			var target = this.makeState(t.n);
			var _g1 = 0;
			var _g2 = t.chars;
			while(_g1 < _g2.length) {
				var chr = _g2[_g1];
				++_g1;
				var _g3 = chr.min;
				var _g4 = chr.max + 1;
				while(_g3 < _g4) {
					var i = _g3++;
					s.trans[i] = target;
				}
			}
		}
		var setFinal = function() {
			var _g = 0;
			var _g1 = _gthis.finals;
			while(_g < _g1.length) {
				var f = _g1[_g];
				++_g;
				var _g2 = 0;
				while(_g2 < nodes.length) {
					var n = nodes[_g2];
					++_g2;
					if(n == f) {
						s.finalId = n.pid;
						return;
					}
				}
			}
		};
		if(s.finalId == -1) {
			setFinal();
		}
		return s;
	}
	,getTransitions: function(nodes) {
		var tl = [];
		var _g = 0;
		while(_g < nodes.length) {
			var n = nodes[_g];
			++_g;
			var _g1 = 0;
			var _g2 = n.trans;
			while(_g1 < _g2.length) {
				var t = _g2[_g1];
				++_g1;
				tl.push(t);
			}
		}
		tl.sort(function(t1,t2) {
			return t1.n.id - t2.n.id;
		});
		var t0 = tl[0];
		var _g = 1;
		var _g1 = tl.length;
		while(_g < _g1) {
			var i = _g++;
			var t1 = tl[i];
			if(t0.n == t1.n) {
				tl[i - 1] = null;
				t1 = { chars : hxparse_LexEngine.cunion(t0.chars,t1.chars), n : t1.n};
				tl[i] = t1;
			}
			t0 = t1;
		}
		while(HxOverrides.remove(tl,null)) {
		}
		var allChars = hxparse_LexEngine.EMPTY;
		var allStates = new haxe_ds_List();
		var _g = 0;
		while(_g < tl.length) {
			var t = tl[_g];
			++_g;
			var states = new haxe_ds_List();
			states.push({ chars : hxparse_LexEngine.cdiff(t.chars,allChars), n : [t.n]});
			var _g3_head = allStates.h;
			while(_g3_head != null) {
				var val = _g3_head.item;
				_g3_head = _g3_head.next;
				var s = val;
				var nodes = s.n.slice();
				nodes.push(t.n);
				states.push({ chars : hxparse_LexEngine.cinter(s.chars,t.chars), n : nodes});
				states.push({ chars : hxparse_LexEngine.cdiff(s.chars,t.chars), n : s.n});
			}
			var _g4_head = states.h;
			while(_g4_head != null) {
				var val1 = _g4_head.item;
				_g4_head = _g4_head.next;
				var s1 = val1;
				if(s1.chars.length == 0) {
					states.remove(s1);
				}
			}
			allChars = hxparse_LexEngine.cunion(allChars,t.chars);
			allStates = states;
		}
		var states = [];
		var _g4_head = allStates.h;
		while(_g4_head != null) {
			var val = _g4_head.item;
			_g4_head = _g4_head.next;
			var s = val;
			states.push({ chars : s.chars, n : this.addNodes([],s.n)});
		}
		states.sort(function(s1,s2) {
			var a = s1.chars.length;
			var b = s2.chars.length;
			var _g = 0;
			var _g1 = a < b ? a : b;
			while(_g < _g1) {
				var i = _g++;
				var a1 = s1.chars[i];
				var b1 = s2.chars[i];
				if(a1.min != b1.min) {
					return b1.min - a1.min;
				}
				if(a1.max != b1.max) {
					return b1.max - a1.max;
				}
			}
			if(a < b) {
				return b - a;
			}
			return 0;
		});
		return states;
	}
	,addNode: function(nodes,n) {
		var _g = 0;
		while(_g < nodes.length) {
			var n2 = nodes[_g];
			++_g;
			if(n == n2) {
				return;
			}
		}
		nodes.push(n);
		this.addNodes(nodes,n.epsilon);
	}
	,addNodes: function(nodes,add) {
		var _g = 0;
		while(_g < add.length) {
			var n = add[_g];
			++_g;
			this.addNode(nodes,n);
		}
		return nodes;
	}
	,node: function(pid) {
		return new hxparse__$LexEngine_Node(this.uid++,pid);
	}
	,initNode: function(p,finalId,pid) {
		switch(p._hx_index) {
		case 0:
			return finalId;
		case 1:
			var c = p.c;
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			n.trans.push({ chars : c, n : finalId});
			return n;
		case 2:
			var p1 = p.p;
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			var an = this.initNode(p1,n,pid);
			n.epsilon.push(an);
			n.epsilon.push(finalId);
			return n;
		case 3:
			var p1 = p.p;
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			var an = this.initNode(p1,n,pid);
			n.epsilon.push(an);
			n.epsilon.push(finalId);
			return an;
		case 4:
			var b = p.p2;
			var a = p.p1;
			return this.initNode(a,this.initNode(b,finalId,pid),pid);
		case 5:
			var b = p.p2;
			var a = p.p1;
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			n.epsilon.push(this.initNode(a,finalId,pid));
			n.epsilon.push(this.initNode(b,finalId,pid));
			return n;
		case 6:
			var p1 = p.p;
			return this.initNode(p1,finalId,pid);
		}
	}
	,__class__: hxparse_LexEngine
};
var hxparse__$LexEngine_Pattern = $hxEnums["hxparse._LexEngine.Pattern"] = { __ename__ : true, __constructs__ : ["Empty","Match","Star","Plus","Next","Choice","Group"]
	,Empty: {_hx_index:0,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}
	,Match: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Star: ($_=function(p) { return {_hx_index:2,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
	,Plus: ($_=function(p) { return {_hx_index:3,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
	,Next: ($_=function(p1,p2) { return {_hx_index:4,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p1","p2"],$_)
	,Choice: ($_=function(p1,p2) { return {_hx_index:5,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p1","p2"],$_)
	,Group: ($_=function(p) { return {_hx_index:6,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
};
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var hxparse__$LexEngine_Node = function(id,pid) {
	this.id = id;
	this.pid = pid;
	this.trans = [];
	this.epsilon = [];
};
$hxClasses["hxparse._LexEngine.Node"] = hxparse__$LexEngine_Node;
hxparse__$LexEngine_Node.__name__ = "hxparse._LexEngine.Node";
hxparse__$LexEngine_Node.prototype = {
	id: null
	,pid: null
	,trans: null
	,epsilon: null
	,__class__: hxparse__$LexEngine_Node
};
var hxparse_Ruleset = function(state,functions,eofFunction,name) {
	if(name == null) {
		name = "";
	}
	this.state = state;
	this.functions = functions;
	this.eofFunction = eofFunction;
	this.name = name;
};
$hxClasses["hxparse.Ruleset"] = hxparse_Ruleset;
hxparse_Ruleset.__name__ = "hxparse.Ruleset";
hxparse_Ruleset.prototype = {
	state: null
	,functions: null
	,eofFunction: null
	,name: null
	,__class__: hxparse_Ruleset
};
var hxparse_Position = function(source,min,max) {
	this.psource = source;
	this.pmin = min;
	this.pmax = max;
};
$hxClasses["hxparse.Position"] = hxparse_Position;
hxparse_Position.__name__ = "hxparse.Position";
hxparse_Position.union = function(p1,p2) {
	return new hxparse_Position(p1.psource,p1.pmin < p2.pmin ? p1.pmin : p2.pmin,p1.pmax > p2.pmax ? p1.pmax : p2.pmax);
};
hxparse_Position.prototype = {
	psource: null
	,pmin: null
	,pmax: null
	,toString: function() {
		return "" + this.psource + ":characters " + this.pmin + "-" + this.pmax;
	}
	,getLinePosition: function(input) {
		var lineMin = 1;
		var lineMax = 1;
		var posMin = 0;
		var posMax = 0;
		var cur = 0;
		while(cur < this.pmin) {
			if(input.b[cur] == 10) {
				++lineMin;
				posMin = cur + 1;
			}
			++cur;
		}
		lineMax = lineMin;
		posMax = posMin;
		posMin = cur - posMin;
		while(cur < this.pmax) {
			if(input.b[cur] == 10) {
				++lineMax;
				posMax = cur + 1;
			}
			++cur;
		}
		posMax = cur - posMax;
		return { lineMin : lineMin, lineMax : lineMax, posMin : posMin, posMax : posMax};
	}
	,format: function(input) {
		var linePos = this.getLinePosition(input);
		if(linePos.lineMin != linePos.lineMax) {
			return "" + this.psource + ":lines " + linePos.lineMin + "-" + linePos.lineMax;
		} else {
			return "" + this.psource + ":" + linePos.lineMin + ": characters " + linePos.posMin + "-" + linePos.posMax;
		}
	}
	,__class__: hxparse_Position
};
var haxeparser_HaxeLexer = function(input,sourceName) {
	hxparse_Lexer.call(this,input,sourceName);
};
$hxClasses["haxeparser.HaxeLexer"] = haxeparser_HaxeLexer;
haxeparser_HaxeLexer.__name__ = "haxeparser.HaxeLexer";
haxeparser_HaxeLexer.__interfaces__ = [hxparse_RuleBuilder];
haxeparser_HaxeLexer.mkPos = function(p) {
	return { file : p.psource, min : p.pmin, max : p.pmax};
};
haxeparser_HaxeLexer.mk = function(lexer,td) {
	return new haxeparser_Token(td,haxeparser_HaxeLexer.mkPos(new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos)));
};
haxeparser_HaxeLexer.unescapePos = function(pos,index,length) {
	return { file : pos.file, min : pos.min + index, max : pos.min + index + length};
};
haxeparser_HaxeLexer.unescape = function(s,pos) {
	var b_b = "";
	var i = 0;
	var esc = false;
	while(s.length != i) {
		var c = HxOverrides.cca(s,i);
		if(esc) {
			var iNext = i + 1;
			var _hx_tmp;
			if(c == null) {
				_hx_tmp = c >= 48 && c <= 51;
				if(_hx_tmp == true) {
					iNext += 2;
				} else {
					var c1 = c;
					throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c1)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
				}
			} else {
				switch(c) {
				case 34:case 39:case 92:
					b_b += String.fromCodePoint(c);
					break;
				case 110:
					b_b += "\n";
					break;
				case 114:
					b_b += "\r";
					break;
				case 116:
					b_b += "\t";
					break;
				case 117:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var c2;
						if(s.charAt(i + 1) == "{") {
							var endIndex = s.indexOf("}",i + 3);
							if(endIndex == -1) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedEscapeSequence,{ file : pos.file, min : pos.min + i, max : pos.min + i + 2}));
							}
							var l = endIndex - (i + 2);
							var chars = HxOverrides.substr(s,i + 2,l);
							if(!new EReg("^[0-9a-fA-F]+$","").match(chars)) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
							}
							c2 = Std.parseInt("0x" + chars);
							if(c2 > 1114111) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
							}
							iNext += 2 + l;
						} else {
							var chars1 = HxOverrides.substr(s,i + 1,4);
							if(!new EReg("^[0-9a-fA-F]{4}$","").match(chars1)) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u" + chars1),{ file : pos.file, min : pos.min + i, max : pos.min + i + 5}));
							}
							c2 = Std.parseInt("0x" + chars1);
							iNext += 4;
						}
						b_b += String.fromCodePoint(c2);
					}
					break;
				case 120:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var chars2 = HxOverrides.substr(s,i + 1,2);
						if(!new EReg("^[0-9a-fA-F]{2}$","").match(chars2)) {
							throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\x" + chars2),{ file : pos.file, min : pos.min + i, max : pos.min + i + 3}));
						}
						var c3 = Std.parseInt("0x" + chars2);
						b_b += String.fromCodePoint(c3);
						iNext += 2;
					}
					break;
				default:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var c4 = c;
						throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c4)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
					}
				}
			}
			esc = false;
			i = iNext;
		} else if(c == null) {
			b_b += String.fromCodePoint(c);
			++i;
		} else if(c == 92) {
			++i;
			esc = true;
		} else {
			b_b += String.fromCodePoint(c);
			++i;
		}
	}
	return b_b;
};
haxeparser_HaxeLexer.__super__ = hxparse_Lexer;
haxeparser_HaxeLexer.prototype = $extend(hxparse_Lexer.prototype,{
	__class__: haxeparser_HaxeLexer
});
var haxeparser_ParserErrorMsg = $hxEnums["haxeparser.ParserErrorMsg"] = { __ename__ : true, __constructs__ : ["MissingSemicolon","MissingType","DuplicateDefault","UnclosedMacro","Unimplemented","Custom","SharpError"]
	,MissingSemicolon: {_hx_index:0,__enum__:"haxeparser.ParserErrorMsg",toString:$estr}
	,MissingType: {_hx_index:1,__enum__:"haxeparser.ParserErrorMsg",toString:$estr}
	,DuplicateDefault: {_hx_index:2,__enum__:"haxeparser.ParserErrorMsg",toString:$estr}
	,UnclosedMacro: {_hx_index:3,__enum__:"haxeparser.ParserErrorMsg",toString:$estr}
	,Unimplemented: {_hx_index:4,__enum__:"haxeparser.ParserErrorMsg",toString:$estr}
	,Custom: ($_=function(s) { return {_hx_index:5,s:s,__enum__:"haxeparser.ParserErrorMsg",toString:$estr}; },$_.__params__ = ["s"],$_)
	,SharpError: ($_=function(s) { return {_hx_index:6,s:s,__enum__:"haxeparser.ParserErrorMsg",toString:$estr}; },$_.__params__ = ["s"],$_)
};
var haxeparser_ParserError = function(message,pos) {
	this.msg = message;
	this.pos = pos;
};
$hxClasses["haxeparser.ParserError"] = haxeparser_ParserError;
haxeparser_ParserError.__name__ = "haxeparser.ParserError";
haxeparser_ParserError.prototype = {
	msg: null
	,pos: null
	,__class__: haxeparser_ParserError
};
var haxeparser_SmallType = $hxEnums["haxeparser.SmallType"] = { __ename__ : true, __constructs__ : ["SNull","SBool","SFloat","SString"]
	,SNull: {_hx_index:0,__enum__:"haxeparser.SmallType",toString:$estr}
	,SBool: ($_=function(b) { return {_hx_index:1,b:b,__enum__:"haxeparser.SmallType",toString:$estr}; },$_.__params__ = ["b"],$_)
	,SFloat: ($_=function(f) { return {_hx_index:2,f:f,__enum__:"haxeparser.SmallType",toString:$estr}; },$_.__params__ = ["f"],$_)
	,SString: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxeparser.SmallType",toString:$estr}; },$_.__params__ = ["s"],$_)
};
var hxparse_Parser_$hxparse_$LexerTokenSource_$haxeparser_$Token_$haxeparser_$Token = function(stream) {
	this.stream = stream;
};
$hxClasses["hxparse.Parser_hxparse_LexerTokenSource_haxeparser_Token_haxeparser_Token"] = hxparse_Parser_$hxparse_$LexerTokenSource_$haxeparser_$Token_$haxeparser_$Token;
hxparse_Parser_$hxparse_$LexerTokenSource_$haxeparser_$Token_$haxeparser_$Token.__name__ = "hxparse.Parser_hxparse_LexerTokenSource_haxeparser_Token_haxeparser_Token";
hxparse_Parser_$hxparse_$LexerTokenSource_$haxeparser_$Token_$haxeparser_$Token.prototype = {
	last: null
	,stream: null
	,token: null
	,peek: function(n) {
		if(this.token == null) {
			this.token = new haxe_ds_GenericCell(this.stream.token(),null);
			--n;
		}
		var tok = this.token;
		while(n > 0) {
			if(tok.next == null) {
				tok.next = new haxe_ds_GenericCell(this.stream.token(),null);
			}
			tok = tok.next;
			--n;
		}
		return tok.elt;
	}
	,junk: function() {
		this.last = this.token.elt;
		this.token = this.token.next;
	}
	,curPos: function() {
		return this.stream.curPos();
	}
	,parseSeparated: function(separatorFunc,f) {
		var acc = [];
		while(true) {
			try {
				acc.push(f());
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
					break;
				} else {
					throw _g;
				}
			}
			if(separatorFunc(this.peek(0))) {
				this.last = this.token.elt;
				this.token = this.token.next;
			} else {
				break;
			}
		}
		return acc;
	}
	,parseOptional: function(f) {
		try {
			return f();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return null;
			} else {
				throw _g;
			}
		}
	}
	,parseRepeat: function(f) {
		var acc = [];
		while(true) try {
			acc.push(f());
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return acc;
			} else {
				throw _g;
			}
		}
	}
	,parseExpect: function(f) {
		try {
			return f();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			} else {
				throw _g;
			}
		}
	}
	,noMatch: function() {
		return new hxparse_NoMatch(this.stream.curPos(),this.peek(0));
	}
	,unexpected: function() {
		throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
	}
	,__class__: hxparse_Parser_$hxparse_$LexerTokenSource_$haxeparser_$Token_$haxeparser_$Token
};
var hxparse_ParserBuilder = function() { };
$hxClasses["hxparse.ParserBuilder"] = hxparse_ParserBuilder;
hxparse_ParserBuilder.__name__ = "hxparse.ParserBuilder";
hxparse_ParserBuilder.__isInterface__ = true;
var haxeparser_HaxeCondParser = function(stream) {
	hxparse_Parser_$hxparse_$LexerTokenSource_$haxeparser_$Token_$haxeparser_$Token.call(this,stream);
};
$hxClasses["haxeparser.HaxeCondParser"] = haxeparser_HaxeCondParser;
haxeparser_HaxeCondParser.__name__ = "haxeparser.HaxeCondParser";
haxeparser_HaxeCondParser.__interfaces__ = [hxparse_ParserBuilder];
haxeparser_HaxeCondParser.__super__ = hxparse_Parser_$hxparse_$LexerTokenSource_$haxeparser_$Token_$haxeparser_$Token;
haxeparser_HaxeCondParser.prototype = $extend(hxparse_Parser_$hxparse_$LexerTokenSource_$haxeparser_$Token_$haxeparser_$Token.prototype,{
	parseMacroCond: function(allowOp) {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		switch(_g2._hx_index) {
		case 0:
			var p = _g1;
			var k = _g2.k;
			this.last = this.token.elt;
			this.token = this.token.next;
			return this.parseMacroIdent(allowOp,haxeparser_HaxeParser.keywordString(k),p);
		case 1:
			var _g = _g2.c;
			switch(_g._hx_index) {
			case 0:
				var p = _g1;
				var s = _g.v;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { tk : haxe_ds_Option.None, expr : { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CInt(s)), pos : p}};
			case 1:
				var p = _g1;
				var s = _g.f;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { tk : haxe_ds_Option.None, expr : { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CFloat(s)), pos : p}};
			case 2:
				var p = _g1;
				var qs = _g.kind;
				var s = _g.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { tk : haxe_ds_Option.None, expr : { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString(s,qs)), pos : p}};
			case 3:
				var p = _g1;
				var t = _g.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.parseMacroIdent(allowOp,t,p);
			default:
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
			break;
		case 4:
			var p = _g1;
			var op = _g2.op;
			this.last = this.token.elt;
			this.token = this.token.next;
			var o = this.parseMacroCond(allowOp);
			return { tk : o.tk, expr : haxeparser_HaxeParser.makeUnop(op,o.expr,p)};
		case 18:
			var p1 = _g1;
			this.last = this.token.elt;
			this.token = this.token.next;
			var o = this.parseMacroCond(true);
			var _g = this.peek(0);
			if(_g.tok._hx_index == 19) {
				var p2 = _g.pos;
				this.last = this.token.elt;
				this.token = this.token.next;
				var e = { expr : haxe_macro_ExprDef.EParenthesis(o.expr), pos : haxeparser_HaxeParser.punion(p1,p2)};
				if(allowOp) {
					return this.parseMacroOp(e);
				} else {
					return { tk : haxe_ds_Option.None, expr : e};
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
			break;
		default:
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseMacroIdent: function(allowOp,t,p) {
		var e = { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent(t)), pos : p};
		if(!allowOp) {
			return { tk : haxe_ds_Option.None, expr : e};
		} else {
			return this.parseMacroOp(e);
		}
	}
	,parseMacroOp: function(e) {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 5) {
			var op = _g1.op;
			this.last = this.token.elt;
			this.token = this.token.next;
			var _g1 = this.peek(0);
			var _g2 = _g1.pos;
			var _g2 = _g1.tok;
			if(_g2._hx_index == 5) {
				if(_g2.op._hx_index == 4) {
					if(op == haxe_macro_Binop.OpGt) {
						this.last = this.token.elt;
						this.token = this.token.next;
						op = haxe_macro_Binop.OpGte;
					}
				}
			}
			var o = this.parseMacroCond(true);
			return { tk : o.tk, expr : haxeparser_HaxeParser.makeBinop(op,e,o.expr)};
		} else {
			var tk = _g;
			return { tk : haxe_ds_Option.Some(tk), expr : e};
		}
	}
	,__class__: haxeparser_HaxeCondParser
});
var haxeparser_HaxeTokenSource = function(lexer,defines) {
	this.lexer = lexer;
	this.mstack = [];
	this.defines = defines;
	this.skipstates = [0];
	this.rawSource = new hxparse_LexerTokenSource(lexer,haxeparser_HaxeLexer.sharp_token);
	this.condParser = new haxeparser_HaxeCondParser(this.rawSource);
};
$hxClasses["haxeparser.HaxeTokenSource"] = haxeparser_HaxeTokenSource;
haxeparser_HaxeTokenSource.__name__ = "haxeparser.HaxeTokenSource";
haxeparser_HaxeTokenSource.prototype = {
	lexer: null
	,mstack: null
	,skipstates: null
	,defines: null
	,rawSource: null
	,condParser: null
	,lexerToken: function() {
		return this.lexer.token(haxeparser_HaxeLexer.tok);
	}
	,getSt: function() {
		return this.skipstates[this.skipstates.length - 1];
	}
	,setSt: function(s) {
		this.skipstates[this.skipstates.length - 1] = s;
	}
	,pushSt: function(s) {
		this.skipstates.push(s);
	}
	,popSt: function() {
		if(this.skipstates.length > 1) {
			return this.skipstates.pop();
		} else {
			throw haxe_Exception.thrown("unexpected #end");
		}
	}
	,token: function() {
		while(true) {
			var tk = this.lexerToken();
			var state = this.skipstates[this.skipstates.length - 1];
			var _g = tk.tok;
			switch(_g._hx_index) {
			case 2:
				switch(_g.s) {
				case "else":
					switch(state) {
					case 0:
						this.skipstates[this.skipstates.length - 1] = 2;
						break;
					case 1:
						this.skipstates[this.skipstates.length - 1] = 0;
						break;
					case 2:
						break;
					default:
					}
					break;
				case "elseif":
					switch(state) {
					case 0:
						this.skipstates[this.skipstates.length - 1] = 2;
						break;
					case 1:
						var o = this.condParser.parseMacroCond(false);
						var s = this.isTrue(this.eval(o.expr)) ? 0 : 1;
						this.skipstates[this.skipstates.length - 1] = s;
						break;
					case 2:
						break;
					default:
					}
					break;
				case "end":
					this.mstack.pop();
					if(this.skipstates.length > 1) {
						this.skipstates.pop();
					} else {
						throw haxe_Exception.thrown("unexpected #end");
					}
					break;
				case "error":
					switch(state) {
					case 0:
						var nextTok = this.lexerToken();
						var _g1 = nextTok.tok;
						if(_g1._hx_index == 1) {
							var _g2 = _g1.c;
							if(_g2._hx_index == 2) {
								var _g3 = _g2.kind;
								var str = _g2.s;
								throw haxe_Exception.thrown(new haxeparser_ParserError(haxeparser_ParserErrorMsg.SharpError(str),tk.pos));
							} else {
								throw haxe_Exception.thrown(new haxeparser_ParserError(haxeparser_ParserErrorMsg.Unimplemented,tk.pos));
							}
						} else {
							throw haxe_Exception.thrown(new haxeparser_ParserError(haxeparser_ParserErrorMsg.Unimplemented,tk.pos));
						}
						break;
					case 2:
						break;
					default:
					}
					break;
				case "if":
					switch(state) {
					case 0:
						this.mstack.push(tk.pos);
						var o1 = this.condParser.parseMacroCond(false);
						var s1 = this.isTrue(this.eval(o1.expr)) ? 0 : 1;
						this.skipstates.push(s1);
						break;
					case 1:case 2:
						this.deepSkip();
						break;
					default:
					}
					break;
				case "line":
					break;
				default:
					switch(state) {
					case 0:
						return tk;
					case 2:
						break;
					default:
					}
				}
				break;
			case 6:
				var _g4 = _g.s;
				break;
			case 7:
				var _g5 = _g.s;
				break;
			case 22:
				if(state == 0) {
					return tk;
				} else {
					return tk;
				}
				break;
			default:
				if(state == 0) {
					return tk;
				}
			}
		}
	}
	,enterMacro: function() {
		var o = this.condParser.parseMacroCond(false);
		return this.isTrue(this.eval(o.expr));
	}
	,deepSkip: function() {
		var lvl = 1;
		while(true) {
			var tk = this.lexerToken();
			var _g = tk.tok;
			switch(_g._hx_index) {
			case 2:
				switch(_g.s) {
				case "end":
					--lvl;
					if(lvl == 0) {
						return;
					}
					break;
				case "if":
					++lvl;
					break;
				default:
				}
				break;
			case 22:
				throw haxe_Exception.thrown("unclosed macro");
			default:
			}
		}
	}
	,isTrue: function(a) {
		switch(a._hx_index) {
		case 0:
			return false;
		case 1:
			if(a.b == false) {
				return false;
			} else {
				return true;
			}
			break;
		case 2:
			if(a.f == 0.0) {
				return false;
			} else {
				return true;
			}
			break;
		case 3:
			if(a.s == "") {
				return false;
			} else {
				return true;
			}
			break;
		}
	}
	,compare: function(a,b) {
		switch(a._hx_index) {
		case 0:
			if(b._hx_index == 0) {
				return 0;
			} else {
				return 0;
			}
			break;
		case 1:
			if(b._hx_index == 1) {
				var a1 = a.b;
				var b1 = b.b;
				return Reflect.compare(a1,b1);
			} else {
				return 0;
			}
			break;
		case 2:
			var _g = a.f;
			switch(b._hx_index) {
			case 2:
				var a1 = _g;
				var b1 = b.f;
				return Reflect.compare(a1,b1);
			case 3:
				var a1 = _g;
				var b1 = b.s;
				return Reflect.compare(a1,parseFloat(b1));
			default:
				return 0;
			}
			break;
		case 3:
			var _g = a.s;
			switch(b._hx_index) {
			case 2:
				var a = _g;
				var b1 = b.f;
				return Reflect.compare(parseFloat(a),b1);
			case 3:
				var a = _g;
				var b1 = b.s;
				return Reflect.compare(a,b1);
			default:
				return 0;
			}
			break;
		}
	}
	,'eval': function(e) {
		var _g = e.expr;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				var f = _g1.v;
				return haxeparser_SmallType.SFloat(parseFloat(f));
			case 1:
				var f = _g1.f;
				return haxeparser_SmallType.SFloat(parseFloat(f));
			case 2:
				var _g2 = _g1.kind;
				var s = _g1.s;
				return haxeparser_SmallType.SString(s);
			case 3:
				var s = _g1.s;
				if(Object.prototype.hasOwnProperty.call(this.defines.h,s)) {
					return haxeparser_SmallType.SString(s);
				} else {
					return haxeparser_SmallType.SNull;
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid condition expression");
			}
			break;
		case 2:
			var _g1 = _g.e2;
			var _g2 = _g.e1;
			var _g3 = _g.op;
			switch(_g3._hx_index) {
			case 14:
				var e2 = _g1;
				var e1 = _g2;
				return haxeparser_SmallType.SBool(this.isTrue(this.eval(e1)) && this.isTrue(this.eval(e2)));
			case 15:
				var e2 = _g1;
				var e1 = _g2;
				return haxeparser_SmallType.SBool(this.isTrue(this.eval(e1)) || this.isTrue(this.eval(e2)));
			default:
				var e2 = _g1;
				var e1 = _g2;
				var op = _g3;
				var v1 = this.eval(e1);
				var v2 = this.eval(e2);
				var cmp = this.compare(v1,v2);
				var val;
				switch(op._hx_index) {
				case 5:
					val = cmp == 0;
					break;
				case 6:
					val = cmp != 0;
					break;
				case 7:
					val = cmp > 0;
					break;
				case 8:
					val = cmp >= 0;
					break;
				case 9:
					val = cmp < 0;
					break;
				case 10:
					val = cmp <= 0;
					break;
				default:
					throw haxe_Exception.thrown("Unsupported operation");
				}
				return haxeparser_SmallType.SBool(val);
			}
			break;
		case 4:
			var e = _g.e;
			return this.eval(e);
		case 9:
			var _g1 = _g.postFix;
			if(_g.op._hx_index == 2) {
				var e = _g.e;
				return haxeparser_SmallType.SBool(!this.isTrue(this.eval(e)));
			} else {
				throw haxe_Exception.thrown("Invalid condition expression");
			}
			break;
		default:
			throw haxe_Exception.thrown("Invalid condition expression");
		}
	}
	,curPos: function() {
		var _this = this.lexer;
		return new hxparse_Position(_this.source,_this.pos - _this.current.length,_this.pos);
	}
	,__class__: haxeparser_HaxeTokenSource
};
var hxparse_Parser_$haxeparser_$HaxeTokenSource_$haxeparser_$Token = function(stream) {
	this.stream = stream;
};
$hxClasses["hxparse.Parser_haxeparser_HaxeTokenSource_haxeparser_Token"] = hxparse_Parser_$haxeparser_$HaxeTokenSource_$haxeparser_$Token;
hxparse_Parser_$haxeparser_$HaxeTokenSource_$haxeparser_$Token.__name__ = "hxparse.Parser_haxeparser_HaxeTokenSource_haxeparser_Token";
hxparse_Parser_$haxeparser_$HaxeTokenSource_$haxeparser_$Token.prototype = {
	last: null
	,stream: null
	,token: null
	,peek: function(n) {
		if(this.token == null) {
			this.token = new haxe_ds_GenericCell(this.stream.token(),null);
			--n;
		}
		var tok = this.token;
		while(n > 0) {
			if(tok.next == null) {
				tok.next = new haxe_ds_GenericCell(this.stream.token(),null);
			}
			tok = tok.next;
			--n;
		}
		return tok.elt;
	}
	,junk: function() {
		this.last = this.token.elt;
		this.token = this.token.next;
	}
	,curPos: function() {
		return this.stream.curPos();
	}
	,parseSeparated: function(separatorFunc,f) {
		var acc = [];
		while(true) {
			try {
				acc.push(f());
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
					break;
				} else {
					throw _g;
				}
			}
			if(separatorFunc(this.peek(0))) {
				this.last = this.token.elt;
				this.token = this.token.next;
			} else {
				break;
			}
		}
		return acc;
	}
	,parseOptional: function(f) {
		try {
			return f();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return null;
			} else {
				throw _g;
			}
		}
	}
	,parseRepeat: function(f) {
		var acc = [];
		while(true) try {
			acc.push(f());
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return acc;
			} else {
				throw _g;
			}
		}
	}
	,parseExpect: function(f) {
		try {
			return f();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			} else {
				throw _g;
			}
		}
	}
	,noMatch: function() {
		return new hxparse_NoMatch(this.stream.curPos(),this.peek(0));
	}
	,unexpected: function() {
		throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
	}
	,__class__: hxparse_Parser_$haxeparser_$HaxeTokenSource_$haxeparser_$Token
};
var haxeparser_HaxeParser = function(input,sourceName) {
	this.doResume = false;
	this.defines = new haxe_ds_StringMap();
	this.defines.h["true"] = true;
	var lexer = new haxeparser_HaxeLexer(input,sourceName);
	var ts = new haxeparser_HaxeTokenSource(lexer,this.defines);
	hxparse_Parser_$haxeparser_$HaxeTokenSource_$haxeparser_$Token.call(this,ts);
	this.inMacro = false;
	this.doc = "";
};
$hxClasses["haxeparser.HaxeParser"] = haxeparser_HaxeParser;
haxeparser_HaxeParser.__name__ = "haxeparser.HaxeParser";
haxeparser_HaxeParser.__interfaces__ = [hxparse_ParserBuilder];
haxeparser_HaxeParser.keywordString = function(k) {
	return HxOverrides.substr(Std.string(k),3,null).toLowerCase();
};
haxeparser_HaxeParser.punion = function(p1,p2) {
	return { file : p1.file, min : p1.min < p2.min ? p1.min : p2.min, max : p1.max > p2.max ? p1.max : p2.max};
};
haxeparser_HaxeParser.quoteIdent = function(s) {
	return s;
};
haxeparser_HaxeParser.isLowerIdent = function(s) {
	var loop = null;
	loop = function(p) {
		var c = HxOverrides.cca(s,p);
		if(c >= 97 && c <= 122) {
			return true;
		} else if(c == 95) {
			if(p + 1 < s.length) {
				return loop(p + 1);
			} else {
				return true;
			}
		} else {
			return false;
		}
	};
	return loop(0);
};
haxeparser_HaxeParser.isPostfix = function(e,u) {
	switch(u._hx_index) {
	case 0:case 1:case 2:
		var _g = e.expr;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.c;
			return true;
		case 1:
			var _g1 = _g.e2;
			var _g1 = _g.e1;
			return true;
		case 3:
			var _g1 = _g.field;
			var _g1 = _g.e;
			return true;
		default:
			return false;
		}
		break;
	case 3:case 4:
		return false;
	}
};
haxeparser_HaxeParser.isPrefix = function(u) {
	switch(u._hx_index) {
	case 0:case 1:
		return true;
	case 2:case 3:case 4:
		return true;
	}
};
haxeparser_HaxeParser.precedence = function(op) {
	var left = true;
	var right = false;
	switch(op._hx_index) {
	case 0:case 3:
		return { p : 3, left : left};
	case 1:case 2:
		return { p : 2, left : left};
	case 4:
		return { p : 11, left : right};
	case 5:case 6:case 7:case 8:case 9:case 10:
		return { p : 6, left : left};
	case 11:case 12:case 13:
		return { p : 5, left : left};
	case 14:
		return { p : 8, left : left};
	case 15:
		return { p : 9, left : left};
	case 16:case 17:case 18:
		return { p : 4, left : left};
	case 19:
		return { p : 1, left : left};
	case 20:
		var _g = op.op;
		return { p : 11, left : right};
	case 21:
		return { p : 7, left : left};
	case 22:
		return { p : 10, left : left};
	case 23:
		return { p : 0, left : right};
	}
};
haxeparser_HaxeParser.isNotAssign = function(op) {
	switch(op._hx_index) {
	case 4:
		return false;
	case 20:
		var _g = op.op;
		return false;
	default:
		return true;
	}
};
haxeparser_HaxeParser.isDollarIdent = function(e) {
	var _g = e.expr;
	if(_g._hx_index == 0) {
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var n = _g1.s;
			if(HxOverrides.cca(n,0) == 36) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	} else {
		return false;
	}
};
haxeparser_HaxeParser.swap = function(op1,op2) {
	var i1 = haxeparser_HaxeParser.precedence(op1);
	var i2 = haxeparser_HaxeParser.precedence(op2);
	if(i1.left) {
		return i1.p <= i2.p;
	} else {
		return false;
	}
};
haxeparser_HaxeParser.makeBinop = function(op,e,e2) {
	var _g = e2.expr;
	switch(_g._hx_index) {
	case 2:
		var _e2 = _g.e2;
		var _e = _g.e1;
		var _op = _g.op;
		if(haxeparser_HaxeParser.swap(op,_op)) {
			var _e1 = haxeparser_HaxeParser.makeBinop(op,e,_e);
			return { expr : haxe_macro_ExprDef.EBinop(_op,_e1,_e2), pos : haxeparser_HaxeParser.punion(_e1.pos,_e2.pos)};
		} else {
			return { expr : haxe_macro_ExprDef.EBinop(op,e,e2), pos : haxeparser_HaxeParser.punion(e.pos,e2.pos)};
		}
		break;
	case 26:
		var e3 = _g.eelse;
		var e21 = _g.eif;
		var e1 = _g.econd;
		if(haxeparser_HaxeParser.isNotAssign(op)) {
			var e4 = haxeparser_HaxeParser.makeBinop(op,e,e1);
			return { expr : haxe_macro_ExprDef.ETernary(e4,e21,e3), pos : haxeparser_HaxeParser.punion(e4.pos,e3.pos)};
		} else {
			return { expr : haxe_macro_ExprDef.EBinop(op,e,e2), pos : haxeparser_HaxeParser.punion(e.pos,e2.pos)};
		}
		break;
	default:
		return { expr : haxe_macro_ExprDef.EBinop(op,e,e2), pos : haxeparser_HaxeParser.punion(e.pos,e2.pos)};
	}
};
haxeparser_HaxeParser.makeUnop = function(op,e,p1) {
	var _g = e.expr;
	switch(_g._hx_index) {
	case 2:
		var e2 = _g.e2;
		var e1 = _g.e1;
		var bop = _g.op;
		return { expr : haxe_macro_ExprDef.EBinop(bop,haxeparser_HaxeParser.makeUnop(op,e1,p1),e2), pos : haxeparser_HaxeParser.punion(p1,e1.pos)};
	case 26:
		var e3 = _g.eelse;
		var e2 = _g.eif;
		var e1 = _g.econd;
		return { expr : haxe_macro_ExprDef.ETernary(haxeparser_HaxeParser.makeUnop(op,e1,p1),e2,e3), pos : haxeparser_HaxeParser.punion(p1,e.pos)};
	default:
		return { expr : haxe_macro_ExprDef.EUnop(op,false,e), pos : haxeparser_HaxeParser.punion(p1,e.pos)};
	}
};
haxeparser_HaxeParser.makeMeta = function(name,params,e,p1) {
	var _g = e.expr;
	switch(_g._hx_index) {
	case 2:
		var e2 = _g.e2;
		var e1 = _g.e1;
		var bop = _g.op;
		return { expr : haxe_macro_ExprDef.EBinop(bop,haxeparser_HaxeParser.makeMeta(name,params,e1,p1),e2), pos : haxeparser_HaxeParser.punion(p1,e1.pos)};
	case 26:
		var e3 = _g.eelse;
		var e2 = _g.eif;
		var e1 = _g.econd;
		return { expr : haxe_macro_ExprDef.ETernary(haxeparser_HaxeParser.makeMeta(name,params,e1,p1),e2,e3), pos : haxeparser_HaxeParser.punion(p1,e.pos)};
	default:
		var tmp = haxeparser_HaxeParser.punion(p1,e.pos);
		return { expr : haxe_macro_ExprDef.EMeta({ name : name, params : params, pos : p1},e), pos : tmp};
	}
};
haxeparser_HaxeParser.makeIs = function(e,t,p,p_is) {
	var e_is = { expr : haxe_macro_ExprDef.EField({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("Std")), pos : haxeparser_HaxeParser.nullPos},"is"), pos : p_is};
	var e2 = haxeparser_HaxeParser.exprOfTypePath(t.pack,t.name,p);
	return { expr : haxe_macro_ExprDef.ECall(e_is,[e,e2]), pos : p};
};
haxeparser_HaxeParser.exprOfTypePath = function(pack,name,p) {
	if(pack.length <= 0) {
		return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent(name)), pos : p};
	}
	var e = { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent(pack.pop())), pos : p};
	var _g = 0;
	while(_g < pack.length) {
		var pa = pack[_g];
		++_g;
		e = { expr : haxe_macro_ExprDef.EField(e,pa), pos : p};
	}
	return { expr : haxe_macro_ExprDef.EField(e,name), pos : p};
};
haxeparser_HaxeParser.apush = function(a,t) {
	a.push(t);
	return a;
};
haxeparser_HaxeParser.aunshift = function(a,t) {
	a.unshift(t);
	return a;
};
haxeparser_HaxeParser.__super__ = hxparse_Parser_$haxeparser_$HaxeTokenSource_$haxeparser_$Token;
haxeparser_HaxeParser.prototype = $extend(hxparse_Parser_$haxeparser_$HaxeTokenSource_$haxeparser_$Token.prototype,{
	defines: null
	,doResume: null
	,doc: null
	,inMacro: null
	,define: function(flag,value) {
		this.defines.h[flag] = value;
	}
	,parse: function() {
		var res = this.parseFile();
		if(this.stream.mstack.length != 0) {
			throw haxe_Exception.thrown(new haxeparser_ParserError(haxeparser_ParserErrorMsg.UnclosedMacro,this.stream.mstack[this.stream.mstack.length - 1]));
		}
		return res;
	}
	,psep: function(sep,f) {
		var acc = [];
		while(true) try {
			acc.push(f());
			var _g = this.peek(0);
			var _g1 = _g.pos;
			var sep2 = _g.tok;
			if(sep2 == sep) {
				this.last = this.token.elt;
				this.token = this.token.next;
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} catch( _g2 ) {
			haxe_NativeStackTrace.lastError = _g2;
			if(((haxe_Exception.caught(_g2).unwrap()) instanceof hxparse_NoMatch)) {
				break;
			} else {
				throw _g2;
			}
		}
		return acc;
	}
	,ident: function() {
		var _g = this.peek(0);
		var _g1 = _g.tok;
		if(_g1._hx_index == 1) {
			var _g2 = _g1.c;
			if(_g2._hx_index == 3) {
				var p = _g.pos;
				var i = _g2.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { name : i, pos : p};
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,dollarIdent: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		switch(_g2._hx_index) {
		case 1:
			var _g = _g2.c;
			if(_g._hx_index == 3) {
				var p = _g1;
				var i = _g.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { name : i, pos : p};
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
			break;
		case 3:
			var p = _g1;
			var i = _g2.s;
			this.last = this.token.elt;
			this.token = this.token.next;
			return { name : "$" + i, pos : p};
		default:
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,dollarIdentMacro: function(pack) {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		switch(_g2._hx_index) {
		case 1:
			var _g = _g2.c;
			if(_g._hx_index == 3) {
				var p = _g1;
				var i = _g.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { name : i, pos : p};
			} else {
				var _g = this.peek(0);
				var _g3 = _g.tok;
				if(_g3._hx_index == 0) {
					if(_g3.k._hx_index == 40) {
						var p = _g.pos;
						if(pack.length > 0) {
							this.last = this.token.elt;
							this.token = this.token.next;
							return { name : "macro", pos : p};
						} else {
							var _g = this.peek(0);
							var _g3 = _g.tok;
							if(_g3._hx_index == 0) {
								if(_g3.k._hx_index == 25) {
									var p = _g.pos;
									if(pack.length > 0) {
										this.last = this.token.elt;
										this.token = this.token.next;
										return { name : "extern", pos : p};
									} else {
										var _g = this.peek(0);
										var _g3 = _g.tok;
										if(_g3._hx_index == 0) {
											if(_g3.k._hx_index == 0) {
												var p = _g.pos;
												if(pack.length > 0) {
													this.last = this.token.elt;
													this.token = this.token.next;
													return { name : "function", pos : p};
												} else {
													throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
												}
											} else {
												throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
											}
										} else {
											throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
										}
									}
								} else {
									var _g = this.peek(0);
									var _g3 = _g.tok;
									if(_g3._hx_index == 0) {
										if(_g3.k._hx_index == 0) {
											var p = _g.pos;
											if(pack.length > 0) {
												this.last = this.token.elt;
												this.token = this.token.next;
												return { name : "function", pos : p};
											} else {
												throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
											}
										} else {
											throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								}
							} else {
								var _g = this.peek(0);
								var _g3 = _g.tok;
								if(_g3._hx_index == 0) {
									if(_g3.k._hx_index == 0) {
										var p = _g.pos;
										if(pack.length > 0) {
											this.last = this.token.elt;
											this.token = this.token.next;
											return { name : "function", pos : p};
										} else {
											throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							}
						}
					} else {
						var _g = this.peek(0);
						var _g3 = _g.tok;
						if(_g3._hx_index == 0) {
							if(_g3.k._hx_index == 25) {
								var p = _g.pos;
								if(pack.length > 0) {
									this.last = this.token.elt;
									this.token = this.token.next;
									return { name : "extern", pos : p};
								} else {
									var _g = this.peek(0);
									var _g3 = _g.tok;
									if(_g3._hx_index == 0) {
										if(_g3.k._hx_index == 0) {
											var p = _g.pos;
											if(pack.length > 0) {
												this.last = this.token.elt;
												this.token = this.token.next;
												return { name : "function", pos : p};
											} else {
												throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
											}
										} else {
											throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								}
							} else {
								var _g = this.peek(0);
								var _g3 = _g.tok;
								if(_g3._hx_index == 0) {
									if(_g3.k._hx_index == 0) {
										var p = _g.pos;
										if(pack.length > 0) {
											this.last = this.token.elt;
											this.token = this.token.next;
											return { name : "function", pos : p};
										} else {
											throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							}
						} else {
							var _g = this.peek(0);
							var _g3 = _g.tok;
							if(_g3._hx_index == 0) {
								if(_g3.k._hx_index == 0) {
									var p = _g.pos;
									if(pack.length > 0) {
										this.last = this.token.elt;
										this.token = this.token.next;
										return { name : "function", pos : p};
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
							}
						}
					}
				} else {
					var _g = this.peek(0);
					var _g3 = _g.tok;
					if(_g3._hx_index == 0) {
						if(_g3.k._hx_index == 25) {
							var p = _g.pos;
							if(pack.length > 0) {
								this.last = this.token.elt;
								this.token = this.token.next;
								return { name : "extern", pos : p};
							} else {
								var _g = this.peek(0);
								var _g3 = _g.tok;
								if(_g3._hx_index == 0) {
									if(_g3.k._hx_index == 0) {
										var p = _g.pos;
										if(pack.length > 0) {
											this.last = this.token.elt;
											this.token = this.token.next;
											return { name : "function", pos : p};
										} else {
											throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							}
						} else {
							var _g = this.peek(0);
							var _g3 = _g.tok;
							if(_g3._hx_index == 0) {
								if(_g3.k._hx_index == 0) {
									var p = _g.pos;
									if(pack.length > 0) {
										this.last = this.token.elt;
										this.token = this.token.next;
										return { name : "function", pos : p};
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
							}
						}
					} else {
						var _g = this.peek(0);
						var _g3 = _g.tok;
						if(_g3._hx_index == 0) {
							if(_g3.k._hx_index == 0) {
								var p = _g.pos;
								if(pack.length > 0) {
									this.last = this.token.elt;
									this.token = this.token.next;
									return { name : "function", pos : p};
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
						}
					}
				}
			}
			break;
		case 3:
			var p = _g1;
			var i = _g2.s;
			this.last = this.token.elt;
			this.token = this.token.next;
			return { name : "$" + i, pos : p};
		default:
			var _g = this.peek(0);
			var _g1 = _g.tok;
			if(_g1._hx_index == 0) {
				if(_g1.k._hx_index == 40) {
					var p = _g.pos;
					if(pack.length > 0) {
						this.last = this.token.elt;
						this.token = this.token.next;
						return { name : "macro", pos : p};
					} else {
						var _g = this.peek(0);
						var _g1 = _g.tok;
						if(_g1._hx_index == 0) {
							if(_g1.k._hx_index == 25) {
								var p = _g.pos;
								if(pack.length > 0) {
									this.last = this.token.elt;
									this.token = this.token.next;
									return { name : "extern", pos : p};
								} else {
									var _g = this.peek(0);
									var _g1 = _g.tok;
									if(_g1._hx_index == 0) {
										if(_g1.k._hx_index == 0) {
											var p = _g.pos;
											if(pack.length > 0) {
												this.last = this.token.elt;
												this.token = this.token.next;
												return { name : "function", pos : p};
											} else {
												throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
											}
										} else {
											throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								}
							} else {
								var _g = this.peek(0);
								var _g1 = _g.tok;
								if(_g1._hx_index == 0) {
									if(_g1.k._hx_index == 0) {
										var p = _g.pos;
										if(pack.length > 0) {
											this.last = this.token.elt;
											this.token = this.token.next;
											return { name : "function", pos : p};
										} else {
											throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							}
						} else {
							var _g = this.peek(0);
							var _g1 = _g.tok;
							if(_g1._hx_index == 0) {
								if(_g1.k._hx_index == 0) {
									var p = _g.pos;
									if(pack.length > 0) {
										this.last = this.token.elt;
										this.token = this.token.next;
										return { name : "function", pos : p};
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
							}
						}
					}
				} else {
					var _g = this.peek(0);
					var _g1 = _g.tok;
					if(_g1._hx_index == 0) {
						if(_g1.k._hx_index == 25) {
							var p = _g.pos;
							if(pack.length > 0) {
								this.last = this.token.elt;
								this.token = this.token.next;
								return { name : "extern", pos : p};
							} else {
								var _g = this.peek(0);
								var _g1 = _g.tok;
								if(_g1._hx_index == 0) {
									if(_g1.k._hx_index == 0) {
										var p = _g.pos;
										if(pack.length > 0) {
											this.last = this.token.elt;
											this.token = this.token.next;
											return { name : "function", pos : p};
										} else {
											throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							}
						} else {
							var _g = this.peek(0);
							var _g1 = _g.tok;
							if(_g1._hx_index == 0) {
								if(_g1.k._hx_index == 0) {
									var p = _g.pos;
									if(pack.length > 0) {
										this.last = this.token.elt;
										this.token = this.token.next;
										return { name : "function", pos : p};
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
							}
						}
					} else {
						var _g = this.peek(0);
						var _g1 = _g.tok;
						if(_g1._hx_index == 0) {
							if(_g1.k._hx_index == 0) {
								var p = _g.pos;
								if(pack.length > 0) {
									this.last = this.token.elt;
									this.token = this.token.next;
									return { name : "function", pos : p};
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
						}
					}
				}
			} else {
				var _g = this.peek(0);
				var _g1 = _g.tok;
				if(_g1._hx_index == 0) {
					if(_g1.k._hx_index == 25) {
						var p = _g.pos;
						if(pack.length > 0) {
							this.last = this.token.elt;
							this.token = this.token.next;
							return { name : "extern", pos : p};
						} else {
							var _g = this.peek(0);
							var _g1 = _g.tok;
							if(_g1._hx_index == 0) {
								if(_g1.k._hx_index == 0) {
									var p = _g.pos;
									if(pack.length > 0) {
										this.last = this.token.elt;
										this.token = this.token.next;
										return { name : "function", pos : p};
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
							}
						}
					} else {
						var _g = this.peek(0);
						var _g1 = _g.tok;
						if(_g1._hx_index == 0) {
							if(_g1.k._hx_index == 0) {
								var p = _g.pos;
								if(pack.length > 0) {
									this.last = this.token.elt;
									this.token = this.token.next;
									return { name : "function", pos : p};
								} else {
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
						}
					}
				} else {
					var _g = this.peek(0);
					var _g1 = _g.tok;
					if(_g1._hx_index == 0) {
						if(_g1.k._hx_index == 0) {
							var p = _g.pos;
							if(pack.length > 0) {
								this.last = this.token.elt;
								this.token = this.token.next;
								return { name : "function", pos : p};
							} else {
								throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
					}
				}
			}
		}
	}
	,lowerIdentOrMacro: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 1) {
			var _g = _g1.c;
			if(_g._hx_index == 3) {
				var i = _g.s;
				if(haxeparser_HaxeParser.isLowerIdent(i)) {
					this.last = this.token.elt;
					this.token = this.token.next;
					return i;
				} else {
					var _g = this.peek(0);
					var _g1 = _g.pos;
					var _g1 = _g.tok;
					if(_g1._hx_index == 0) {
						switch(_g1.k._hx_index) {
						case 0:
							this.last = this.token.elt;
							this.token = this.token.next;
							return "function";
						case 25:
							this.last = this.token.elt;
							this.token = this.token.next;
							return "extern";
						case 40:
							this.last = this.token.elt;
							this.token = this.token.next;
							return "macro";
						default:
							throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
					}
				}
			} else {
				var _g = this.peek(0);
				var _g1 = _g.pos;
				var _g1 = _g.tok;
				if(_g1._hx_index == 0) {
					switch(_g1.k._hx_index) {
					case 0:
						this.last = this.token.elt;
						this.token = this.token.next;
						return "function";
					case 25:
						this.last = this.token.elt;
						this.token = this.token.next;
						return "extern";
					case 40:
						this.last = this.token.elt;
						this.token = this.token.next;
						return "macro";
					default:
						throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
				}
			}
		} else {
			var _g = this.peek(0);
			var _g1 = _g.pos;
			var _g1 = _g.tok;
			if(_g1._hx_index == 0) {
				switch(_g1.k._hx_index) {
				case 0:
					this.last = this.token.elt;
					this.token = this.token.next;
					return "function";
				case 25:
					this.last = this.token.elt;
					this.token = this.token.next;
					return "extern";
				case 40:
					this.last = this.token.elt;
					this.token = this.token.next;
					return "macro";
				default:
					throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		}
	}
	,anyEnumIdent: function() {
		try {
			var i = this.ident();
			return i;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				var _g1 = this.peek(0);
				var _g2 = _g1.tok;
				if(_g2._hx_index == 0) {
					var p = _g1.pos;
					var k = _g2.k;
					this.last = this.token.elt;
					this.token = this.token.next;
					return { name : $hxEnums[k.__enum__].__constructs__[k._hx_index].toLowerCase(), pos : p};
				} else {
					throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
				}
			} else {
				throw _g;
			}
		}
	}
	,propertyIdent: function() {
		try {
			var i = this.ident();
			return i.name;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				var _g1 = this.peek(0);
				var _g2 = _g1.pos;
				var _g2 = _g1.tok;
				if(_g2._hx_index == 0) {
					switch(_g2.k._hx_index) {
					case 16:
						this.last = this.token.elt;
						this.token = this.token.next;
						return "default";
					case 32:
						this.last = this.token.elt;
						this.token = this.token.next;
						return "dynamic";
					case 36:
						this.last = this.token.elt;
						this.token = this.token.next;
						return "null";
					default:
						throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
				}
			} else {
				throw _g;
			}
		}
	}
	,questionableDollarIdent: function() {
		var po;
		var _g = this.peek(0);
		if(_g.tok._hx_index == 20) {
			var p = _g.pos;
			this.last = this.token.elt;
			this.token = this.token.next;
			po = p;
		} else {
			po = null;
		}
		var ident = this.dollarIdent();
		return { opt : po != null, name : ident.name, pos : ident.pos};
	}
	,getDoc: function() {
		return "";
	}
	,comma: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 13) {
			this.last = this.token.elt;
			this.token = this.token.next;
			return null;
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,semicolon: function() {
		if(this.last.tok == haxeparser_TokenDef.BrClose) {
			var _g = this.peek(0);
			if(_g.tok._hx_index == 9) {
				var p = _g.pos;
				this.last = this.token.elt;
				this.token = this.token.next;
				return p;
			} else {
				return this.last.pos;
			}
		} else {
			var _g = this.peek(0);
			if(_g.tok._hx_index == 9) {
				var p = _g.pos;
				this.last = this.token.elt;
				this.token = this.token.next;
				return p;
			} else {
				var pos = this.last.pos;
				if(this.doResume) {
					return pos;
				} else {
					throw haxe_Exception.thrown(new haxeparser_ParserError(haxeparser_ParserErrorMsg.MissingSemicolon,pos));
				}
			}
		}
	}
	,parseFile: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 0) {
			if(_g1.k._hx_index == 33) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var p = this.parsePackage();
				this.semicolon();
				var l = this.parseTypeDecls(p,[]);
				var _g = this.peek(0);
				var _g1 = _g.pos;
				if(_g.tok._hx_index == 22) {
					this.last = this.token.elt;
					this.token = this.token.next;
					return { pack : p, decls : l};
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				var l = this.parseTypeDecls([],[]);
				var _g = this.peek(0);
				var _g1 = _g.pos;
				if(_g.tok._hx_index == 22) {
					this.last = this.token.elt;
					this.token = this.token.next;
					return { pack : [], decls : l};
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			}
		} else {
			var l = this.parseTypeDecls([],[]);
			var _g = this.peek(0);
			var _g1 = _g.pos;
			if(_g.tok._hx_index == 22) {
				this.last = this.token.elt;
				this.token = this.token.next;
				return { pack : [], decls : l};
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		}
	}
	,parseTypeDecls: function(pack,acc) {
		try {
			var v = this.parseTypeDecl();
			var l = this.parseTypeDecls(pack,haxeparser_HaxeParser.apush(acc,v));
			return l;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return acc;
			} else {
				throw _g;
			}
		}
	}
	,parseAbstract: function(doc,meta,flags,p1) {
		var name = this.typeName();
		var tl = this.parseConstraintParams();
		var st = this.parseAbstractSubtype();
		var sl = this.parseRepeat($bind(this,this.parseAbstractRelations));
		var fl;
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 16) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var fl1 = this.parseClassFields(false,p1);
			fl = fl1;
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
		var result = new Array(flags.length);
		var _g = 0;
		var _g1 = flags.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = flags[i].a;
		}
		var aflags = result;
		if(st != null) {
			aflags.push(haxeparser_AbstractFlag.AIsType(st));
		}
		return { decl : haxeparser_TypeDef.EAbstract({ name : name, doc : doc, meta : meta, params : tl, flags : aflags.concat(sl), data : fl.fields}), pos : haxeparser_HaxeParser.punion(p1,fl.pos)};
	}
	,parseClassContent: function(doc,meta,flags,n,p1) {
		var name = this.typeName();
		var tl = this.parseConstraintParams();
		var hl = this.parseRepeat($bind(this,this.parseClassHerit));
		var fl;
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 16) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var fl1 = this.parseClassFields(false,p1);
			fl = fl1;
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
		var result = new Array(flags.length);
		var _g = 0;
		var _g1 = flags.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = flags[i].c;
		}
		return { decl : haxeparser_TypeDef.EClass({ name : name, doc : doc, meta : meta, params : tl, flags : result.concat(n).concat(hl), data : fl.fields}), pos : haxeparser_HaxeParser.punion(p1,fl.pos)};
	}
	,parseTypeDecl: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		if(_g2._hx_index == 0) {
			switch(_g2.k._hx_index) {
			case 13:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.parseImport(p1);
			case 35:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var t = this.parseTypePath();
				var p2 = this.semicolon();
				return { decl : haxeparser_TypeDef.EUsing(t), pos : haxeparser_HaxeParser.punion(p1,p2)};
			default:
				var doc = this.getDoc();
				var meta = this.parseMeta();
				var c = this.parseCommonFlags();
				var _g = this.peek(0);
				var _g1 = _g.pos;
				var _g2 = _g.tok;
				if(_g2._hx_index == 0) {
					switch(_g2.k._hx_index) {
					case 0:
						var p1 = _g1;
						this.last = this.token.elt;
						this.token = this.token.next;
						var name = this.parseFunName();
						var pl = this.parseConstraintParams();
						var _g = this.peek(0);
						var _g2 = _g.pos;
						if(_g.tok._hx_index == 18) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var al = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseFunParam));
							var _g = this.peek(0);
							var _g2 = _g.pos;
							if(_g.tok._hx_index == 19) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var t = this.parseTypeOpt();
								var e;
								try {
									var e1 = this.toplevelExpr();
									this.semicolon();
									e = { expr : e1, pos : e1.pos};
								} catch( _g ) {
									haxe_NativeStackTrace.lastError = _g;
									if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
										var _g2 = this.peek(0);
										if(_g2.tok._hx_index == 9) {
											var p = _g2.pos;
											this.last = this.token.elt;
											this.token = this.token.next;
											e = { expr : null, pos : p};
										} else {
											throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
										}
									} else {
										throw _g;
									}
								}
								var f = { params : pl, args : al, ret : t, expr : e.expr};
								var result = new Array(c.length);
								var _g = 0;
								var _g2 = c.length;
								while(_g < _g2) {
									var i = _g++;
									result[i] = c[i].s;
								}
								var tmp = haxeparser_HaxeParser.punion(p1,e.pos);
								return { decl : haxeparser_TypeDef.EStatic({ name : name, doc : doc, meta : meta, params : pl, flags : result, data : haxe_macro_FieldType.FFun(f)}), pos : tmp};
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
						break;
					case 2:
						var p1 = _g1;
						this.last = this.token.elt;
						this.token = this.token.next;
						var name = this.dollarIdent();
						var _g = this.peek(0);
						var _g2 = _g.pos;
						if(_g.tok._hx_index == 18) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var i1 = this.propertyIdent();
							var _g = this.peek(0);
							var _g2 = _g.pos;
							if(_g.tok._hx_index == 13) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var i2 = this.propertyIdent();
								var _g = this.peek(0);
								var _g2 = _g.pos;
								if(_g.tok._hx_index == 19) {
									this.last = this.token.elt;
									this.token = this.token.next;
									var t = this.parseTypeOpt();
									var e = this.parseVarFieldAssignment();
									var name1 = name.name;
									var result = new Array(c.length);
									var _g = 0;
									var _g2 = c.length;
									while(_g < _g2) {
										var i = _g++;
										result[i] = c[i].s;
									}
									return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FProp(i1,i2,t,e.expr)}), pos : haxeparser_HaxeParser.punion(p1,e.pos)};
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							var t = this.parseTypeOpt();
							var e = this.parseVarFieldAssignment();
							var name1 = name.name;
							var result = new Array(c.length);
							var _g = 0;
							var _g2 = c.length;
							while(_g < _g2) {
								var i = _g++;
								result[i] = c[i].s;
							}
							return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FVar(t,e.expr)}), pos : haxeparser_HaxeParser.punion(p1,e.pos)};
						}
						break;
					case 26:
						var p1 = _g1;
						this.last = this.token.elt;
						this.token = this.token.next;
						var _g = this.peek(0);
						var _g1 = _g.tok;
						if(_g1._hx_index == 0) {
							if(_g1.k._hx_index == 39) {
								var p11 = _g.pos;
								this.last = this.token.elt;
								this.token = this.token.next;
								var a = this.parseAbstract(doc,[{ name : ":enum", params : [], pos : p11}].concat(meta),c,p11);
								return { decl : a.decl, pos : haxeparser_HaxeParser.punion(p11,a.pos)};
							} else {
								var name = this.typeName();
								var tl = this.parseConstraintParams();
								var _g = this.peek(0);
								var _g1 = _g.pos;
								if(_g.tok._hx_index == 16) {
									this.last = this.token.elt;
									this.token = this.token.next;
									var l = this.parseRepeat($bind(this,this.parseEnum));
									var _g = this.peek(0);
									if(_g.tok._hx_index == 17) {
										var p2 = _g.pos;
										this.last = this.token.elt;
										this.token = this.token.next;
										var result = new Array(c.length);
										var _g = 0;
										var _g1 = c.length;
										while(_g < _g1) {
											var i = _g++;
											result[i] = c[i].e;
										}
										var tmp = haxeparser_HaxeParser.punion(p1,p2);
										return { decl : haxeparser_TypeDef.EEnum({ name : name, doc : doc, meta : meta, params : tl, flags : result, data : l}), pos : tmp};
									} else {
										throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							}
						} else {
							var name = this.typeName();
							var tl = this.parseConstraintParams();
							var _g = this.peek(0);
							var _g1 = _g.pos;
							if(_g.tok._hx_index == 16) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var l = this.parseRepeat($bind(this,this.parseEnum));
								var _g = this.peek(0);
								if(_g.tok._hx_index == 17) {
									var p2 = _g.pos;
									this.last = this.token.elt;
									this.token = this.token.next;
									var result = new Array(c.length);
									var _g = 0;
									var _g1 = c.length;
									while(_g < _g1) {
										var i = _g++;
										result[i] = c[i].e;
									}
									var tmp = haxeparser_HaxeParser.punion(p1,p2);
									return { decl : haxeparser_TypeDef.EEnum({ name : name, doc : doc, meta : meta, params : tl, flags : result, data : l}), pos : tmp};
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						}
						break;
					default:
						try {
							var flags = this.parseClassFlags();
							return this.parseClassContent(doc,meta,c,flags.flags,flags.pos);
						} catch( _g ) {
							haxe_NativeStackTrace.lastError = _g;
							if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
								var _g1 = this.peek(0);
								var _g2 = _g1.pos;
								var _g3 = _g1.tok;
								if(_g3._hx_index == 0) {
									switch(_g3.k._hx_index) {
									case 31:
										var p1 = _g2;
										this.last = this.token.elt;
										this.token = this.token.next;
										var name = this.typeName();
										var tl = this.parseConstraintParams();
										var _g1 = this.peek(0);
										var _g3 = _g1.tok;
										if(_g3._hx_index == 5) {
											if(_g3.op._hx_index == 4) {
												var p2 = _g1.pos;
												this.last = this.token.elt;
												this.token = this.token.next;
												var t = this.parseComplexType();
												var _g1 = this.peek(0);
												var _g3 = _g1.pos;
												if(_g1.tok._hx_index == 9) {
													this.last = this.token.elt;
													this.token = this.token.next;
												}
												var result = new Array(c.length);
												var _g1 = 0;
												var _g3 = c.length;
												while(_g1 < _g3) {
													var i = _g1++;
													result[i] = c[i].e;
												}
												var tmp = haxeparser_HaxeParser.punion(p1,p2);
												return { decl : haxeparser_TypeDef.ETypedef({ name : name, doc : doc, meta : meta, params : tl, flags : result, data : t}), pos : tmp};
											} else {
												throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
											}
										} else {
											throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
										}
										break;
									case 39:
										var p1 = _g2;
										this.last = this.token.elt;
										this.token = this.token.next;
										try {
											var a = this.parseAbstract(doc,meta,c,p1);
											return { decl : a.decl, pos : a.pos};
										} catch( _g1 ) {
											if(((haxe_Exception.caught(_g1).unwrap()) instanceof hxparse_NoMatch)) {
												var c2 = this.parseCommonFlags();
												try {
													var flags = this.parseClassFlags();
													return this.parseClassContent(doc,meta,c.concat(c2),haxeparser_HaxeParser.apush(flags.flags,haxeparser_ClassFlag.HAbstract),p1);
												} catch( _g2 ) {
													if(((haxe_Exception.caught(_g2).unwrap()) instanceof hxparse_NoMatch)) {
														return null;
													} else {
														throw _g2;
													}
												}
											} else {
												throw _g1;
											}
										}
										break;
									default:
										var name = this.dollarIdent();
										var t = this.parseTypeOpt();
										var e = this.parseVarFieldAssignment();
										var name1 = name.name;
										var result = new Array(c.length);
										var _g1 = 0;
										var _g2 = c.length;
										while(_g1 < _g2) {
											var i = _g1++;
											result[i] = c[i].s;
										}
										return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FVar(t,e.expr)}), pos : haxeparser_HaxeParser.punion(c[0].pos,e.pos)};
									}
								} else {
									var name = this.dollarIdent();
									var t = this.parseTypeOpt();
									var e = this.parseVarFieldAssignment();
									var name1 = name.name;
									var result = new Array(c.length);
									var _g1 = 0;
									var _g2 = c.length;
									while(_g1 < _g2) {
										var i = _g1++;
										result[i] = c[i].s;
									}
									return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FVar(t,e.expr)}), pos : haxeparser_HaxeParser.punion(c[0].pos,e.pos)};
								}
							} else {
								throw _g;
							}
						}
					}
				} else {
					try {
						var flags = this.parseClassFlags();
						return this.parseClassContent(doc,meta,c,flags.flags,flags.pos);
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
							var _g1 = this.peek(0);
							var _g2 = _g1.pos;
							var _g3 = _g1.tok;
							if(_g3._hx_index == 0) {
								switch(_g3.k._hx_index) {
								case 31:
									var p1 = _g2;
									this.last = this.token.elt;
									this.token = this.token.next;
									var name = this.typeName();
									var tl = this.parseConstraintParams();
									var _g1 = this.peek(0);
									var _g3 = _g1.tok;
									if(_g3._hx_index == 5) {
										if(_g3.op._hx_index == 4) {
											var p2 = _g1.pos;
											this.last = this.token.elt;
											this.token = this.token.next;
											var t = this.parseComplexType();
											var _g1 = this.peek(0);
											var _g3 = _g1.pos;
											if(_g1.tok._hx_index == 9) {
												this.last = this.token.elt;
												this.token = this.token.next;
											}
											var result = new Array(c.length);
											var _g1 = 0;
											var _g3 = c.length;
											while(_g1 < _g3) {
												var i = _g1++;
												result[i] = c[i].e;
											}
											var tmp = haxeparser_HaxeParser.punion(p1,p2);
											return { decl : haxeparser_TypeDef.ETypedef({ name : name, doc : doc, meta : meta, params : tl, flags : result, data : t}), pos : tmp};
										} else {
											throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
									}
									break;
								case 39:
									var p1 = _g2;
									this.last = this.token.elt;
									this.token = this.token.next;
									try {
										var a = this.parseAbstract(doc,meta,c,p1);
										return { decl : a.decl, pos : a.pos};
									} catch( _g1 ) {
										if(((haxe_Exception.caught(_g1).unwrap()) instanceof hxparse_NoMatch)) {
											var c2 = this.parseCommonFlags();
											try {
												var flags = this.parseClassFlags();
												return this.parseClassContent(doc,meta,c.concat(c2),haxeparser_HaxeParser.apush(flags.flags,haxeparser_ClassFlag.HAbstract),p1);
											} catch( _g2 ) {
												if(((haxe_Exception.caught(_g2).unwrap()) instanceof hxparse_NoMatch)) {
													return null;
												} else {
													throw _g2;
												}
											}
										} else {
											throw _g1;
										}
									}
									break;
								default:
									var name = this.dollarIdent();
									var t = this.parseTypeOpt();
									var e = this.parseVarFieldAssignment();
									var name1 = name.name;
									var result = new Array(c.length);
									var _g1 = 0;
									var _g2 = c.length;
									while(_g1 < _g2) {
										var i = _g1++;
										result[i] = c[i].s;
									}
									return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FVar(t,e.expr)}), pos : haxeparser_HaxeParser.punion(c[0].pos,e.pos)};
								}
							} else {
								var name = this.dollarIdent();
								var t = this.parseTypeOpt();
								var e = this.parseVarFieldAssignment();
								var name1 = name.name;
								var result = new Array(c.length);
								var _g1 = 0;
								var _g2 = c.length;
								while(_g1 < _g2) {
									var i = _g1++;
									result[i] = c[i].s;
								}
								return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FVar(t,e.expr)}), pos : haxeparser_HaxeParser.punion(c[0].pos,e.pos)};
							}
						} else {
							throw _g;
						}
					}
				}
			}
		} else {
			var doc = this.getDoc();
			var meta = this.parseMeta();
			var c = this.parseCommonFlags();
			var _g = this.peek(0);
			var _g1 = _g.pos;
			var _g2 = _g.tok;
			if(_g2._hx_index == 0) {
				switch(_g2.k._hx_index) {
				case 0:
					var p1 = _g1;
					this.last = this.token.elt;
					this.token = this.token.next;
					var name = this.parseFunName();
					var pl = this.parseConstraintParams();
					var _g = this.peek(0);
					var _g2 = _g.pos;
					if(_g.tok._hx_index == 18) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var al = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseFunParam));
						var _g = this.peek(0);
						var _g2 = _g.pos;
						if(_g.tok._hx_index == 19) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var t = this.parseTypeOpt();
							var e;
							try {
								var e1 = this.toplevelExpr();
								this.semicolon();
								e = { expr : e1, pos : e1.pos};
							} catch( _g ) {
								haxe_NativeStackTrace.lastError = _g;
								if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
									var _g2 = this.peek(0);
									if(_g2.tok._hx_index == 9) {
										var p = _g2.pos;
										this.last = this.token.elt;
										this.token = this.token.next;
										e = { expr : null, pos : p};
									} else {
										throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
									}
								} else {
									throw _g;
								}
							}
							var f = { params : pl, args : al, ret : t, expr : e.expr};
							var result = new Array(c.length);
							var _g = 0;
							var _g2 = c.length;
							while(_g < _g2) {
								var i = _g++;
								result[i] = c[i].s;
							}
							var tmp = haxeparser_HaxeParser.punion(p1,e.pos);
							return { decl : haxeparser_TypeDef.EStatic({ name : name, doc : doc, meta : meta, params : pl, flags : result, data : haxe_macro_FieldType.FFun(f)}), pos : tmp};
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
					break;
				case 2:
					var p1 = _g1;
					this.last = this.token.elt;
					this.token = this.token.next;
					var name = this.dollarIdent();
					var _g = this.peek(0);
					var _g2 = _g.pos;
					if(_g.tok._hx_index == 18) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var i1 = this.propertyIdent();
						var _g = this.peek(0);
						var _g2 = _g.pos;
						if(_g.tok._hx_index == 13) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var i2 = this.propertyIdent();
							var _g = this.peek(0);
							var _g2 = _g.pos;
							if(_g.tok._hx_index == 19) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var t = this.parseTypeOpt();
								var e = this.parseVarFieldAssignment();
								var name1 = name.name;
								var result = new Array(c.length);
								var _g = 0;
								var _g2 = c.length;
								while(_g < _g2) {
									var i = _g++;
									result[i] = c[i].s;
								}
								return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FProp(i1,i2,t,e.expr)}), pos : haxeparser_HaxeParser.punion(p1,e.pos)};
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						var t = this.parseTypeOpt();
						var e = this.parseVarFieldAssignment();
						var name1 = name.name;
						var result = new Array(c.length);
						var _g = 0;
						var _g2 = c.length;
						while(_g < _g2) {
							var i = _g++;
							result[i] = c[i].s;
						}
						return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FVar(t,e.expr)}), pos : haxeparser_HaxeParser.punion(p1,e.pos)};
					}
					break;
				case 26:
					var p1 = _g1;
					this.last = this.token.elt;
					this.token = this.token.next;
					var _g = this.peek(0);
					var _g1 = _g.tok;
					if(_g1._hx_index == 0) {
						if(_g1.k._hx_index == 39) {
							var p11 = _g.pos;
							this.last = this.token.elt;
							this.token = this.token.next;
							var a = this.parseAbstract(doc,[{ name : ":enum", params : [], pos : p11}].concat(meta),c,p11);
							return { decl : a.decl, pos : haxeparser_HaxeParser.punion(p11,a.pos)};
						} else {
							var name = this.typeName();
							var tl = this.parseConstraintParams();
							var _g = this.peek(0);
							var _g1 = _g.pos;
							if(_g.tok._hx_index == 16) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var l = this.parseRepeat($bind(this,this.parseEnum));
								var _g = this.peek(0);
								if(_g.tok._hx_index == 17) {
									var p2 = _g.pos;
									this.last = this.token.elt;
									this.token = this.token.next;
									var result = new Array(c.length);
									var _g = 0;
									var _g1 = c.length;
									while(_g < _g1) {
										var i = _g++;
										result[i] = c[i].e;
									}
									var tmp = haxeparser_HaxeParser.punion(p1,p2);
									return { decl : haxeparser_TypeDef.EEnum({ name : name, doc : doc, meta : meta, params : tl, flags : result, data : l}), pos : tmp};
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						}
					} else {
						var name = this.typeName();
						var tl = this.parseConstraintParams();
						var _g = this.peek(0);
						var _g1 = _g.pos;
						if(_g.tok._hx_index == 16) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var l = this.parseRepeat($bind(this,this.parseEnum));
							var _g = this.peek(0);
							if(_g.tok._hx_index == 17) {
								var p2 = _g.pos;
								this.last = this.token.elt;
								this.token = this.token.next;
								var result = new Array(c.length);
								var _g = 0;
								var _g1 = c.length;
								while(_g < _g1) {
									var i = _g++;
									result[i] = c[i].e;
								}
								var tmp = haxeparser_HaxeParser.punion(p1,p2);
								return { decl : haxeparser_TypeDef.EEnum({ name : name, doc : doc, meta : meta, params : tl, flags : result, data : l}), pos : tmp};
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					}
					break;
				default:
					try {
						var flags = this.parseClassFlags();
						return this.parseClassContent(doc,meta,c,flags.flags,flags.pos);
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
							var _g1 = this.peek(0);
							var _g2 = _g1.pos;
							var _g3 = _g1.tok;
							if(_g3._hx_index == 0) {
								switch(_g3.k._hx_index) {
								case 31:
									var p1 = _g2;
									this.last = this.token.elt;
									this.token = this.token.next;
									var name = this.typeName();
									var tl = this.parseConstraintParams();
									var _g1 = this.peek(0);
									var _g3 = _g1.tok;
									if(_g3._hx_index == 5) {
										if(_g3.op._hx_index == 4) {
											var p2 = _g1.pos;
											this.last = this.token.elt;
											this.token = this.token.next;
											var t = this.parseComplexType();
											var _g1 = this.peek(0);
											var _g3 = _g1.pos;
											if(_g1.tok._hx_index == 9) {
												this.last = this.token.elt;
												this.token = this.token.next;
											}
											var result = new Array(c.length);
											var _g1 = 0;
											var _g3 = c.length;
											while(_g1 < _g3) {
												var i = _g1++;
												result[i] = c[i].e;
											}
											var tmp = haxeparser_HaxeParser.punion(p1,p2);
											return { decl : haxeparser_TypeDef.ETypedef({ name : name, doc : doc, meta : meta, params : tl, flags : result, data : t}), pos : tmp};
										} else {
											throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
									}
									break;
								case 39:
									var p1 = _g2;
									this.last = this.token.elt;
									this.token = this.token.next;
									try {
										var a = this.parseAbstract(doc,meta,c,p1);
										return { decl : a.decl, pos : a.pos};
									} catch( _g1 ) {
										if(((haxe_Exception.caught(_g1).unwrap()) instanceof hxparse_NoMatch)) {
											var c2 = this.parseCommonFlags();
											try {
												var flags = this.parseClassFlags();
												return this.parseClassContent(doc,meta,c.concat(c2),haxeparser_HaxeParser.apush(flags.flags,haxeparser_ClassFlag.HAbstract),p1);
											} catch( _g2 ) {
												if(((haxe_Exception.caught(_g2).unwrap()) instanceof hxparse_NoMatch)) {
													return null;
												} else {
													throw _g2;
												}
											}
										} else {
											throw _g1;
										}
									}
									break;
								default:
									var name = this.dollarIdent();
									var t = this.parseTypeOpt();
									var e = this.parseVarFieldAssignment();
									var name1 = name.name;
									var result = new Array(c.length);
									var _g1 = 0;
									var _g2 = c.length;
									while(_g1 < _g2) {
										var i = _g1++;
										result[i] = c[i].s;
									}
									return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FVar(t,e.expr)}), pos : haxeparser_HaxeParser.punion(c[0].pos,e.pos)};
								}
							} else {
								var name = this.dollarIdent();
								var t = this.parseTypeOpt();
								var e = this.parseVarFieldAssignment();
								var name1 = name.name;
								var result = new Array(c.length);
								var _g1 = 0;
								var _g2 = c.length;
								while(_g1 < _g2) {
									var i = _g1++;
									result[i] = c[i].s;
								}
								return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FVar(t,e.expr)}), pos : haxeparser_HaxeParser.punion(c[0].pos,e.pos)};
							}
						} else {
							throw _g;
						}
					}
				}
			} else {
				try {
					var flags = this.parseClassFlags();
					return this.parseClassContent(doc,meta,c,flags.flags,flags.pos);
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
						var _g1 = this.peek(0);
						var _g2 = _g1.pos;
						var _g3 = _g1.tok;
						if(_g3._hx_index == 0) {
							switch(_g3.k._hx_index) {
							case 31:
								var p1 = _g2;
								this.last = this.token.elt;
								this.token = this.token.next;
								var name = this.typeName();
								var tl = this.parseConstraintParams();
								var _g1 = this.peek(0);
								var _g3 = _g1.tok;
								if(_g3._hx_index == 5) {
									if(_g3.op._hx_index == 4) {
										var p2 = _g1.pos;
										this.last = this.token.elt;
										this.token = this.token.next;
										var t = this.parseComplexType();
										var _g1 = this.peek(0);
										var _g3 = _g1.pos;
										if(_g1.tok._hx_index == 9) {
											this.last = this.token.elt;
											this.token = this.token.next;
										}
										var result = new Array(c.length);
										var _g1 = 0;
										var _g3 = c.length;
										while(_g1 < _g3) {
											var i = _g1++;
											result[i] = c[i].e;
										}
										var tmp = haxeparser_HaxeParser.punion(p1,p2);
										return { decl : haxeparser_TypeDef.ETypedef({ name : name, doc : doc, meta : meta, params : tl, flags : result, data : t}), pos : tmp};
									} else {
										throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
								break;
							case 39:
								var p1 = _g2;
								this.last = this.token.elt;
								this.token = this.token.next;
								try {
									var a = this.parseAbstract(doc,meta,c,p1);
									return { decl : a.decl, pos : a.pos};
								} catch( _g1 ) {
									if(((haxe_Exception.caught(_g1).unwrap()) instanceof hxparse_NoMatch)) {
										var c2 = this.parseCommonFlags();
										try {
											var flags = this.parseClassFlags();
											return this.parseClassContent(doc,meta,c.concat(c2),haxeparser_HaxeParser.apush(flags.flags,haxeparser_ClassFlag.HAbstract),p1);
										} catch( _g2 ) {
											if(((haxe_Exception.caught(_g2).unwrap()) instanceof hxparse_NoMatch)) {
												return null;
											} else {
												throw _g2;
											}
										}
									} else {
										throw _g1;
									}
								}
								break;
							default:
								var name = this.dollarIdent();
								var t = this.parseTypeOpt();
								var e = this.parseVarFieldAssignment();
								var name1 = name.name;
								var result = new Array(c.length);
								var _g1 = 0;
								var _g2 = c.length;
								while(_g1 < _g2) {
									var i = _g1++;
									result[i] = c[i].s;
								}
								return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FVar(t,e.expr)}), pos : haxeparser_HaxeParser.punion(c[0].pos,e.pos)};
							}
						} else {
							var name = this.dollarIdent();
							var t = this.parseTypeOpt();
							var e = this.parseVarFieldAssignment();
							var name1 = name.name;
							var result = new Array(c.length);
							var _g1 = 0;
							var _g2 = c.length;
							while(_g1 < _g2) {
								var i = _g1++;
								result[i] = c[i].s;
							}
							return { decl : haxeparser_TypeDef.EStatic({ name : name1, doc : doc, meta : meta, params : [], flags : result, data : haxe_macro_FieldType.FVar(t,e.expr)}), pos : haxeparser_HaxeParser.punion(c[0].pos,e.pos)};
						}
					} else {
						throw _g;
					}
				}
			}
		}
	}
	,parseClass: function(meta,cflags,needName) {
		var _gthis = this;
		var optName = needName ? $bind(this,this.typeName) : function() {
			var t = _gthis.parseOptional($bind(_gthis,_gthis.typeName));
			if(t == null) {
				return "";
			} else {
				return t;
			}
		};
		var flags = this.parseClassFlags();
		var doc = this.getDoc();
		var name = optName();
		var tl = this.parseConstraintParams();
		var hl = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseClassHerit));
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 16) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var fl = this.parseClassFields(false,flags.pos);
			var result = new Array(cflags.length);
			var _g = 0;
			var _g1 = cflags.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = cflags[i].fst;
			}
			return { decl : haxeparser_TypeDef.EClass({ name : name, doc : doc, meta : meta, params : tl, flags : result.concat(flags.flags).concat(hl), data : fl.fields}), pos : haxeparser_HaxeParser.punion(flags.pos,fl.pos)};
		} else {
			throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
		}
	}
	,parseImport: function(p1) {
		var acc;
		var _g = this.peek(0);
		var _g1 = _g.tok;
		if(_g1._hx_index == 1) {
			var _g2 = _g1.c;
			if(_g2._hx_index == 3) {
				var p = _g.pos;
				var name = _g2.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				acc = [{ pack : name, pos : p}];
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
		}
		while(true) {
			var _g = this.peek(0);
			var _g1 = _g.pos;
			var _g2 = _g.tok;
			switch(_g2._hx_index) {
			case 1:
				var _g3 = _g2.c;
				if(_g3._hx_index == 3) {
					if(_g3.s == "as") {
						this.last = this.token.elt;
						this.token = this.token.next;
						var _g4 = this.peek(0);
						var _g5 = _g4.pos;
						var _g6 = _g4.tok;
						if(_g6._hx_index == 1) {
							var _g7 = _g6.c;
							if(_g7._hx_index == 3) {
								var name = _g7.s;
								this.last = this.token.elt;
								this.token = this.token.next;
								var _g8 = this.peek(0);
								if(_g8.tok._hx_index == 9) {
									var p2 = _g8.pos;
									this.last = this.token.elt;
									this.token = this.token.next;
									return { decl : haxeparser_TypeDef.EImport(acc,haxeparser_ImportMode.IAsName(name)), pos : p2};
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
				break;
			case 5:
				if(_g2.op._hx_index == 23) {
					this.last = this.token.elt;
					this.token = this.token.next;
					var _g9 = this.peek(0);
					var _g10 = _g9.pos;
					var _g11 = _g9.tok;
					if(_g11._hx_index == 1) {
						var _g12 = _g11.c;
						if(_g12._hx_index == 3) {
							var name1 = _g12.s;
							this.last = this.token.elt;
							this.token = this.token.next;
							var _g13 = this.peek(0);
							if(_g13.tok._hx_index == 9) {
								var p21 = _g13.pos;
								this.last = this.token.elt;
								this.token = this.token.next;
								return { decl : haxeparser_TypeDef.EImport(acc,haxeparser_ImportMode.IAsName(name1)), pos : p21};
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
				break;
			case 9:
				var p22 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { decl : haxeparser_TypeDef.EImport(acc,haxeparser_ImportMode.INormal), pos : p22};
			case 10:
				this.last = this.token.elt;
				this.token = this.token.next;
				var _g14 = this.peek(0);
				var _g15 = _g14.pos;
				var _g16 = _g14.tok;
				switch(_g16._hx_index) {
				case 0:
					switch(_g16.k._hx_index) {
					case 0:
						var p = _g15;
						this.last = this.token.elt;
						this.token = this.token.next;
						acc.push({ pack : "function", pos : p});
						break;
					case 25:
						var p1 = _g15;
						this.last = this.token.elt;
						this.token = this.token.next;
						acc.push({ pack : "extern", pos : p1});
						break;
					case 40:
						var p3 = _g15;
						this.last = this.token.elt;
						this.token = this.token.next;
						acc.push({ pack : "macro", pos : p3});
						break;
					default:
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
					break;
				case 1:
					var _g17 = _g16.c;
					if(_g17._hx_index == 3) {
						var p4 = _g15;
						var k = _g17.s;
						this.last = this.token.elt;
						this.token = this.token.next;
						acc.push({ pack : k, pos : p4});
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
					break;
				case 5:
					if(_g16.op._hx_index == 1) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var _g18 = this.peek(0);
						if(_g18.tok._hx_index == 9) {
							var p23 = _g18.pos;
							this.last = this.token.elt;
							this.token = this.token.next;
							return { decl : haxeparser_TypeDef.EImport(acc,haxeparser_ImportMode.IAll), pos : p23};
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
					break;
				default:
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
				break;
			default:
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		}
	}
	,parseAbstractRelations: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 1) {
			var _g = _g1.c;
			if(_g._hx_index == 3) {
				switch(_g.s) {
				case "from":
					this.last = this.token.elt;
					this.token = this.token.next;
					var t = this.parseComplexType();
					return haxeparser_AbstractFlag.AFromType(t);
				case "to":
					this.last = this.token.elt;
					this.token = this.token.next;
					var t = this.parseComplexType();
					return haxeparser_AbstractFlag.AToType(t);
				default:
					throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseAbstractSubtype: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 18) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var t = this.parseComplexType();
			var _g = this.peek(0);
			var _g1 = _g.pos;
			if(_g.tok._hx_index == 19) {
				this.last = this.token.elt;
				this.token = this.token.next;
				return t;
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		} else {
			return null;
		}
	}
	,parsePackage: function() {
		return this.psep(haxeparser_TokenDef.Dot,$bind(this,this.lowerIdentOrMacro));
	}
	,parseClassFields: function(tdecl,p1) {
		var l = this.parseClassFieldResume(tdecl);
		var p2;
		var _g = this.peek(0);
		if(_g.tok._hx_index == 17) {
			var p21 = _g.pos;
			this.last = this.token.elt;
			this.token = this.token.next;
			p2 = p21;
		} else {
			throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
		}
		return { fields : l, pos : p2};
	}
	,parseClassFieldResume: function(tdecl) {
		return this.parseRepeat($bind(this,this.parseClassField));
	}
	,parseCommonFlags: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		if(_g2._hx_index == 0) {
			switch(_g2.k._hx_index) {
			case 19:
				var p = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var l = this.parseCommonFlags();
				return haxeparser_HaxeParser.aunshift(l,{ c : haxeparser_ClassFlag.HPrivate, e : haxeparser_EnumFlag.EPrivate, a : haxeparser_AbstractFlag.APrivAbstract, s : haxeparser_StaticFlag.SPrivate, pos : p});
			case 25:
				var p = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var l = this.parseCommonFlags();
				return haxeparser_HaxeParser.aunshift(l,{ c : haxeparser_ClassFlag.HExtern, e : haxeparser_EnumFlag.EExtern, a : haxeparser_AbstractFlag.AExtern, s : null, pos : p});
			case 32:
				var p = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var l = this.parseCommonFlags();
				return haxeparser_HaxeParser.aunshift(l,{ c : null, e : null, a : null, s : haxeparser_StaticFlag.SDynamic, pos : p});
			case 34:
				var p = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var l = this.parseCommonFlags();
				return haxeparser_HaxeParser.aunshift(l,{ c : null, e : null, a : null, s : haxeparser_StaticFlag.SInline, pos : p});
			case 40:
				var p = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var l = this.parseCommonFlags();
				return haxeparser_HaxeParser.aunshift(l,{ c : null, e : null, a : null, s : haxeparser_StaticFlag.SMacro, pos : p});
			case 41:
				var p = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var l = this.parseCommonFlags();
				return haxeparser_HaxeParser.aunshift(l,{ c : haxeparser_ClassFlag.HFinal, e : null, a : null, s : haxeparser_StaticFlag.SFinal, pos : p});
			case 43:
				var p = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var l = this.parseCommonFlags();
				return haxeparser_HaxeParser.aunshift(l,{ c : null, e : null, a : null, s : haxeparser_StaticFlag.SOverload, pos : p});
			default:
				return [];
			}
		} else {
			return [];
		}
	}
	,parseMetaParams: function(pname) {
		var _g = this.peek(0);
		if(_g.tok._hx_index == 18) {
			var p = _g.pos;
			if(p.min == pname.max) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var params = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.expr));
				var _g = this.peek(0);
				var _g1 = _g.pos;
				if(_g.tok._hx_index == 19) {
					this.last = this.token.elt;
					this.token = this.token.next;
					return params;
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				return [];
			}
		} else {
			return [];
		}
	}
	,parseMetaEntry: function() {
		var _g = this.peek(0);
		if(_g.tok._hx_index == 21) {
			var p1 = _g.pos;
			this.last = this.token.elt;
			this.token = this.token.next;
			var name = this.parseMetaName(p1);
			var params = this.parseMetaParams(name.pos);
			return { name : name.name, params : params, pos : name.pos};
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseMeta: function() {
		try {
			var entry = this.parseMetaEntry();
			return haxeparser_HaxeParser.apush(this.parseMeta(),entry);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return [];
			} else {
				throw _g;
			}
		}
	}
	,parseMetaName2: function(p1,acc) {
		var part;
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		switch(_g2._hx_index) {
		case 0:
			var p = _g1;
			var k = _g2.k;
			this.last = this.token.elt;
			this.token = this.token.next;
			part = { name : haxeparser_KeywordPrinter.toString(k), pos : haxeparser_HaxeParser.punion(p,p1)};
			break;
		case 1:
			var _g = _g2.c;
			if(_g._hx_index == 3) {
				var p = _g1;
				var i = _g.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				part = { name : i, pos : haxeparser_HaxeParser.punion(p,p1)};
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
			break;
		default:
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
		acc.unshift(part);
		var _g = this.peek(0);
		if(_g.tok._hx_index == 10) {
			var p1 = _g.pos;
			this.last = this.token.elt;
			this.token = this.token.next;
			var part = this.parseMetaName2(p1,acc);
			return part;
		} else {
			return acc;
		}
	}
	,parseMetaName: function(p1) {
		var _g = this.peek(0);
		if(_g.tok._hx_index == 11) {
			var p = _g.pos;
			this.last = this.token.elt;
			this.token = this.token.next;
			try {
				var names = this.parseMetaName2(p,[]);
				return this.metaNameConcat(names,false);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				} else {
					throw _g;
				}
			}
		} else {
			var names = this.parseMetaName2(p1,[]);
			return this.metaNameConcat(names,true);
		}
	}
	,metaNameConcat: function(names,custom) {
		if(names.length <= 0) {
			throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
		}
		var pos = names[0].pos;
		var nameParts = [];
		var _g = 0;
		while(_g < names.length) {
			var n = names[_g];
			++_g;
			nameParts.push(n.name);
			pos = haxeparser_HaxeParser.punion(pos,n.pos);
		}
		nameParts.reverse();
		if(custom) {
			return { name : nameParts.join("."), pos : pos};
		} else {
			return { name : ":" + nameParts.join("."), pos : pos};
		}
	}
	,parseEnumFlags: function() {
		var _g = this.peek(0);
		var _g1 = _g.tok;
		if(_g1._hx_index == 0) {
			if(_g1.k._hx_index == 26) {
				var p = _g.pos;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { flags : [], pos : p};
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseClassFlags: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		if(_g2._hx_index == 0) {
			switch(_g2.k._hx_index) {
			case 1:
				var p = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { flags : [], pos : p};
			case 27:
				var p = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { flags : haxeparser_HaxeParser.apush([],haxeparser_ClassFlag.HInterface), pos : p};
			default:
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseTypeHint: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 11) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var t = this.parseComplexType();
			return t;
		} else {
			return null;
		}
	}
	,parseTypeOpt: function() {
		try {
			var t = this.parseTypeHint();
			return t;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return null;
			} else {
				throw _g;
			}
		}
	}
	,parseComplexType: function() {
		return this.parseComplexTypeMaybeNamed(false);
	}
	,parseComplexTypeMaybeNamed: function(allowNamed) {
		var _gthis = this;
		var _g = this.peek(0);
		if(_g.tok._hx_index == 18) {
			var p1 = _g.pos;
			this.last = this.token.elt;
			this.token = this.token.next;
			var tl = this.psep(haxeparser_TokenDef.Comma,function() {
				return _gthis.parseComplexTypeMaybeNamed(true);
			});
			var _g = this.peek(0);
			if(_g.tok._hx_index == 19) {
				var p2 = _g.pos;
				this.last = this.token.elt;
				this.token = this.token.next;
				switch(tl.length) {
				case 0:
					return this.parseFunctionTypeNext(tl,p1);
				case 1:
					var _g = tl[0];
					if(_g._hx_index == 6) {
						var _g1 = _g.t;
						var _g1 = _g.n;
						return this.parseFunctionTypeNext(tl,p1);
					} else {
						var t = _g;
						var t1 = haxe_macro_ComplexType.TParent(t);
						return this.parseComplexTypeNext(t1);
					}
					break;
				default:
					return this.parseFunctionTypeNext(tl,p1);
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		} else {
			var t = this.parseComplexTypeInner(allowNamed);
			return this.parseComplexTypeNext(t);
		}
	}
	,parseFunctionTypeNext: function(tl,p1) {
		var _g = this.peek(0);
		if(_g.tok._hx_index == 12) {
			var pa = _g.pos;
			this.last = this.token.elt;
			this.token = this.token.next;
			var tret = this.parseComplexTypeInner(false);
			return haxe_macro_ComplexType.TFunction(tl,tret);
		} else {
			throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
		}
	}
	,parseStructuralExtension: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 5) {
			if(_g1.op._hx_index == 7) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var t = this.parseTypePath();
				var _g = this.peek(0);
				var _g1 = _g.pos;
				if(_g.tok._hx_index == 13) {
					this.last = this.token.elt;
					this.token = this.token.next;
					return t;
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseComplexTypeInner: function(allowNamed) {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		switch(_g.tok._hx_index) {
		case 16:
			var p1 = _g1;
			this.last = this.token.elt;
			this.token = this.token.next;
			try {
				var l = this.parseTypeAnonymous(false);
				return haxe_macro_ComplexType.TAnonymous(l);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
					try {
						var t = this.parseStructuralExtension();
						var tl = this.parseRepeat($bind(this,this.parseStructuralExtension));
						tl.unshift(t);
						try {
							var l = this.parseTypeAnonymous(false);
							return haxe_macro_ComplexType.TExtend(tl,l);
						} catch( _g1 ) {
							if(((haxe_Exception.caught(_g1).unwrap()) instanceof hxparse_NoMatch)) {
								try {
									var fl = this.parseClassFields(true,p1);
									return haxe_macro_ComplexType.TExtend(tl,fl.fields);
								} catch( _g2 ) {
									if(((haxe_Exception.caught(_g2).unwrap()) instanceof hxparse_NoMatch)) {
										throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
									} else {
										throw _g2;
									}
								}
							} else {
								throw _g1;
							}
						}
					} catch( _g1 ) {
						if(((haxe_Exception.caught(_g1).unwrap()) instanceof hxparse_NoMatch)) {
							try {
								var l = this.parseClassFields(true,p1);
								return haxe_macro_ComplexType.TAnonymous(l.fields);
							} catch( _g2 ) {
								if(((haxe_Exception.caught(_g2).unwrap()) instanceof hxparse_NoMatch)) {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								} else {
									throw _g2;
								}
							}
						} else {
							throw _g1;
						}
					}
				} else {
					throw _g;
				}
			}
			break;
		case 18:
			this.last = this.token.elt;
			this.token = this.token.next;
			var t = this.parseComplexType();
			var _g = this.peek(0);
			var _g1 = _g.pos;
			if(_g.tok._hx_index == 19) {
				this.last = this.token.elt;
				this.token = this.token.next;
				return haxe_macro_ComplexType.TParent(t);
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
			break;
		case 20:
			this.last = this.token.elt;
			this.token = this.token.next;
			var t = this.parseComplexTypeInner(allowNamed);
			return haxe_macro_ComplexType.TOptional(t);
		default:
			try {
				var n = this.dollarIdent();
				var _g = this.peek(0);
				var _g1 = _g.pos;
				if(_g.tok._hx_index == 11) {
					this.last = this.token.elt;
					this.token = this.token.next;
					var t = this.parseComplexType();
					return haxe_macro_ComplexType.TNamed(n.name,t);
				} else {
					var t = this.parseTypePath2([],n);
					return haxe_macro_ComplexType.TPath(t);
				}
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
					var t = this.parseTypePath();
					return haxe_macro_ComplexType.TPath(t);
				} else {
					throw _g;
				}
			}
		}
	}
	,parseTypePath: function() {
		return this.parseTypePath1([]);
	}
	,parseTypePath1: function(pack) {
		var ident = this.dollarIdentMacro(pack);
		return this.parseTypePath2(pack,ident);
	}
	,parseTypePath2: function(pack,ident) {
		if(haxeparser_HaxeParser.isLowerIdent(ident.name)) {
			var _g = this.peek(0);
			var _g1 = _g.pos;
			switch(_g.tok._hx_index) {
			case 9:
				this.last = this.token.elt;
				this.token = this.token.next;
				throw haxe_Exception.thrown(new haxeparser_ParserError(haxeparser_ParserErrorMsg.Custom("Type name should start with an uppercase letter"),ident.pos));
			case 10:
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.parseTypePath1(haxeparser_HaxeParser.apush(pack,ident.name));
			default:
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		} else {
			var sub;
			var _g = this.peek(0);
			var _g1 = _g.pos;
			if(_g.tok._hx_index == 10) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var _g = this.peek(0);
				var _g1 = _g.pos;
				var _g1 = _g.tok;
				if(_g1._hx_index == 1) {
					var _g = _g1.c;
					if(_g._hx_index == 3) {
						var name = _g.s;
						if(!haxeparser_HaxeParser.isLowerIdent(name)) {
							this.last = this.token.elt;
							this.token = this.token.next;
							sub = name;
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				sub = null;
			}
			var params;
			var _g = this.peek(0);
			var _g1 = _g.pos;
			var _g1 = _g.tok;
			if(_g1._hx_index == 5) {
				if(_g1.op._hx_index == 9) {
					this.last = this.token.elt;
					this.token = this.token.next;
					var l = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseTypePathOrConst));
					var _g = this.peek(0);
					var _g1 = _g.pos;
					var _g1 = _g.tok;
					if(_g1._hx_index == 5) {
						if(_g1.op._hx_index == 7) {
							this.last = this.token.elt;
							this.token = this.token.next;
							params = l;
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					params = [];
				}
			} else {
				params = [];
			}
			return { pack : pack, name : ident.name, params : params, sub : sub};
		}
	}
	,typeName: function() {
		var _g = this.peek(0);
		var _g1 = _g.tok;
		if(_g1._hx_index == 1) {
			var _g2 = _g1.c;
			if(_g2._hx_index == 3) {
				var p = _g.pos;
				var name = _g2.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				if(haxeparser_HaxeParser.isLowerIdent(name)) {
					throw haxe_Exception.thrown(new haxeparser_ParserError(haxeparser_ParserErrorMsg.Custom("Type name should start with an uppercase letter"),p));
				} else {
					return name;
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseTypePathOrConst: function() {
		var _g = this.peek(0);
		if(_g.tok._hx_index == 14) {
			var p1 = _g.pos;
			this.last = this.token.elt;
			this.token = this.token.next;
			var l = this.parseArrayDecl();
			var _g = this.peek(0);
			if(_g.tok._hx_index == 15) {
				var p2 = _g.pos;
				this.last = this.token.elt;
				this.token = this.token.next;
				return haxe_macro_TypeParam.TPExpr({ expr : haxe_macro_ExprDef.EArrayDecl(l), pos : haxeparser_HaxeParser.punion(p1,p2)});
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		} else {
			try {
				var t = this.parseComplexType();
				return haxe_macro_TypeParam.TPType(t);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
					var _g1 = this.peek(0);
					var _g2 = _g1.tok;
					if(_g2._hx_index == 1) {
						var p = _g1.pos;
						var c = _g2.c;
						this.last = this.token.elt;
						this.token = this.token.next;
						return haxe_macro_TypeParam.TPExpr({ expr : haxe_macro_ExprDef.EConst(c), pos : p});
					} else {
						try {
							var e = this.expr();
							return haxe_macro_TypeParam.TPExpr(e);
						} catch( _g1 ) {
							if(((haxe_Exception.caught(_g1).unwrap()) instanceof hxparse_NoMatch)) {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							} else {
								throw _g1;
							}
						}
					}
				} else {
					throw _g;
				}
			}
		}
	}
	,parseComplexTypeNext: function(t) {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		switch(_g2._hx_index) {
		case 5:
			if(_g2.op._hx_index == 11) {
				var pa = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var t2 = this.parseComplexType();
				if(t2._hx_index == 7) {
					var tl = t2.tl;
					return haxe_macro_ComplexType.TIntersection(haxeparser_HaxeParser.aunshift(tl,t));
				} else {
					return haxe_macro_ComplexType.TIntersection([t,t2]);
				}
			} else {
				return t;
			}
			break;
		case 12:
			this.last = this.token.elt;
			this.token = this.token.next;
			var t2 = this.parseComplexType();
			if(t2._hx_index == 1) {
				var r = t2.ret;
				var args = t2.args;
				return haxe_macro_ComplexType.TFunction(haxeparser_HaxeParser.aunshift(args,t),r);
			} else {
				return haxe_macro_ComplexType.TFunction([t],t2);
			}
			break;
		default:
			return t;
		}
	}
	,parseTypeAnonymous: function(opt) {
		try {
			var id = this.ident();
			var t = this.parseTypeHint();
			var next = function(p2,acc) {
				var t1;
				if(!opt) {
					t1 = t;
				} else if(t._hx_index == 0) {
					var _g = t.p;
					var _g1 = _g.sub;
					var _g1 = _g.params;
					t1 = _g.name == "Null" ? _g.pack.length == 0 ? t : haxe_macro_ComplexType.TPath({ pack : [], name : "Null", sub : null, params : [haxe_macro_TypeParam.TPType(t)]}) : haxe_macro_ComplexType.TPath({ pack : [], name : "Null", sub : null, params : [haxe_macro_TypeParam.TPType(t)]});
				} else {
					t1 = haxe_macro_ComplexType.TPath({ pack : [], name : "Null", sub : null, params : [haxe_macro_TypeParam.TPType(t)]});
				}
				return haxeparser_HaxeParser.aunshift(acc,{ name : id.name, meta : opt ? [{ name : ":optional", params : [], pos : id.pos}] : [], access : [], doc : null, kind : haxe_macro_FieldType.FVar(t1,null), pos : haxeparser_HaxeParser.punion(id.pos,p2)});
			};
			var _g = this.peek(0);
			var _g1 = _g.pos;
			switch(_g.tok._hx_index) {
			case 13:
				var p2 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var _g = this.peek(0);
				var _g2 = _g.pos;
				if(_g.tok._hx_index == 17) {
					this.last = this.token.elt;
					this.token = this.token.next;
					return next(p2,[]);
				} else {
					try {
						var l = this.parseTypeAnonymous(false);
						return next(p2,l);
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						} else {
							throw _g;
						}
					}
				}
				break;
			case 17:
				var p2 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				return next(p2,[]);
			default:
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				var _g1 = this.peek(0);
				var _g2 = _g1.pos;
				if(_g1.tok._hx_index == 20) {
					if(!opt) {
						this.last = this.token.elt;
						this.token = this.token.next;
						return this.parseTypeAnonymous(true);
					} else {
						throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
				}
			} else {
				throw _g;
			}
		}
	}
	,parseEnum: function() {
		this.doc = null;
		var meta = this.parseMeta();
		var name = this.anyEnumIdent();
		var doc = this.getDoc();
		var params = this.parseConstraintParams();
		var args;
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 18) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var l = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseEnumParam));
			var _g = this.peek(0);
			var _g1 = _g.pos;
			if(_g.tok._hx_index == 19) {
				this.last = this.token.elt;
				this.token = this.token.next;
				args = l;
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		} else {
			args = [];
		}
		var t = this.parseTypeOpt();
		var p2;
		try {
			var p = this.semicolon();
			p2 = p;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			} else {
				throw _g;
			}
		}
		return { name : name.name, doc : doc, meta : meta, args : args, params : params, type : t, pos : haxeparser_HaxeParser.punion(name.pos,p2)};
	}
	,parseEnumParam: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 20) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var name = this.ident();
			var t = this.parseTypeHint();
			return { name : name.name, opt : true, type : t};
		} else {
			var name = this.ident();
			var t = this.parseTypeHint();
			return { name : name.name, opt : false, type : t};
		}
	}
	,parseFunctionField: function(doc,meta,accessList) {
		var _g = this.peek(0);
		var _g1 = _g.tok;
		if(_g1._hx_index == 0) {
			if(_g1.k._hx_index == 0) {
				var p1 = _g.pos;
				this.last = this.token.elt;
				this.token = this.token.next;
				var name = this.parseFunName();
				var pl = this.parseConstraintParams();
				var _g = this.peek(0);
				var _g1 = _g.pos;
				if(_g.tok._hx_index == 18) {
					this.last = this.token.elt;
					this.token = this.token.next;
					var al = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseFunParam));
					var _g = this.peek(0);
					var _g1 = _g.pos;
					if(_g.tok._hx_index == 19) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var t = this.parseTypeOpt();
						var e;
						try {
							var e1 = this.toplevelExpr();
							this.semicolon();
							e = { expr : e1, pos : e1.pos};
						} catch( _g ) {
							haxe_NativeStackTrace.lastError = _g;
							if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
								var _g1 = this.peek(0);
								if(_g1.tok._hx_index == 9) {
									var p = _g1.pos;
									this.last = this.token.elt;
									this.token = this.token.next;
									e = { expr : null, pos : p};
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							} else {
								throw _g;
							}
						}
						var f = { params : pl, args : al, ret : t, expr : e.expr};
						return { name : name, pos : haxeparser_HaxeParser.punion(p1,e.pos), kind : haxe_macro_FieldType.FFun(f)};
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseVarFieldAssignment: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		switch(_g2._hx_index) {
		case 5:
			if(_g2.op._hx_index == 4) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var e = this.toplevelExpr();
				var p2 = this.semicolon();
				return { expr : e, pos : p2};
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
			break;
		case 9:
			var p2 = _g1;
			this.last = this.token.elt;
			this.token = this.token.next;
			return { expr : null, pos : p2};
		default:
			throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
		}
	}
	,parseClassField: function() {
		this.doc = null;
		var meta = this.parseMeta();
		var al = this.parseCfRights(true,[]);
		var doc = this.getDoc();
		var data;
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		if(_g2._hx_index == 0) {
			switch(_g2.k._hx_index) {
			case 2:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var name = this.questionableDollarIdent();
				var _g = this.peek(0);
				var _g2 = _g.pos;
				if(_g.tok._hx_index == 18) {
					this.last = this.token.elt;
					this.token = this.token.next;
					var i1 = this.propertyIdent();
					var _g = this.peek(0);
					var _g2 = _g.pos;
					if(_g.tok._hx_index == 13) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var i2 = this.propertyIdent();
						var _g = this.peek(0);
						var _g2 = _g.pos;
						if(_g.tok._hx_index == 19) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var t = this.parseTypeOpt();
							var e = this.parseVarFieldAssignment();
							data = { name : name.name, pos : haxeparser_HaxeParser.punion(p1,e.pos), kind : haxe_macro_FieldType.FProp(i1,i2,t,e.expr)};
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					var t = this.parseTypeOpt();
					var e = this.parseVarFieldAssignment();
					data = { name : name.name, pos : haxeparser_HaxeParser.punion(p1,e.pos), kind : haxe_macro_FieldType.FVar(t,e.expr)};
				}
				break;
			case 41:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				try {
					var name = this.questionableDollarIdent();
					var t = this.parseTypeOpt();
					var e = this.parseVarFieldAssignment();
					al.push(haxe_macro_Access.AFinal);
					data = { name : name.name, pos : haxeparser_HaxeParser.punion(p1,e.pos), kind : haxe_macro_FieldType.FVar(t,e.expr)};
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
						var al2 = this.parseCfRights(true,al);
						var f = this.parseFunctionField(doc,meta,haxeparser_HaxeParser.apush(al2,haxe_macro_Access.AFinal));
						al = al2;
						data = f;
					} else {
						throw _g;
					}
				}
				break;
			default:
				try {
					var f = this.parseFunctionField(doc,meta,al);
					data = f;
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
						if(al.length == 0) {
							throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						throw _g;
					}
				}
			}
		} else {
			try {
				var f = this.parseFunctionField(doc,meta,al);
				data = f;
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
					if(al.length == 0) {
						throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					throw _g;
				}
			}
		}
		return { name : data.name, doc : doc, meta : meta, access : al, pos : data.pos, kind : data.kind};
	}
	,parseCfRights: function(allowStatic,l) {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 0) {
			if(_g1.k._hx_index == 17) {
				if(allowStatic) {
					this.last = this.token.elt;
					this.token = this.token.next;
					var l1 = this.parseCfRights(false,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AStatic));
					return l1;
				} else {
					var _g = this.peek(0);
					var _g1 = _g.pos;
					var _g1 = _g.tok;
					if(_g1._hx_index == 0) {
						switch(_g1.k._hx_index) {
						case 18:
							this.last = this.token.elt;
							this.token = this.token.next;
							var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.APublic));
							return l1;
						case 19:
							this.last = this.token.elt;
							this.token = this.token.next;
							var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.APrivate));
							return l1;
						case 25:
							this.last = this.token.elt;
							this.token = this.token.next;
							var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AExtern));
							return l1;
						case 30:
							this.last = this.token.elt;
							this.token = this.token.next;
							var l1 = this.parseCfRights(false,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AOverride));
							return l1;
						case 32:
							this.last = this.token.elt;
							this.token = this.token.next;
							var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.ADynamic));
							return l1;
						case 34:
							this.last = this.token.elt;
							this.token = this.token.next;
							var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AInline));
							return l1;
						case 40:
							this.last = this.token.elt;
							this.token = this.token.next;
							var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AMacro));
							return l1;
						default:
							return l;
						}
					} else {
						return l;
					}
				}
			} else {
				var _g = this.peek(0);
				var _g1 = _g.pos;
				var _g1 = _g.tok;
				if(_g1._hx_index == 0) {
					switch(_g1.k._hx_index) {
					case 18:
						this.last = this.token.elt;
						this.token = this.token.next;
						var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.APublic));
						return l1;
					case 19:
						this.last = this.token.elt;
						this.token = this.token.next;
						var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.APrivate));
						return l1;
					case 25:
						this.last = this.token.elt;
						this.token = this.token.next;
						var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AExtern));
						return l1;
					case 30:
						this.last = this.token.elt;
						this.token = this.token.next;
						var l1 = this.parseCfRights(false,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AOverride));
						return l1;
					case 32:
						this.last = this.token.elt;
						this.token = this.token.next;
						var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.ADynamic));
						return l1;
					case 34:
						this.last = this.token.elt;
						this.token = this.token.next;
						var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AInline));
						return l1;
					case 40:
						this.last = this.token.elt;
						this.token = this.token.next;
						var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AMacro));
						return l1;
					default:
						return l;
					}
				} else {
					return l;
				}
			}
		} else {
			var _g = this.peek(0);
			var _g1 = _g.pos;
			var _g1 = _g.tok;
			if(_g1._hx_index == 0) {
				switch(_g1.k._hx_index) {
				case 18:
					this.last = this.token.elt;
					this.token = this.token.next;
					var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.APublic));
					return l1;
				case 19:
					this.last = this.token.elt;
					this.token = this.token.next;
					var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.APrivate));
					return l1;
				case 25:
					this.last = this.token.elt;
					this.token = this.token.next;
					var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AExtern));
					return l1;
				case 30:
					this.last = this.token.elt;
					this.token = this.token.next;
					var l1 = this.parseCfRights(false,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AOverride));
					return l1;
				case 32:
					this.last = this.token.elt;
					this.token = this.token.next;
					var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.ADynamic));
					return l1;
				case 34:
					this.last = this.token.elt;
					this.token = this.token.next;
					var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AInline));
					return l1;
				case 40:
					this.last = this.token.elt;
					this.token = this.token.next;
					var l1 = this.parseCfRights(allowStatic,haxeparser_HaxeParser.apush(l,haxe_macro_Access.AMacro));
					return l1;
				default:
					return l;
				}
			} else {
				return l;
			}
		}
	}
	,parseFunName: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		switch(_g1._hx_index) {
		case 0:
			if(_g1.k._hx_index == 22) {
				this.last = this.token.elt;
				this.token = this.token.next;
				return "new";
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
			break;
		case 1:
			var _g = _g1.c;
			if(_g._hx_index == 3) {
				var name = _g.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				return name;
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
			break;
		default:
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseFunParam: function() {
		var meta = this.parseMeta();
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 20) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var id = this.dollarIdent();
			var t = this.parseTypeOpt();
			var c = this.parseFunParamValue();
			return { name : id.name, opt : true, type : t, value : c, meta : meta};
		} else {
			var id = this.dollarIdent();
			var t = this.parseTypeOpt();
			var c = this.parseFunParamValue();
			return { name : id.name, opt : false, type : t, value : c, meta : meta};
		}
	}
	,parseFunParamValue: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 5) {
			if(_g1.op._hx_index == 4) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var e = this.toplevelExpr();
				return e;
			} else {
				return null;
			}
		} else {
			return null;
		}
	}
	,parseFunParamType: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 20) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var id = this.ident();
			var t = this.parseTypeHint();
			return { name : id.name, opt : true, type : t};
		} else {
			var id = this.ident();
			var t = this.parseTypeHint();
			return { name : id.name, opt : false, type : t};
		}
	}
	,parseConstraintParams: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 5) {
			if(_g1.op._hx_index == 9) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var l = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseConstraintParam));
				var _g = this.peek(0);
				var _g1 = _g.pos;
				var _g1 = _g.tok;
				if(_g1._hx_index == 5) {
					if(_g1.op._hx_index == 7) {
						this.last = this.token.elt;
						this.token = this.token.next;
						return l;
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				return [];
			}
		} else {
			return [];
		}
	}
	,parseConstraintParam: function() {
		var meta = this.parseMeta();
		var name = this.typeName();
		var params = [];
		var ctl;
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 11) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var _g = this.peek(0);
			var _g1 = _g.pos;
			if(_g.tok._hx_index == 18) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var l = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseComplexType));
				var _g = this.peek(0);
				var _g1 = _g.pos;
				if(_g.tok._hx_index == 19) {
					this.last = this.token.elt;
					this.token = this.token.next;
					ctl = l;
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				try {
					var t = this.parseComplexType();
					ctl = [t];
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					} else {
						throw _g;
					}
				}
			}
		} else {
			ctl = [];
		}
		return { name : name, params : params, constraints : ctl, meta : meta};
	}
	,parseClassHerit: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 0) {
			switch(_g1.k._hx_index) {
			case 11:
				this.last = this.token.elt;
				this.token = this.token.next;
				var t = this.parseTypePath();
				return haxeparser_ClassFlag.HExtends(t);
			case 12:
				this.last = this.token.elt;
				this.token = this.token.next;
				var t = this.parseTypePath();
				return haxeparser_ClassFlag.HImplements(t);
			default:
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,block1: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		if(_g2._hx_index == 1) {
			var _g = _g2.c;
			switch(_g._hx_index) {
			case 2:
				var p = _g1;
				var qs = _g.kind;
				var name = _g.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.block2(haxeparser_HaxeParser.quoteIdent(name),haxe_macro_QuoteStatus.Quoted,haxe_macro_Constant.CString(name,qs),p);
			case 3:
				var p = _g1;
				var name = _g.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.block2(name,haxe_macro_QuoteStatus.Unquoted,haxe_macro_Constant.CIdent(name),p);
			default:
				var b = this.block([]);
				return haxe_macro_ExprDef.EBlock(b);
			}
		} else {
			var b = this.block([]);
			return haxe_macro_ExprDef.EBlock(b);
		}
	}
	,block2: function(name,quotes,ident,p) {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 11) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var e = this.expr();
			var l = this.parseObjDecl();
			l.unshift({ field : name, expr : e, quotes : quotes});
			return haxe_macro_ExprDef.EObjectDecl(l);
		} else {
			var e = this.exprNext({ expr : haxe_macro_ExprDef.EConst(ident), pos : p});
			var _ = this.semicolon();
			var b = this.block([e]);
			return haxe_macro_ExprDef.EBlock(b);
		}
	}
	,block: function(acc) {
		try {
			var e = this.parseBlockElt();
			return this.block(haxeparser_HaxeParser.apush(acc,e));
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return acc;
			} else {
				throw _g;
			}
		}
	}
	,parseBlockElt: function() {
		var _gthis = this;
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		if(_g2._hx_index == 0) {
			switch(_g2.k._hx_index) {
			case 2:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var vl = this.psep(haxeparser_TokenDef.Comma,function() {
					return _gthis.parseVarDecl(false);
				});
				var p2 = this.semicolon();
				return { expr : haxe_macro_ExprDef.EVars(vl), pos : haxeparser_HaxeParser.punion(p1,p2)};
			case 34:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var _g = this.peek(0);
				var _g2 = _g.pos;
				var _g2 = _g.tok;
				if(_g2._hx_index == 0) {
					if(_g2.k._hx_index == 0) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.parseFunction(p1,true);
						this.semicolon();
						return e;
					} else {
						try {
							var e = this.secureExpr();
							this.semicolon();
							return haxeparser_HaxeParser.makeMeta(":inline",[],e,p1);
						} catch( _g ) {
							haxe_NativeStackTrace.lastError = _g;
							if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							} else {
								throw _g;
							}
						}
					}
				} else {
					try {
						var e = this.secureExpr();
						this.semicolon();
						return haxeparser_HaxeParser.makeMeta(":inline",[],e,p1);
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						} else {
							throw _g;
						}
					}
				}
				break;
			case 41:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var vl = this.psep(haxeparser_TokenDef.Comma,function() {
					return _gthis.parseVarDecl(true);
				});
				var p2 = this.semicolon();
				return { expr : haxe_macro_ExprDef.EVars(vl), pos : haxeparser_HaxeParser.punion(p1,p2)};
			default:
				var e = this.expr();
				this.semicolon();
				return e;
			}
		} else {
			var e = this.expr();
			this.semicolon();
			return e;
		}
	}
	,parseObjDecl: function() {
		var acc = [];
		while(true) {
			var _g = this.peek(0);
			var _g1 = _g.pos;
			if(_g.tok._hx_index == 13) {
				this.last = this.token.elt;
				this.token = this.token.next;
				try {
					var id = this.ident();
					var _g2 = this.peek(0);
					var _g3 = _g2.pos;
					if(_g2.tok._hx_index == 11) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.expr();
						acc.push({ field : id.name, expr : e, quotes : haxe_macro_QuoteStatus.Unquoted});
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} catch( _g4 ) {
					haxe_NativeStackTrace.lastError = _g4;
					if(((haxe_Exception.caught(_g4).unwrap()) instanceof hxparse_NoMatch)) {
						var _g5 = this.peek(0);
						var _g6 = _g5.pos;
						var _g7 = _g5.tok;
						if(_g7._hx_index == 1) {
							var _g8 = _g7.c;
							if(_g8._hx_index == 2) {
								var _g9 = _g8.kind;
								var name = _g8.s;
								this.last = this.token.elt;
								this.token = this.token.next;
								var _g10 = this.peek(0);
								var _g11 = _g10.pos;
								if(_g10.tok._hx_index == 11) {
									this.last = this.token.elt;
									this.token = this.token.next;
									var e1 = this.expr();
									acc.push({ field : haxeparser_HaxeParser.quoteIdent(name), expr : e1, quotes : haxe_macro_QuoteStatus.Quoted});
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							} else {
								break;
							}
						} else {
							break;
						}
					} else {
						throw _g4;
					}
				}
			} else {
				break;
			}
		}
		return acc;
	}
	,parseArrayDecl: function() {
		var acc = [];
		var br = false;
		while(true) {
			try {
				var e = this.expr();
				acc.push(e);
				var _g = this.peek(0);
				var _g1 = _g.pos;
				if(_g.tok._hx_index == 13) {
					this.last = this.token.elt;
					this.token = this.token.next;
				} else {
					br = true;
				}
			} catch( _g2 ) {
				haxe_NativeStackTrace.lastError = _g2;
				if(((haxe_Exception.caught(_g2).unwrap()) instanceof hxparse_NoMatch)) {
					br = true;
				} else {
					throw _g2;
				}
			}
			if(br) {
				break;
			}
		}
		return acc;
	}
	,parseVarDecl: function(isFinal) {
		var id = this.dollarIdent();
		var t = this.parseTypeOpt();
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 5) {
			if(_g1.op._hx_index == 4) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var e = this.expr();
				return { name : id.name, type : t, expr : e, isFinal : isFinal};
			} else {
				return { name : id.name, type : t, expr : null, isFinal : isFinal};
			}
		} else {
			return { name : id.name, type : t, expr : null, isFinal : isFinal};
		}
	}
	,inlineFunction: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		if(_g2._hx_index == 0) {
			switch(_g2.k._hx_index) {
			case 0:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				return { isInline : false, pos : p1};
			case 34:
				this.last = this.token.elt;
				this.token = this.token.next;
				var _g = this.peek(0);
				var _g1 = _g.tok;
				if(_g1._hx_index == 0) {
					if(_g1.k._hx_index == 0) {
						var p1 = _g.pos;
						this.last = this.token.elt;
						this.token = this.token.next;
						return { isInline : true, pos : p1};
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
				break;
			default:
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,reify: function(inMacro) {
		var reificator = new haxeparser__$HaxeParser_Reificator(inMacro);
		return { toExpr : function(e) {
			return reificator.toExpr(e,e.pos);
		}, toType : $bind(reificator,reificator.toCType), toTypeDef : $bind(reificator,reificator.toTypeDef)};
	}
	,reifyExpr: function(e) {
		var toExpr = this.reify(this.inMacro).toExpr;
		var e1 = toExpr(e);
		return { expr : haxe_macro_ExprDef.ECheckType(e1,haxe_macro_ComplexType.TPath({ pack : ["haxe","macro"], name : "Expr", sub : null, params : []})), pos : e1.pos};
	}
	,parseMacroExpr: function(p) {
		var _gthis = this;
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		switch(_g2._hx_index) {
		case 0:
			switch(_g2.k._hx_index) {
			case 2:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var vl = this.psep(haxeparser_TokenDef.Comma,function() {
					return _gthis.parseVarDecl(false);
				});
				return this.reifyExpr({ expr : haxe_macro_ExprDef.EVars(vl), pos : p1});
			case 41:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var vl = this.psep(haxeparser_TokenDef.Comma,function() {
					return _gthis.parseVarDecl(true);
				});
				return this.reifyExpr({ expr : haxe_macro_ExprDef.EVars(vl), pos : p1});
			default:
				try {
					var d = this.parseClass([],[],false);
					var toType = this.reify(this.inMacro).toTypeDef;
					return { expr : haxe_macro_ExprDef.ECheckType(toType(d),haxe_macro_ComplexType.TPath({ pack : ["haxe","macro"], name : "Expr", sub : "TypeDefinition", params : []})), pos : p};
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
						var e = this.secureExpr();
						return this.reifyExpr(e);
					} else {
						throw _g;
					}
				}
			}
			break;
		case 11:
			this.last = this.token.elt;
			this.token = this.token.next;
			var t = this.parseComplexType();
			var toType = this.reify(this.inMacro).toType;
			var t1 = toType(t,p);
			return { expr : haxe_macro_ExprDef.ECheckType(t1,haxe_macro_ComplexType.TPath({ pack : ["haxe","macro"], name : "Expr", sub : "ComplexType", params : []})), pos : p};
		default:
			try {
				var d = this.parseClass([],[],false);
				var toType = this.reify(this.inMacro).toTypeDef;
				return { expr : haxe_macro_ExprDef.ECheckType(toType(d),haxe_macro_ComplexType.TPath({ pack : ["haxe","macro"], name : "Expr", sub : "TypeDefinition", params : []})), pos : p};
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
					var e = this.secureExpr();
					return this.reifyExpr(e);
				} else {
					throw _g;
				}
			}
		}
	}
	,parseFunction: function(p1,inl) {
		var name = this.parseOptional($bind(this,this.dollarIdent));
		var pl = this.parseConstraintParams();
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 18) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var al = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseFunParam));
			var _g = this.peek(0);
			var _g1 = _g.pos;
			if(_g.tok._hx_index == 19) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var t = this.parseOptional($bind(this,this.parseTypeHint));
				var make = function(eBody) {
					var f = { params : pl, ret : t, args : al, expr : eBody};
					var e = { expr : haxe_macro_ExprDef.EFunction(name == null ? haxe_macro_FunctionKind.FAnonymous : haxe_macro_FunctionKind.FNamed(name.name),f), pos : haxeparser_HaxeParser.punion(p1,eBody.pos)};
					if(inl) {
						return haxeparser_HaxeParser.makeMeta(":inline",[],e,p1);
					} else {
						return e;
					}
				};
				return make(this.secureExpr());
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
		}
	}
	,arrowExpr: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		if(_g.tok._hx_index == 12) {
			this.last = this.token.elt;
			this.token = this.token.next;
			var e = this.expr();
			return e;
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,arrowFunction: function(p1,al,er) {
		return { expr : haxe_macro_ExprDef.EFunction(haxe_macro_FunctionKind.FArrow,{ params : [], ret : null, args : al, expr : { expr : haxe_macro_ExprDef.EReturn(er), pos : er.pos}}), pos : haxeparser_HaxeParser.punion(p1,er.pos)};
	}
	,arrowIdentChecktype: function(e) {
		var _g = e.expr;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var n = _g1.s;
				return { name : n, type : null};
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
			break;
		case 27:
			var _g1 = _g.e;
			var _g2 = _g1.pos;
			var _g2 = _g1.expr;
			if(_g2._hx_index == 0) {
				var _g1 = _g2.c;
				if(_g1._hx_index == 3) {
					var t = _g.t;
					var n = _g1.s;
					return { name : n, type : t};
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
			break;
		default:
			throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
		}
	}
	,arrowFirstParam: function(e) {
		var _g = e.expr;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var n = _g1.s;
				return { name : n, opt : false, meta : [], type : null, value : null};
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
			break;
		case 2:
			var e2 = _g.e2;
			var e1 = _g.e1;
			var op = _g.op;
			return null;
		case 4:
			var _g1 = _g.e;
			var _g = _g1.pos;
			var _g = _g1.expr;
			if(_g._hx_index == 2) {
				if(_g.op._hx_index == 4) {
					var e2 = _g.e2;
					var e1 = _g.e1;
					var np = this.arrowIdentChecktype(e1);
					return { name : np.name, opt : true, meta : [], type : np.type, value : e2};
				} else {
					var e = _g1;
					var np = this.arrowIdentChecktype(e);
					return { name : np.name, opt : false, meta : [], type : np.type, value : null};
				}
			} else {
				var e = _g1;
				var np = this.arrowIdentChecktype(e);
				return { name : np.name, opt : false, meta : [], type : np.type, value : null};
			}
			break;
		default:
			throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
		}
	}
	,expr: function() {
		var _gthis = this;
		try {
			var meta = this.parseMetaEntry();
			return haxeparser_HaxeParser.makeMeta(meta.name,meta.params,this.secureExpr(),meta.pos);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				var _g1 = this.peek(0);
				var _g2 = _g1.pos;
				var _g3 = _g1.tok;
				switch(_g3._hx_index) {
				case 0:
					switch(_g3.k._hx_index) {
					case 0:
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.parseFunction(p1,false);
						return e;
					case 2:
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var v = this.parseVarDecl(false);
						return { expr : haxe_macro_ExprDef.EVars([v]), pos : p1};
					case 3:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var _g1 = this.peek(0);
						var _g4 = _g1.pos;
						if(_g1.tok._hx_index == 18) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var cond = this.expr();
							var _g1 = this.peek(0);
							var _g4 = _g1.pos;
							if(_g1.tok._hx_index == 19) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var e1 = this.expr();
								var e2;
								var _g1 = this.peek(0);
								var _g4 = _g1.pos;
								var _g4 = _g1.tok;
								if(_g4._hx_index == 0) {
									if(_g4.k._hx_index == 4) {
										this.last = this.token.elt;
										this.token = this.token.next;
										var e21 = this.expr();
										e2 = e21;
									} else {
										var _g1 = this.peek(1);
										var _g4 = this.peek(0);
										var _g5 = _g4.pos;
										if(_g4.tok._hx_index == 9) {
											var _g4 = _g1.pos;
											var _g4 = _g1.tok;
											if(_g4._hx_index == 0) {
												if(_g4.k._hx_index == 4) {
													this.last = this.token.elt;
													this.token = this.token.next;
													this.last = this.token.elt;
													this.token = this.token.next;
													e2 = this.secureExpr();
												} else {
													e2 = null;
												}
											} else {
												e2 = null;
											}
										} else {
											e2 = null;
										}
									}
								} else {
									var _g1 = this.peek(1);
									var _g4 = this.peek(0);
									var _g5 = _g4.pos;
									if(_g4.tok._hx_index == 9) {
										var _g4 = _g1.pos;
										var _g4 = _g1.tok;
										if(_g4._hx_index == 0) {
											if(_g4.k._hx_index == 4) {
												this.last = this.token.elt;
												this.token = this.token.next;
												this.last = this.token.elt;
												this.token = this.token.next;
												e2 = this.secureExpr();
											} else {
												e2 = null;
											}
										} else {
											e2 = null;
										}
									} else {
										e2 = null;
									}
								}
								return { expr : haxe_macro_ExprDef.EIf(cond,e1,e2), pos : haxeparser_HaxeParser.punion(p,e2 == null ? e1.pos : e2.pos)};
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
						break;
					case 5:
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var _g1 = this.peek(0);
						var _g4 = _g1.pos;
						if(_g1.tok._hx_index == 18) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var cond = this.expr();
							var _g1 = this.peek(0);
							var _g4 = _g1.pos;
							if(_g1.tok._hx_index == 19) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var e = this.secureExpr();
								return { expr : haxe_macro_ExprDef.EWhile(cond,e,true), pos : haxeparser_HaxeParser.punion(p1,e.pos)};
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
						break;
					case 6:
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.expr();
						var _g1 = this.peek(0);
						var _g4 = _g1.pos;
						var _g4 = _g1.tok;
						if(_g4._hx_index == 0) {
							if(_g4.k._hx_index == 5) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var _g1 = this.peek(0);
								var _g4 = _g1.pos;
								if(_g1.tok._hx_index == 18) {
									this.last = this.token.elt;
									this.token = this.token.next;
									var cond = this.expr();
									var _g1 = this.peek(0);
									var _g4 = _g1.pos;
									if(_g1.tok._hx_index == 19) {
										this.last = this.token.elt;
										this.token = this.token.next;
										return { expr : haxe_macro_ExprDef.EWhile(cond,e,false), pos : haxeparser_HaxeParser.punion(p1,e.pos)};
									} else {
										throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
									}
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
						break;
					case 7:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var _g1 = this.peek(0);
						var _g4 = _g1.pos;
						if(_g1.tok._hx_index == 18) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var it = this.expr();
							var _g1 = this.peek(0);
							var _g4 = _g1.pos;
							if(_g1.tok._hx_index == 19) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var e = this.secureExpr();
								return { expr : haxe_macro_ExprDef.EFor(it,e), pos : haxeparser_HaxeParser.punion(p,e.pos)};
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
						break;
					case 8:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						return { expr : haxe_macro_ExprDef.EBreak, pos : p};
					case 9:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						return { expr : haxe_macro_ExprDef.EContinue, pos : p};
					case 10:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.parseOptional($bind(this,this.expr));
						return { expr : haxe_macro_ExprDef.EReturn(e), pos : e == null ? p : haxeparser_HaxeParser.punion(p,e.pos)};
					case 14:
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.expr();
						var _g1 = this.peek(0);
						var _g4 = _g1.pos;
						if(_g1.tok._hx_index == 16) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var cases = this.parseSwitchCases();
							var _g1 = this.peek(0);
							if(_g1.tok._hx_index == 17) {
								var p2 = _g1.pos;
								this.last = this.token.elt;
								this.token = this.token.next;
								return { expr : haxe_macro_ExprDef.ESwitch(e,cases.cases,cases.def), pos : haxeparser_HaxeParser.punion(p1,p2)};
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
						break;
					case 20:
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.expr();
						var cl = this.parseRepeat($bind(this,this.parseCatch));
						return { expr : haxe_macro_ExprDef.ETry(e,cl), pos : p1};
					case 22:
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var t = this.parseTypePath();
						var _g1 = this.peek(0);
						var _g4 = _g1.pos;
						if(_g1.tok._hx_index == 18) {
							this.last = this.token.elt;
							this.token = this.token.next;
							try {
								var al = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.expr));
								var _g1 = this.peek(0);
								if(_g1.tok._hx_index == 19) {
									var p2 = _g1.pos;
									this.last = this.token.elt;
									this.token = this.token.next;
									return this.exprNext({ expr : haxe_macro_ExprDef.ENew(t,al), pos : haxeparser_HaxeParser.punion(p1,p2)});
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							} catch( _g1 ) {
								if(((haxe_Exception.caught(_g1).unwrap()) instanceof hxparse_NoMatch)) {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								} else {
									throw _g1;
								}
							}
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
						break;
					case 23:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						return this.exprNext({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("this")), pos : p});
					case 24:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.expr();
						return { expr : haxe_macro_ExprDef.EThrow(e), pos : p};
					case 28:
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.expr();
						return { expr : haxe_macro_ExprDef.EUntyped(e), pos : haxeparser_HaxeParser.punion(p1,e.pos)};
					case 29:
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var _g1 = this.peek(0);
						if(_g1.tok._hx_index == 18) {
							var pp = _g1.pos;
							this.last = this.token.elt;
							this.token = this.token.next;
							var e = this.expr();
							var _g1 = this.peek(0);
							var _g4 = _g1.pos;
							if(_g1.tok._hx_index == 13) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var t = this.parseComplexType();
								var _g1 = this.peek(0);
								if(_g1.tok._hx_index == 19) {
									var p2 = _g1.pos;
									this.last = this.token.elt;
									this.token = this.token.next;
									return this.exprNext({ expr : haxe_macro_ExprDef.ECast(e,t), pos : haxeparser_HaxeParser.punion(p1,p2)});
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							} else {
								try {
									var t = this.parseTypeHint();
									var _g1 = this.peek(0);
									if(_g1.tok._hx_index == 19) {
										var p2 = _g1.pos;
										this.last = this.token.elt;
										this.token = this.token.next;
										var pu = haxeparser_HaxeParser.punion(p1,p2);
										var ep = { expr : haxe_macro_ExprDef.EParenthesis({ expr : haxe_macro_ExprDef.ECheckType(e,t), pos : pu}), pos : pu};
										return this.exprNext({ expr : haxe_macro_ExprDef.ECast(ep,null), pos : haxeparser_HaxeParser.punion(p1,pu)});
									} else {
										throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
									}
								} catch( _g1 ) {
									if(((haxe_Exception.caught(_g1).unwrap()) instanceof hxparse_NoMatch)) {
										var _g4 = this.peek(0);
										var _g5 = _g4.pos;
										var _g6 = _g4.tok;
										switch(_g6._hx_index) {
										case 1:
											var _g4 = _g6.c;
											if(_g4._hx_index == 3) {
												if(_g4.s == "is") {
													var p_is = _g5;
													this.last = this.token.elt;
													this.token = this.token.next;
													var t = this.parseTypePath();
													var _g4 = this.peek(0);
													if(_g4.tok._hx_index == 19) {
														var p2 = _g4.pos;
														this.last = this.token.elt;
														this.token = this.token.next;
														var e_is = haxeparser_HaxeParser.makeIs(e,t,haxeparser_HaxeParser.punion(p1,p2),p_is);
														return this.exprNext({ expr : haxe_macro_ExprDef.ECast(e_is,null), pos : haxeparser_HaxeParser.punion(p1,e_is.pos)});
													} else {
														throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
													}
												} else {
													throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
												}
											} else {
												throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
											}
											break;
										case 19:
											var p2 = _g5;
											this.last = this.token.elt;
											this.token = this.token.next;
											var ep = this.exprNext({ expr : haxe_macro_ExprDef.EParenthesis(e), pos : haxeparser_HaxeParser.punion(pp,p2)});
											return this.exprNext({ expr : haxe_macro_ExprDef.ECast(ep,null), pos : haxeparser_HaxeParser.punion(p1,ep.pos)});
										default:
											throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
										}
									} else {
										throw _g1;
									}
								}
							}
						} else {
							var e = this.secureExpr();
							return this.exprNext({ expr : haxe_macro_ExprDef.ECast(e,null), pos : haxeparser_HaxeParser.punion(p1,e.pos)});
						}
						break;
					case 34:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.secureExpr();
						return haxeparser_HaxeParser.makeMeta(":inline",[],e,p);
					case 36:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						return this.exprNext({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("null")), pos : p});
					case 37:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						return this.exprNext({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("true")), pos : p});
					case 38:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						return this.exprNext({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("false")), pos : p});
					case 40:
						var p = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var _g1 = this.peek(0);
						if(_g1.tok._hx_index == 10) {
							var pd = _g1.pos;
							this.last = this.token.elt;
							this.token = this.token.next;
							var e = this.parseField({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("macro")), pos : p},pd);
							return e;
						} else {
							var e = this.parseMacroExpr(p);
							return e;
						}
						break;
					case 41:
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var v = this.parseVarDecl(true);
						return { expr : haxe_macro_ExprDef.EVars([v]), pos : p1};
					default:
						throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
					}
					break;
				case 1:
					var p = _g2;
					var c = _g3.c;
					this.last = this.token.elt;
					this.token = this.token.next;
					return this.exprNext({ expr : haxe_macro_ExprDef.EConst(c), pos : p});
				case 3:
					var p = _g2;
					var v = _g3.s;
					this.last = this.token.elt;
					this.token = this.token.next;
					return this.exprNext({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("$" + v)), pos : p});
				case 4:
					var p1 = _g2;
					var op = _g3.op;
					this.last = this.token.elt;
					this.token = this.token.next;
					var e = this.expr();
					return haxeparser_HaxeParser.makeUnop(op,e,p1);
				case 5:
					if(_g3.op._hx_index == 3) {
						var p1 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = this.expr();
						var neg = function(s) {
							if(HxOverrides.cca(s,0) == 45) {
								return HxOverrides.substr(s,1,null);
							} else {
								return "-" + s;
							}
						};
						var _g1 = haxeparser_HaxeParser.makeUnop(haxe_macro_Unop.OpNeg,e,p1);
						var _g4 = _g1.pos;
						var _g5 = _g1.expr;
						if(_g5._hx_index == 9) {
							var _g6 = _g5.e;
							if(_g5.op._hx_index == 3) {
								if(_g5.postFix == false) {
									var _g5 = _g6.pos;
									var _g5 = _g6.expr;
									if(_g5._hx_index == 0) {
										var _g6 = _g5.c;
										switch(_g6._hx_index) {
										case 0:
											var p = _g4;
											var i = _g6.v;
											return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CInt(neg(i))), pos : p};
										case 1:
											var p = _g4;
											var j = _g6.f;
											return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CFloat(neg(j))), pos : p};
										default:
											var e = _g1;
											return e;
										}
									} else {
										var e = _g1;
										return e;
									}
								} else {
									var e = _g1;
									return e;
								}
							} else {
								var e = _g1;
								return e;
							}
						} else {
							var e = _g1;
							return e;
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
					}
					break;
				case 8:
					var p1 = _g2;
					var i = _g3.s;
					this.last = this.token.elt;
					this.token = this.token.next;
					var e2 = this.expr();
					return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpInterval,{ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CInt(i)), pos : p1},e2);
				case 14:
					var p1 = _g2;
					this.last = this.token.elt;
					this.token = this.token.next;
					var l = this.parseArrayDecl();
					var _g1 = this.peek(0);
					if(_g1.tok._hx_index == 15) {
						var p2 = _g1.pos;
						this.last = this.token.elt;
						this.token = this.token.next;
						return this.exprNext({ expr : haxe_macro_ExprDef.EArrayDecl(l), pos : haxeparser_HaxeParser.punion(p1,p2)});
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
					break;
				case 16:
					var p1 = _g2;
					this.last = this.token.elt;
					this.token = this.token.next;
					var b = this.block1();
					var _g1 = this.peek(0);
					if(_g1.tok._hx_index == 17) {
						var p2 = _g1.pos;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e = { expr : b, pos : haxeparser_HaxeParser.punion(p1,p2)};
						if(b._hx_index == 5) {
							var _g1 = b.fields;
							return this.exprNext(e);
						} else {
							return e;
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
					break;
				case 18:
					var p1 = _g2;
					this.last = this.token.elt;
					this.token = this.token.next;
					var _g1 = this.peek(0);
					var _g2 = _g1.pos;
					switch(_g1.tok._hx_index) {
					case 19:
						var p2 = _g2;
						this.last = this.token.elt;
						this.token = this.token.next;
						var er = this.arrowExpr();
						return this.arrowFunction(p1,[],er);
					case 20:
						this.last = this.token.elt;
						this.token = this.token.next;
						var al = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseFunParam));
						var _g1 = this.peek(0);
						var _g2 = _g1.pos;
						if(_g1.tok._hx_index == 19) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var er = this.arrowExpr();
							if(al.length > 0) {
								al[1].opt = true;
							}
							return this.arrowFunction(p1,al,er);
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
						break;
					default:
						var e = this.expr();
						var _g1 = this.peek(0);
						var _g2 = _g1.pos;
						switch(_g1.tok._hx_index) {
						case 13:
							this.last = this.token.elt;
							this.token = this.token.next;
							var al = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseFunParam));
							var _g1 = this.peek(0);
							var _g3 = _g1.pos;
							if(_g1.tok._hx_index == 19) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var er = this.arrowExpr();
								return this.arrowFunction(p1,haxeparser_HaxeParser.aunshift(al,this.arrowFirstParam(e)),er);
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
							break;
						case 19:
							var p2 = _g2;
							this.last = this.token.elt;
							this.token = this.token.next;
							return this.exprNext({ expr : haxe_macro_ExprDef.EParenthesis(e), pos : haxeparser_HaxeParser.punion(p1,p2)});
						default:
							try {
								var t = this.parseTypeHint();
								var _g1 = this.peek(0);
								var _g2 = _g1.pos;
								var _g3 = _g1.tok;
								switch(_g3._hx_index) {
								case 5:
									if(_g3.op._hx_index == 4) {
										var p2 = _g2;
										this.last = this.token.elt;
										this.token = this.token.next;
										var ea1 = this.expr();
										var withArgs = function(al,er) {
											var _g = e.expr;
											if(_g._hx_index == 0) {
												var _g1 = _g.c;
												if(_g1._hx_index == 3) {
													var n = _g1.s;
													return _gthis.arrowFunction(p1,haxeparser_HaxeParser.aunshift(al,{ name : n, opt : true, meta : [], type : t, value : ea1}),er);
												} else {
													throw haxe_Exception.thrown(new hxparse_Unexpected(_gthis.peek(0),_gthis.stream.curPos()));
												}
											} else {
												throw haxe_Exception.thrown(new hxparse_Unexpected(_gthis.peek(0),_gthis.stream.curPos()));
											}
										};
										var _g1 = this.peek(0);
										var _g3 = _g1.pos;
										switch(_g1.tok._hx_index) {
										case 13:
											this.last = this.token.elt;
											this.token = this.token.next;
											var al = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseFunParam));
											var _g1 = this.peek(0);
											var _g3 = _g1.pos;
											if(_g1.tok._hx_index == 19) {
												this.last = this.token.elt;
												this.token = this.token.next;
												var er = this.arrowExpr();
												return withArgs(al,er);
											} else {
												throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
											}
											break;
										case 19:
											this.last = this.token.elt;
											this.token = this.token.next;
											var er = this.arrowExpr();
											return withArgs([],er);
										default:
											throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
									}
									break;
								case 13:
									var p2 = _g2;
									this.last = this.token.elt;
									this.token = this.token.next;
									var al = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseFunParam));
									var _g1 = this.peek(0);
									var _g3 = _g1.pos;
									if(_g1.tok._hx_index == 19) {
										this.last = this.token.elt;
										this.token = this.token.next;
										var er = this.arrowExpr();
										var np = this.arrowIdentChecktype(e);
										return this.arrowFunction(p1,haxeparser_HaxeParser.aunshift(al,{ name : np.name, opt : false, meta : [], type : t, value : null}),er);
									} else {
										throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
									}
									break;
								case 19:
									var p2 = _g2;
									this.last = this.token.elt;
									this.token = this.token.next;
									return this.exprNext({ expr : haxe_macro_ExprDef.EParenthesis({ expr : haxe_macro_ExprDef.ECheckType(e,t), pos : haxeparser_HaxeParser.punion(p1,p2)}), pos : haxeparser_HaxeParser.punion(p1,p2)});
								default:
									throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
								}
							} catch( _g1 ) {
								if(((haxe_Exception.caught(_g1).unwrap()) instanceof hxparse_NoMatch)) {
									var _g2 = this.peek(0);
									var _g3 = _g2.tok;
									if(_g3._hx_index == 1) {
										var _g4 = _g3.c;
										if(_g4._hx_index == 3) {
											if(_g4.s == "is") {
												var p_is = _g2.pos;
												this.last = this.token.elt;
												this.token = this.token.next;
												var t1 = this.parseTypePath();
												var _g2 = this.peek(0);
												if(_g2.tok._hx_index == 19) {
													var p2 = _g2.pos;
													this.last = this.token.elt;
													this.token = this.token.next;
													return this.exprNext(haxeparser_HaxeParser.makeIs(e,t1,haxeparser_HaxeParser.punion(p1,p2),p_is));
												} else {
													throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
												}
											} else {
												throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
											}
										} else {
											throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
										}
									} else {
										throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
									}
								} else {
									throw _g1;
								}
							}
						}
					}
					break;
				default:
					throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
				}
			} else {
				throw _g;
			}
		}
	}
	,toplevelExpr: function() {
		return this.expr();
	}
	,exprNext: function(e1) {
		var _g = this.peek(0);
		if(_g.tok._hx_index == 16) {
			var p1 = _g.pos;
			if(haxeparser_HaxeParser.isDollarIdent(e1)) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var eparam = this.expr();
				var _g = this.peek(0);
				if(_g.tok._hx_index == 17) {
					var p2 = _g.pos;
					this.last = this.token.elt;
					this.token = this.token.next;
					var _g = e1.expr;
					if(_g._hx_index == 0) {
						var _g1 = _g.c;
						if(_g1._hx_index == 3) {
							var n = _g1.s;
							return this.exprNext({ expr : haxe_macro_ExprDef.EMeta({ name : n, params : [], pos : e1.pos},eparam), pos : haxeparser_HaxeParser.punion(p1,p2)});
						} else {
							throw haxe_Exception.thrown(false);
						}
					} else {
						throw haxe_Exception.thrown(false);
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				var _g = this.peek(0);
				var _g1 = _g.pos;
				var _g2 = _g.tok;
				switch(_g2._hx_index) {
				case 5:
					var _g = _g2.op;
					if(_g._hx_index == 7) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var _g2 = this.peek(0);
						var _g3 = _g2.pos;
						var _g3 = _g2.tok;
						if(_g3._hx_index == 5) {
							switch(_g3.op._hx_index) {
							case 4:
								this.last = this.token.elt;
								this.token = this.token.next;
								return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpGte,e1,this.secureExpr());
							case 7:
								this.last = this.token.elt;
								this.token = this.token.next;
								var _g2 = this.peek(0);
								var _g3 = _g2.pos;
								var _g3 = _g2.tok;
								if(_g3._hx_index == 5) {
									switch(_g3.op._hx_index) {
									case 4:
										this.last = this.token.elt;
										this.token = this.token.next;
										var e2 = this.expr();
										return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr),e1,e2);
									case 7:
										this.last = this.token.elt;
										this.token = this.token.next;
										var _g2 = this.peek(0);
										var _g3 = _g2.pos;
										var _g3 = _g2.tok;
										if(_g3._hx_index == 5) {
											if(_g3.op._hx_index == 4) {
												this.last = this.token.elt;
												this.token = this.token.next;
												var e2 = this.expr();
												return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr),e1,e2);
											} else {
												var e2 = this.secureExpr();
												return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpUShr,e1,e2);
											}
										} else {
											var e2 = this.secureExpr();
											return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpUShr,e1,e2);
										}
										break;
									default:
										var e2 = this.secureExpr();
										return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpShr,e1,e2);
									}
								} else {
									var e2 = this.secureExpr();
									return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpShr,e1,e2);
								}
								break;
							default:
								var e2 = this.secureExpr();
								return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpGt,e1,e2);
							}
						} else {
							var e2 = this.secureExpr();
							return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpGt,e1,e2);
						}
					} else {
						var op = _g;
						this.last = this.token.elt;
						this.token = this.token.next;
						var e2 = this.expr();
						return haxeparser_HaxeParser.makeBinop(op,e1,e2);
					}
					break;
				case 10:
					var p = _g1;
					this.last = this.token.elt;
					this.token = this.token.next;
					var e = this.parseField(e1,p);
					return e;
				case 12:
					this.last = this.token.elt;
					this.token = this.token.next;
					var er = this.expr();
					return this.arrowFunction(e1.pos,[this.arrowFirstParam(e1)],er);
				case 14:
					this.last = this.token.elt;
					this.token = this.token.next;
					var e2 = this.expr();
					var _g = this.peek(0);
					if(_g.tok._hx_index == 15) {
						var p2 = _g.pos;
						this.last = this.token.elt;
						this.token = this.token.next;
						return this.exprNext({ expr : haxe_macro_ExprDef.EArray(e1,e2), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
					break;
				case 18:
					this.last = this.token.elt;
					this.token = this.token.next;
					try {
						var params = this.parseCallParams();
						var _g = this.peek(0);
						if(_g.tok._hx_index == 19) {
							var p2 = _g.pos;
							this.last = this.token.elt;
							this.token = this.token.next;
							return this.exprNext({ expr : haxe_macro_ExprDef.ECall(e1,params), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						} else {
							throw _g;
						}
					}
					break;
				default:
					var _g = this.peek(0);
					var _g1 = _g.tok;
					if(_g1._hx_index == 4) {
						var p = _g.pos;
						var op = _g1.op;
						if(haxeparser_HaxeParser.isPostfix(e1,op)) {
							this.last = this.token.elt;
							this.token = this.token.next;
							return this.exprNext({ expr : haxe_macro_ExprDef.EUnop(op,true,e1), pos : haxeparser_HaxeParser.punion(e1.pos,p)});
						} else {
							var _g = this.peek(0);
							var _g1 = _g.pos;
							if(_g.tok._hx_index == 20) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var e2 = this.expr();
								var _g = this.peek(0);
								var _g1 = _g.pos;
								if(_g.tok._hx_index == 11) {
									this.last = this.token.elt;
									this.token = this.token.next;
									var e3 = this.expr();
									return { expr : haxe_macro_ExprDef.ETernary(e1,e2,e3), pos : haxeparser_HaxeParser.punion(e1.pos,e3.pos)};
								} else {
									throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
								}
							} else {
								return e1;
							}
						}
					} else {
						var _g = this.peek(0);
						var _g1 = _g.pos;
						if(_g.tok._hx_index == 20) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var e2 = this.expr();
							var _g = this.peek(0);
							var _g1 = _g.pos;
							if(_g.tok._hx_index == 11) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var e3 = this.expr();
								return { expr : haxe_macro_ExprDef.ETernary(e1,e2,e3), pos : haxeparser_HaxeParser.punion(e1.pos,e3.pos)};
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							return e1;
						}
					}
				}
			}
		} else {
			var _g = this.peek(0);
			var _g1 = _g.pos;
			var _g2 = _g.tok;
			switch(_g2._hx_index) {
			case 5:
				var _g = _g2.op;
				if(_g._hx_index == 7) {
					this.last = this.token.elt;
					this.token = this.token.next;
					var _g2 = this.peek(0);
					var _g3 = _g2.pos;
					var _g3 = _g2.tok;
					if(_g3._hx_index == 5) {
						switch(_g3.op._hx_index) {
						case 4:
							this.last = this.token.elt;
							this.token = this.token.next;
							return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpGte,e1,this.secureExpr());
						case 7:
							this.last = this.token.elt;
							this.token = this.token.next;
							var _g2 = this.peek(0);
							var _g3 = _g2.pos;
							var _g3 = _g2.tok;
							if(_g3._hx_index == 5) {
								switch(_g3.op._hx_index) {
								case 4:
									this.last = this.token.elt;
									this.token = this.token.next;
									var e2 = this.expr();
									return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr),e1,e2);
								case 7:
									this.last = this.token.elt;
									this.token = this.token.next;
									var _g2 = this.peek(0);
									var _g3 = _g2.pos;
									var _g3 = _g2.tok;
									if(_g3._hx_index == 5) {
										if(_g3.op._hx_index == 4) {
											this.last = this.token.elt;
											this.token = this.token.next;
											var e2 = this.expr();
											return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr),e1,e2);
										} else {
											var e2 = this.secureExpr();
											return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpUShr,e1,e2);
										}
									} else {
										var e2 = this.secureExpr();
										return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpUShr,e1,e2);
									}
									break;
								default:
									var e2 = this.secureExpr();
									return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpShr,e1,e2);
								}
							} else {
								var e2 = this.secureExpr();
								return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpShr,e1,e2);
							}
							break;
						default:
							var e2 = this.secureExpr();
							return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpGt,e1,e2);
						}
					} else {
						var e2 = this.secureExpr();
						return haxeparser_HaxeParser.makeBinop(haxe_macro_Binop.OpGt,e1,e2);
					}
				} else {
					var op = _g;
					this.last = this.token.elt;
					this.token = this.token.next;
					var e2 = this.expr();
					return haxeparser_HaxeParser.makeBinop(op,e1,e2);
				}
				break;
			case 10:
				var p = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var e = this.parseField(e1,p);
				return e;
			case 12:
				this.last = this.token.elt;
				this.token = this.token.next;
				var er = this.expr();
				return this.arrowFunction(e1.pos,[this.arrowFirstParam(e1)],er);
			case 14:
				this.last = this.token.elt;
				this.token = this.token.next;
				var e2 = this.expr();
				var _g = this.peek(0);
				if(_g.tok._hx_index == 15) {
					var p2 = _g.pos;
					this.last = this.token.elt;
					this.token = this.token.next;
					return this.exprNext({ expr : haxe_macro_ExprDef.EArray(e1,e2), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
				break;
			case 18:
				this.last = this.token.elt;
				this.token = this.token.next;
				try {
					var params = this.parseCallParams();
					var _g = this.peek(0);
					if(_g.tok._hx_index == 19) {
						var p2 = _g.pos;
						this.last = this.token.elt;
						this.token = this.token.next;
						return this.exprNext({ expr : haxe_macro_ExprDef.ECall(e1,params), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					} else {
						throw _g;
					}
				}
				break;
			default:
				var _g = this.peek(0);
				var _g1 = _g.tok;
				if(_g1._hx_index == 4) {
					var p = _g.pos;
					var op = _g1.op;
					if(haxeparser_HaxeParser.isPostfix(e1,op)) {
						this.last = this.token.elt;
						this.token = this.token.next;
						return this.exprNext({ expr : haxe_macro_ExprDef.EUnop(op,true,e1), pos : haxeparser_HaxeParser.punion(e1.pos,p)});
					} else {
						var _g = this.peek(0);
						var _g1 = _g.pos;
						if(_g.tok._hx_index == 20) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var e2 = this.expr();
							var _g = this.peek(0);
							var _g1 = _g.pos;
							if(_g.tok._hx_index == 11) {
								this.last = this.token.elt;
								this.token = this.token.next;
								var e3 = this.expr();
								return { expr : haxe_macro_ExprDef.ETernary(e1,e2,e3), pos : haxeparser_HaxeParser.punion(e1.pos,e3.pos)};
							} else {
								throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
							}
						} else {
							return e1;
						}
					}
				} else {
					var _g = this.peek(0);
					var _g1 = _g.pos;
					if(_g.tok._hx_index == 20) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var e2 = this.expr();
						var _g = this.peek(0);
						var _g1 = _g.pos;
						if(_g.tok._hx_index == 11) {
							this.last = this.token.elt;
							this.token = this.token.next;
							var e3 = this.expr();
							return { expr : haxe_macro_ExprDef.ETernary(e1,e2,e3), pos : haxeparser_HaxeParser.punion(e1.pos,e3.pos)};
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						return e1;
					}
				}
			}
		}
	}
	,parseField: function(e1,p) {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		switch(_g2._hx_index) {
		case 0:
			var _g = _g2.k;
			switch(_g._hx_index) {
			case 0:
				var p2 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.exprNext({ expr : haxe_macro_ExprDef.EField(e1,"function"), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
			case 22:
				var p2 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.exprNext({ expr : haxe_macro_ExprDef.EField(e1,"new"), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
			case 25:
				var p2 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.exprNext({ expr : haxe_macro_ExprDef.EField(e1,"extern"), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
			case 40:
				var p2 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.exprNext({ expr : haxe_macro_ExprDef.EField(e1,"macro"), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
			default:
				var p2 = _g1;
				var k = _g;
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.exprNext({ expr : haxe_macro_ExprDef.EField(e1,haxeparser_KeywordPrinter.toString(k)), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
			}
			break;
		case 1:
			var _g = _g2.c;
			if(_g._hx_index == 3) {
				var p2 = _g1;
				var f = _g.s;
				this.last = this.token.elt;
				this.token = this.token.next;
				return this.exprNext({ expr : haxe_macro_ExprDef.EField(e1,f), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
			} else {
				var _g = e1.expr;
				if(_g._hx_index == 0) {
					var _g3 = _g.c;
					if(_g3._hx_index == 0) {
						var p2 = e1.pos;
						var v = _g3.v;
						if(p2.max == p.min) {
							return this.exprNext({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CFloat(v + ".")), pos : haxeparser_HaxeParser.punion(p,p2)});
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			}
			break;
		case 3:
			var p2 = _g1;
			var v = _g2.s;
			this.last = this.token.elt;
			this.token = this.token.next;
			return this.exprNext({ expr : haxe_macro_ExprDef.EField(e1,"$" + v), pos : haxeparser_HaxeParser.punion(e1.pos,p2)});
		default:
			var _g = e1.expr;
			if(_g._hx_index == 0) {
				var _g1 = _g.c;
				if(_g1._hx_index == 0) {
					var p2 = e1.pos;
					var v = _g1.v;
					if(p2.max == p.min) {
						return this.exprNext({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CFloat(v + ".")), pos : haxeparser_HaxeParser.punion(p,p2)});
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			}
		}
	}
	,parseGuard: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g1 = _g.tok;
		if(_g1._hx_index == 0) {
			if(_g1.k._hx_index == 3) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var _g = this.peek(0);
				var _g1 = _g.pos;
				if(_g.tok._hx_index == 18) {
					this.last = this.token.elt;
					this.token = this.token.next;
					var e = this.expr();
					var _g = this.peek(0);
					var _g1 = _g.pos;
					if(_g.tok._hx_index == 19) {
						this.last = this.token.elt;
						this.token = this.token.next;
						return e;
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseExprOrVar: function() {
		var _g = this.peek(0);
		var _g1 = _g.pos;
		var _g2 = _g.tok;
		if(_g2._hx_index == 0) {
			switch(_g2.k._hx_index) {
			case 2:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var name = this.dollarIdent();
				return { expr : haxe_macro_ExprDef.EVars([{ name : name.name, type : null, expr : null}]), pos : p1};
			case 41:
				var p1 = _g1;
				this.last = this.token.elt;
				this.token = this.token.next;
				var name = this.dollarIdent();
				return { expr : haxe_macro_ExprDef.EVars([{ name : name.name, type : null, expr : null}]), pos : p1};
			default:
				var e = this.expr();
				return e;
			}
		} else {
			var e = this.expr();
			return e;
		}
	}
	,parseSwitchCases: function() {
		var cases = [];
		var def = null;
		var caseBlock = function(b,p) {
			if(b.length == 0) {
				return null;
			} else if(b.length == 1) {
				var _g = b[0];
				var _g1 = _g.pos;
				var _g1 = _g.expr;
				if(_g1._hx_index == 12) {
					var el = _g1.exprs;
					var e = _g;
					return e;
				} else {
					return { expr : haxe_macro_ExprDef.EBlock(b), pos : p};
				}
			} else {
				return { expr : haxe_macro_ExprDef.EBlock(b), pos : p};
			}
		};
		_hx_loop1: while(true) {
			var _g = this.peek(0);
			var _g1 = _g.pos;
			var _g2 = _g.tok;
			if(_g2._hx_index == 0) {
				switch(_g2.k._hx_index) {
				case 15:
					var p1 = _g1;
					this.last = this.token.elt;
					this.token = this.token.next;
					var el = this.psep(haxeparser_TokenDef.Comma,$bind(this,this.parseExprOrVar));
					var eg = this.parseOptional($bind(this,this.parseGuard));
					var _g3 = this.peek(0);
					var _g4 = _g3.pos;
					if(_g3.tok._hx_index == 11) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var b = this.block([]);
						var e = caseBlock(b,p1);
						cases.push({ values : el, guard : eg, expr : e});
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
					break;
				case 16:
					var p11 = _g1;
					this.last = this.token.elt;
					this.token = this.token.next;
					var _g5 = this.peek(0);
					var _g6 = _g5.pos;
					if(_g5.tok._hx_index == 11) {
						this.last = this.token.elt;
						this.token = this.token.next;
						var b1 = this.block([]);
						var e1 = caseBlock(b1,p11);
						if(e1 == null) {
							e1 = { expr : null, pos : p11};
						}
						if(def != null) {
							throw haxe_Exception.thrown(new haxeparser_ParserError(haxeparser_ParserErrorMsg.DuplicateDefault,p11));
						}
						def = e1;
					} else {
						throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
					}
					break;
				default:
					break _hx_loop1;
				}
			} else {
				break;
			}
		}
		return { cases : cases, def : def};
	}
	,parseCatch: function() {
		var _g = this.peek(0);
		var _g1 = _g.tok;
		if(_g1._hx_index == 0) {
			if(_g1.k._hx_index == 21) {
				var p = _g.pos;
				this.last = this.token.elt;
				this.token = this.token.next;
				var _g = this.peek(0);
				var _g1 = _g.pos;
				if(_g.tok._hx_index == 18) {
					this.last = this.token.elt;
					this.token = this.token.next;
					var id = this.ident();
					try {
						var t = this.parseTypeHint();
						var _g = this.peek(0);
						var _g1 = _g.pos;
						if(_g.tok._hx_index == 19) {
							this.last = this.token.elt;
							this.token = this.token.next;
							return { name : id.name, type : t, expr : this.secureExpr()};
						} else {
							throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
						}
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
							throw haxe_Exception.thrown(new haxeparser_ParserError(haxeparser_ParserErrorMsg.MissingType,p));
						} else {
							throw _g;
						}
					}
				} else {
					throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
				}
			} else {
				throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
			}
		} else {
			throw haxe_Exception.thrown(new hxparse_NoMatch(this.stream.curPos(),this.peek(0)));
		}
	}
	,parseCallParams: function() {
		var ret = [];
		try {
			var e = this.expr();
			ret.push(e);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return [];
			} else {
				throw _g;
			}
		}
		while(true) {
			var _g = this.peek(0);
			var _g1 = _g.pos;
			if(_g.tok._hx_index == 13) {
				this.last = this.token.elt;
				this.token = this.token.next;
				var e = this.expr();
				ret.push(e);
			} else {
				break;
			}
		}
		return ret;
	}
	,secureExpr: function() {
		return this.expr();
	}
	,__class__: haxeparser_HaxeParser
});
var haxeparser__$HaxeParser_Reificator = function(inMacro) {
	this.curPos = null;
	this.inMacro = inMacro;
};
$hxClasses["haxeparser._HaxeParser.Reificator"] = haxeparser__$HaxeParser_Reificator;
haxeparser__$HaxeParser_Reificator.__name__ = "haxeparser._HaxeParser.Reificator";
haxeparser__$HaxeParser_Reificator.prototype = {
	curPos: null
	,inMacro: null
	,mkEnum: function(ename,name,vl,p) {
		var constr = { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent(name)), pos : p};
		if(vl.length == 0) {
			return constr;
		} else {
			return { expr : haxe_macro_ExprDef.ECall(constr,vl), pos : p};
		}
	}
	,toConst: function(c,p) {
		var _gthis = this;
		var cst = function(n,v) {
			return _gthis.mkEnum("Constant",n,[{ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString(v)), pos : p}],p);
		};
		switch(c._hx_index) {
		case 0:
			var i = c.v;
			return cst("CInt",i);
		case 1:
			var s = c.f;
			return cst("CFloat",s);
		case 2:
			var _g = c.kind;
			var s = c.s;
			return cst("CString",s);
		case 3:
			var s = c.s;
			return cst("CIdent",s);
		case 4:
			var o = c.opt;
			var r = c.r;
			return this.mkEnum("Constant","CRegexp",[{ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString(r)), pos : p},{ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString(o)), pos : p}],p);
		}
	}
	,toBinop: function(o,p) {
		var _gthis = this;
		var op = function(n) {
			return _gthis.mkEnum("Binop",n,[],p);
		};
		switch(o._hx_index) {
		case 0:
			return op("OpAdd");
		case 1:
			return op("OpMult");
		case 2:
			return op("OpDiv");
		case 3:
			return op("OpSub");
		case 4:
			return op("OpAssign");
		case 5:
			return op("OpEq");
		case 6:
			return op("OpNotEq");
		case 7:
			return op("OpGt");
		case 8:
			return op("OpGte");
		case 9:
			return op("OpLt");
		case 10:
			return op("OpLte");
		case 11:
			return op("OpAnd");
		case 12:
			return op("OpOr");
		case 13:
			return op("OpXor");
		case 14:
			return op("OpBoolAnd");
		case 15:
			return op("OpBoolOr");
		case 16:
			return op("OpShl");
		case 17:
			return op("OpShr");
		case 18:
			return op("OpUShr");
		case 19:
			return op("OpMod");
		case 20:
			var o1 = o.op;
			return this.mkEnum("Binop","OpAssignOp",[this.toBinop(o1,p)],p);
		case 21:
			return op("OpInterval");
		case 22:
			return op("OpArrow");
		case 23:
			return op("OpIn");
		}
	}
	,toString: function(s,p) {
		var len = s.length;
		if(len > 1 && s.charAt(0) == "$") {
			return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent(HxOverrides.substr(s,1,null))), pos : p};
		} else {
			return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString(s)), pos : p};
		}
	}
	,toArray: function(f,a,p) {
		var vals = [];
		var _g = 0;
		while(_g < a.length) {
			var v = a[_g];
			++_g;
			vals.push(f(v,p));
		}
		var e = { pos : p, expr : haxe_macro_ExprDef.EArrayDecl(vals)};
		return e;
	}
	,toNull: function(p) {
		return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("null")), pos : p};
	}
	,toOpt: function(f,v,p) {
		if(v == null) {
			return this.toNull(p);
		} else {
			return f(v,p);
		}
	}
	,toBool: function(o,p) {
		var s = o ? "true" : "false";
		return { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent(s)), pos : p};
	}
	,toObj: function(fields,p) {
		return { expr : haxe_macro_ExprDef.EObjectDecl(fields), pos : p};
	}
	,toTParam: function(t,p) {
		var n;
		var v;
		switch(t._hx_index) {
		case 0:
			var t1 = t.t;
			n = "TPType";
			v = this.toCType(t1,p);
			break;
		case 1:
			var e = t.e;
			n = "TPExpr";
			v = this.toExpr(e,p);
			break;
		}
		return this.mkEnum("TypeParam",n,[v],p);
	}
	,toTPath: function(t,p) {
		var fields = [{ field : "pack", expr : this.toArray($bind(this,this.toString),t.pack,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "name", expr : this.toString(t.name,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "params", expr : this.toArray($bind(this,this.toTParam),t.params,p), quotes : haxe_macro_QuoteStatus.Unquoted}];
		if(t.sub != null) {
			fields.push({ field : "sub", expr : this.toString(t.sub,p), quotes : haxe_macro_QuoteStatus.Unquoted});
		}
		return this.toObj(fields,p);
	}
	,toCType: function(t,p) {
		var _gthis = this;
		var ct = function(n,vl) {
			return _gthis.mkEnum("ComplexType",n,vl,p);
		};
		switch(t._hx_index) {
		case 0:
			var _g = t.p;
			var _g1 = _g.sub;
			var _g2 = _g.params;
			var _g3 = _g.name;
			if(_g.pack.length == 0) {
				if(_g2 == null) {
					var t1 = _g;
					return ct("TPath",[this.toTPath(t1,p)]);
				} else if(_g2.length == 0) {
					if(_g1 == null) {
						var n = _g3;
						if(n.charAt(0) == "$") {
							return this.toString(n,p);
						} else {
							var t1 = _g;
							return ct("TPath",[this.toTPath(t1,p)]);
						}
					} else {
						var t1 = _g;
						return ct("TPath",[this.toTPath(t1,p)]);
					}
				} else {
					var t1 = _g;
					return ct("TPath",[this.toTPath(t1,p)]);
				}
			} else {
				var t1 = _g;
				return ct("TPath",[this.toTPath(t1,p)]);
			}
			break;
		case 1:
			var ret = t.ret;
			var args = t.args;
			return ct("TFunction",[this.toArray($bind(this,this.toCType),args,p),this.toCType(ret,p)]);
		case 2:
			var fields = t.fields;
			return ct("TAnonymous",[this.toArray($bind(this,this.toCField),fields,p)]);
		case 3:
			var t1 = t.t;
			return ct("TParent",[this.toCType(t1,p)]);
		case 4:
			var fields = t.fields;
			var tl = t.p;
			return ct("TExtend",[this.toArray($bind(this,this.toTPath),tl,p),this.toArray($bind(this,this.toCField),fields,p)]);
		case 5:
			var t1 = t.t;
			return ct("TOptional",[this.toCType(t1,p)]);
		case 6:
			var t1 = t.t;
			var s = t.n;
			return ct("TNamed",[this.toString(s,p),this.toCType(t1,p)]);
		case 7:
			var types = t.tl;
			return ct("TIntersection",[this.toArray($bind(this,this.toCType),types,p)]);
		}
	}
	,toFun: function(f,p) {
		var _gthis = this;
		var farg = function(vv,p) {
			var n = vv.name;
			var o = vv.opt;
			var t = vv.type;
			var e = vv.value;
			var fields = [{ field : "name", expr : _gthis.toString(n,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "opt", expr : _gthis.toBool(o,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "type", expr : _gthis.toOpt($bind(_gthis,_gthis.toCType),t,p), quotes : haxe_macro_QuoteStatus.Unquoted}];
			if(e != null) {
				fields.push({ field : "value", expr : _gthis.toExpr(e,p), quotes : haxe_macro_QuoteStatus.Unquoted});
			}
			return _gthis.toObj(fields,p);
		};
		var fparam = null;
		fparam = function(t,p) {
			var fields = [{ field : "name", expr : _gthis.toString(t.name,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "constraints", expr : _gthis.toArray($bind(_gthis,_gthis.toCType),t.constraints,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "params", expr : _gthis.toArray(fparam,t.params,p), quotes : haxe_macro_QuoteStatus.Unquoted}];
			return _gthis.toObj(fields,p);
		};
		var fields = [{ field : "args", expr : this.toArray(farg,f.args,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "ret", expr : this.toOpt($bind(this,this.toCType),f.ret,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "expr", expr : this.toOpt($bind(this,this.toExpr),f.expr,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "params", expr : this.toArray(fparam,f.params,p), quotes : haxe_macro_QuoteStatus.Unquoted}];
		return this.toObj(fields,p);
	}
	,toAccess: function(a,p) {
		var n;
		switch(a._hx_index) {
		case 0:
			n = "APublic";
			break;
		case 1:
			n = "APrivate";
			break;
		case 2:
			n = "AStatic";
			break;
		case 3:
			n = "AOverride";
			break;
		case 4:
			n = "ADynamic";
			break;
		case 5:
			n = "AInline";
			break;
		case 6:
			n = "AMacro";
			break;
		case 7:
			n = "AFinal";
			break;
		case 8:
			n = "AExtern";
			break;
		}
		return this.mkEnum("Access",n,[],p);
	}
	,toDisplaykind: function(dk,p) {
		var n;
		switch(dk._hx_index) {
		case 0:
			n = "DKCall";
			break;
		case 1:
			n = "DKDot";
			break;
		case 2:
			n = "DKStructure";
			break;
		case 3:
			n = "DKMarked";
			break;
		case 4:
			var _g = dk.outermost;
			n = "DKPattern";
			break;
		}
		return this.mkEnum("DisplayKind",n,[],p);
	}
	,toCField: function(f,p) {
		var _gthis = this;
		var p2 = f.pos;
		var toFType = function(k) {
			var n;
			var vl;
			switch(k._hx_index) {
			case 0:
				var e = k.e;
				var ct = k.t;
				n = "FVar";
				vl = [_gthis.toOpt($bind(_gthis,_gthis.toCType),ct,p),_gthis.toOpt($bind(_gthis,_gthis.toExpr),e,p)];
				break;
			case 1:
				var f = k.f;
				n = "FFun";
				vl = [_gthis.toFun(f,p)];
				break;
			case 2:
				var e = k.e;
				var t = k.t;
				var set = k.set;
				var get = k.get;
				n = "FProp";
				vl = [_gthis.toString(get,p),_gthis.toString(set,p),_gthis.toOpt($bind(_gthis,_gthis.toCType),t,p),_gthis.toOpt($bind(_gthis,_gthis.toExpr),e,p)];
				break;
			}
			return _gthis.mkEnum("FieldType",n,vl,p);
		};
		var fields = [];
		fields.push({ field : "name", expr : this.toString(f.name,p), quotes : haxe_macro_QuoteStatus.Unquoted});
		if(f.doc != null) {
			fields.push({ field : "doc", expr : this.toString(f.doc,p), quotes : haxe_macro_QuoteStatus.Unquoted});
		}
		if(f.access != null) {
			fields.push({ field : "access", expr : this.toArray($bind(this,this.toAccess),f.access,p), quotes : haxe_macro_QuoteStatus.Unquoted});
		}
		fields.push({ field : "kind", expr : toFType(f.kind), quotes : haxe_macro_QuoteStatus.Unquoted});
		fields.push({ field : "pos", expr : this.toPos(f.pos), quotes : haxe_macro_QuoteStatus.Unquoted});
		if(f.meta != null) {
			fields.push({ field : "meta", expr : this.toMeta(f.meta,p), quotes : haxe_macro_QuoteStatus.Unquoted});
		}
		return this.toObj(fields,p);
	}
	,toMeta: function(m,p) {
		var _gthis = this;
		return this.toArray(function(me,_) {
			var fields = [{ field : "name", expr : _gthis.toString(me.name,me.pos), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "params", expr : _gthis.toExprArray(me.params,me.pos), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "pos", expr : _gthis.toPos(me.pos), quotes : haxe_macro_QuoteStatus.Unquoted}];
			return _gthis.toObj(fields,me.pos);
		},m,p);
	}
	,toPos: function(p) {
		if(this.curPos != null) {
			return this.curPos;
		}
		var file = { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString(p.file)), pos : p};
		var pmin = { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CInt(p.min == null ? "null" : "" + p.min)), pos : p};
		var pmax = { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CInt(p.max == null ? "null" : "" + p.max)), pos : p};
		if(this.inMacro) {
			return { expr : haxe_macro_ExprDef.EUntyped({ expr : haxe_macro_ExprDef.ECall({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("$mk_pos")), pos : p},[file,pmin,pmax]), pos : p}), pos : p};
		} else {
			return this.toObj([{ field : "file", expr : file, quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "min", expr : pmin, quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "max", expr : pmax, quotes : haxe_macro_QuoteStatus.Unquoted}],p);
		}
	}
	,toEncPos: function(p) {
		if(this.curPos != null) {
			return this.curPos;
		}
		if(this.inMacro) {
			return this.toPos(p);
		} else {
			var tmp = this.toPos(p);
			return { expr : haxe_macro_ExprDef.ECall({ expr : haxe_macro_ExprDef.EField({ expr : haxe_macro_ExprDef.EField({ expr : haxe_macro_ExprDef.EField({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("haxe")), pos : p},"macro"), pos : p},"Context"), pos : p},"makePosition"), pos : p},[tmp]), pos : p};
		}
	}
	,toExprArray: function(a,p) {
		if(a.length > 0) {
			var _g = a[0].expr;
			if(_g._hx_index == 28) {
				var e1 = _g.e;
				var md = _g.s;
				if(md.name == "$a" && md.params.length == 0) {
					var _g = e1.expr;
					if(_g._hx_index == 6) {
						var el = _g.values;
						return this.toExprArray(el,p);
					} else {
						return e1;
					}
				}
			}
		}
		return this.toArray($bind(this,this.toExpr),a,p);
	}
	,toExpr: function(e,_) {
		var _gthis = this;
		var p = e.pos;
		var expr = function(n,vl) {
			var e = _gthis.mkEnum("ExprDef",n,vl,p);
			var _gthis1 = _gthis;
			var expr = _gthis.toPos(p);
			return _gthis1.toObj([{ field : "expr", expr : e, quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "pos", expr : expr, quotes : haxe_macro_QuoteStatus.Unquoted}],p);
		};
		var loop = function(e) {
			return _gthis.toExpr(e,e.pos);
		};
		var _g = e.expr;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var n = _g1.s;
				if(n.charAt(0) == "$" && n.length > 1) {
					return this.toString(n,p);
				} else {
					var c = _g1;
					return expr("EConst",[this.toConst(c,p)]);
				}
			} else {
				var c = _g1;
				return expr("EConst",[this.toConst(c,p)]);
			}
			break;
		case 1:
			var e2 = _g.e2;
			var e1 = _g.e1;
			return expr("EArray",[loop(e1),loop(e2)]);
		case 2:
			var e2 = _g.e2;
			var e1 = _g.e1;
			var op = _g.op;
			return expr("EBinop",[this.toBinop(op,p),loop(e1),loop(e2)]);
		case 3:
			var s = _g.field;
			var e1 = _g.e;
			return expr("EField",[loop(e1),this.toString(s,p)]);
		case 4:
			var e1 = _g.e;
			return expr("EParenthesis",[loop(e1)]);
		case 5:
			var fl = _g.fields;
			return expr("EObjectDecl",[this.toArray(function(f,p2) {
				return _gthis.toObj([{ field : "field", expr : _gthis.toString(f.field,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "expr", expr : loop(f.expr), quotes : haxe_macro_QuoteStatus.Unquoted}],p2);
			},fl,p)]);
		case 6:
			var el = _g.values;
			return expr("EArrayDecl",[this.toExprArray(el,p)]);
		case 7:
			var el = _g.params;
			var e1 = _g.e;
			return expr("ECall",[loop(e1),this.toExprArray(el,p)]);
		case 8:
			var el = _g.params;
			var t = _g.t;
			return expr("ENew",[this.toTPath(t,p),this.toExprArray(el,p)]);
		case 9:
			var e1 = _g.e;
			var isPostfix = _g.postFix;
			var op = _g.op;
			var ops;
			switch(op._hx_index) {
			case 0:
				ops = "OpIncrement";
				break;
			case 1:
				ops = "OpDecrement";
				break;
			case 2:
				ops = "OpNot";
				break;
			case 3:
				ops = "OpNeg";
				break;
			case 4:
				ops = "OpNegBits";
				break;
			}
			var op2 = this.mkEnum("Unop",ops,[],p);
			return expr("EUnop",[op2,this.toBool(isPostfix,p),loop(e1)]);
		case 10:
			var vl = _g.vars;
			return expr("EVars",[this.toArray(function(vv,p) {
				var name = vv.name;
				var type = vv.type;
				var expr = vv.expr;
				var isFinal = vv.isFinal;
				var fields = [{ field : "name", expr : _gthis.toString(name,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "type", expr : _gthis.toOpt($bind(_gthis,_gthis.toCType),type,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "expr", expr : _gthis.toOpt($bind(_gthis,_gthis.toExpr),expr,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "isFinal", expr : _gthis.toBool(isFinal,p), quotes : haxe_macro_QuoteStatus.Unquoted}];
				return _gthis.toObj(fields,p);
			},vl,p)]);
		case 11:
			var f = _g.f;
			var kind = _g.kind;
			var kind1;
			switch(kind._hx_index) {
			case 0:
				kind1 = this.mkEnum("FunctionKind","FAnonymous",[],p);
				break;
			case 1:
				var inlined = kind.inlined;
				var name = kind.name;
				kind1 = this.mkEnum("FunctionKind","FNamed",[this.toString(name,p),this.toOpt($bind(this,this.toBool),inlined,p)],p);
				break;
			case 2:
				kind1 = this.mkEnum("FunctionKind","FArrow",[],p);
				break;
			}
			return expr("EFunction",[kind1,this.toFun(f,p)]);
		case 12:
			var el = _g.exprs;
			return expr("EBlock",[this.toExprArray(el,p)]);
		case 13:
			var e2 = _g.expr;
			var e1 = _g.it;
			return expr("EFor",[loop(e1),loop(e2)]);
		case 14:
			var eelse = _g.eelse;
			var e2 = _g.eif;
			var e1 = _g.econd;
			return expr("EIf",[loop(e1),loop(e2),this.toOpt($bind(this,this.toExpr),eelse,p)]);
		case 15:
			var normalWhile = _g.normalWhile;
			var e2 = _g.e;
			var e1 = _g.econd;
			return expr("EWhile",[loop(e1),loop(e2),this.toBool(normalWhile,p)]);
		case 16:
			var def = _g.edef;
			var cases = _g.cases;
			var e1 = _g.e;
			var scase = function(swc,p) {
				var el = swc.values;
				var eg = swc.guard;
				var e = swc.expr;
				return _gthis.toObj([{ field : "values", expr : _gthis.toExprArray(el,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "guard", expr : _gthis.toOpt($bind(_gthis,_gthis.toExpr),eg,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "expr", expr : _gthis.toOpt($bind(_gthis,_gthis.toExpr),e,p), quotes : haxe_macro_QuoteStatus.Unquoted}],p);
			};
			return expr("ESwitch",[loop(e1),this.toArray(scase,cases,p),this.toOpt(function(def2,p) {
				return _gthis.toOpt(function(def3,p) {
					return _gthis.toExpr(def3,p);
				},def2,p);
			},def,p)]);
		case 17:
			var catches = _g.catches;
			var e1 = _g.e;
			var scatch = function(c,p) {
				var n = c.name;
				var t = c.type;
				var e = c.expr;
				return _gthis.toObj([{ field : "name", expr : _gthis.toString(n,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "type", expr : _gthis.toCType(t,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "expr", expr : loop(e), quotes : haxe_macro_QuoteStatus.Unquoted}],p);
			};
			return expr("ETry",[loop(e1),this.toArray(scatch,catches,p)]);
		case 18:
			var eo = _g.e;
			return expr("EReturn",[this.toOpt($bind(this,this.toExpr),eo,p)]);
		case 19:
			return expr("EBreak",[]);
		case 20:
			return expr("EContinue",[]);
		case 21:
			var e1 = _g.e;
			return expr("EUntyped",[loop(e1)]);
		case 22:
			var e1 = _g.e;
			return expr("EThrow",[loop(e1)]);
		case 23:
			var ct = _g.t;
			var e1 = _g.e;
			return expr("ECast",[loop(e1),this.toOpt($bind(this,this.toCType),ct,p)]);
		case 24:
			var dk = _g.displayKind;
			var e1 = _g.e;
			return expr("EDisplay",[loop(e1),this.toDisplaykind(dk,p)]);
		case 25:
			var t = _g.t;
			return expr("EDisplayNew",[this.toTPath(t,p)]);
		case 26:
			var e3 = _g.eelse;
			var e2 = _g.eif;
			var e1 = _g.econd;
			return expr("ETernary",[loop(e1),loop(e2),loop(e3)]);
		case 27:
			var ct = _g.t;
			var e1 = _g.e;
			return expr("ECheckType",[loop(e1),this.toCType(ct,p)]);
		case 28:
			var e1 = _g.e;
			var md = _g.s;
			switch(md.name) {
			case "$a":
				var _g = e1.expr;
				if(_g._hx_index == 6) {
					var el = _g.values;
					return expr("EArrayDecl",[this.toExprArray(el,p)]);
				} else {
					return expr("EArrayDecl",[e1]);
				}
				break;
			case "$b":
				return expr("EBlock",[e1]);
			case "$":case "$e":
				return e1;
			case "$i":
				return expr("EConst",[this.mkEnum("Constant","CIdent",[e1],e1.pos)]);
			case "$p":
				return { expr : haxe_macro_ExprDef.ECall({ expr : haxe_macro_ExprDef.EField({ expr : haxe_macro_ExprDef.EField({ expr : haxe_macro_ExprDef.EField({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("haxe")), pos : p},"macro"), pos : p},"ExprTools"), pos : p},"toFieldExpr"), pos : p},[e]), pos : p};
			case "$v":
				return { expr : haxe_macro_ExprDef.ECall({ expr : haxe_macro_ExprDef.EField({ expr : haxe_macro_ExprDef.EField({ expr : haxe_macro_ExprDef.EField({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("haxe")), pos : p},"macro"), pos : p},"Context"), pos : p},"makeExpr"), pos : p},[e,this.toPos(e.pos)]), pos : p};
			case ":pos":
				if(md.params.length == 1) {
					var old = this.curPos;
					this.curPos = md.params[0];
					var e = loop(e1);
					this.curPos = old;
					return e;
				} else {
					return expr("EMeta",[this.toObj([{ field : "name", expr : this.toString(md.name,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "params", expr : this.toExprArray(md.params,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "pos", expr : this.toPos(p), quotes : haxe_macro_QuoteStatus.Unquoted}],p),loop(e1)]);
				}
				break;
			default:
				return expr("EMeta",[this.toObj([{ field : "name", expr : this.toString(md.name,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "params", expr : this.toExprArray(md.params,p), quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "pos", expr : this.toPos(p), quotes : haxe_macro_QuoteStatus.Unquoted}],p),loop(e1)]);
			}
			break;
		}
	}
	,toTParamDecl: function(t,p) {
		var params = [];
		var _g = 0;
		var _g1 = t.params;
		while(_g < _g1.length) {
			var tp = _g1[_g];
			++_g;
			params.push(this.toTParamDecl(tp,p));
		}
		var constraints = [];
		var _g = 0;
		var _g1 = t.constraints;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			constraints.push(this.toCType(c,p));
		}
		var tmp = { field : "name", expr : this.toString(t.name,p), quotes : haxe_macro_QuoteStatus.Unquoted};
		var tmp1 = this.toMeta(t.meta,p);
		return this.toObj([tmp,{ field : "params", expr : { expr : haxe_macro_ExprDef.EArrayDecl(params), pos : p}, quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "meta", expr : tmp1, quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "constraints", expr : { expr : haxe_macro_ExprDef.EArrayDecl(constraints), pos : p}, quotes : haxe_macro_QuoteStatus.Unquoted}],p);
	}
	,toTypeDef: function(td) {
		var p = td.pos;
		var _g = td.decl;
		if(_g._hx_index == 0) {
			var d = _g.d;
			var ext = null;
			var impl = [];
			var interf = false;
			var isFinal = false;
			var isAbstract = false;
			var _g = 0;
			var _g1 = d.flags;
			while(_g < _g1.length) {
				var f = _g1[_g];
				++_g;
				switch(f._hx_index) {
				case 0:
					interf = true;
					break;
				case 1:case 2:
					break;
				case 3:
					var t = f.t;
					ext = this.toTPath(t,td.pos);
					break;
				case 4:
					var i = f.t;
					impl.push(this.toTPath(i,td.pos));
					break;
				case 5:
					isFinal = true;
					break;
				case 6:
					isAbstract = true;
					break;
				}
			}
			var params = [];
			var _g = 0;
			var _g1 = d.params;
			while(_g < _g1.length) {
				var par = _g1[_g];
				++_g;
				params.push(this.toTParamDecl(par,p));
			}
			var isExtern = false;
			var _g = 0;
			var _g1 = d.flags;
			while(_g < _g1.length) {
				var f = _g1[_g];
				++_g;
				if(f._hx_index == 1) {
					isExtern = true;
					break;
				}
			}
			var kindParams = [];
			if(ext == null) {
				kindParams.push({ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CIdent("null")), pos : p});
			} else {
				kindParams.push(ext);
			}
			kindParams.push({ expr : haxe_macro_ExprDef.EArrayDecl(impl), pos : p});
			kindParams.push(this.toBool(interf,p));
			kindParams.push(this.toBool(isFinal,p));
			kindParams.push(this.toBool(isAbstract,p));
			var fields = [];
			var _g = 0;
			var _g1 = d.data;
			while(_g < _g1.length) {
				var d1 = _g1[_g];
				++_g;
				fields.push(this.toCField(d1,p));
			}
			var tmp = { field : "name", expr : this.toString(d.name,p), quotes : haxe_macro_QuoteStatus.Unquoted};
			var tmp1 = { field : "pos", expr : this.toPos(p), quotes : haxe_macro_QuoteStatus.Unquoted};
			var tmp2 = { field : "meta", expr : this.toMeta(d.meta,p), quotes : haxe_macro_QuoteStatus.Unquoted};
			var tmp3 = { field : "isExtern", expr : this.toBool(isExtern,p), quotes : haxe_macro_QuoteStatus.Unquoted};
			var tmp4 = this.mkEnum("TypeDefKind","TDClass",kindParams,p);
			return this.toObj([{ field : "pack", expr : { expr : haxe_macro_ExprDef.EArrayDecl([]), pos : p}, quotes : haxe_macro_QuoteStatus.Unquoted},tmp,tmp1,tmp2,{ field : "params", expr : { expr : haxe_macro_ExprDef.EArrayDecl(params), pos : p}, quotes : haxe_macro_QuoteStatus.Unquoted},tmp3,{ field : "kind", expr : tmp4, quotes : haxe_macro_QuoteStatus.Unquoted},{ field : "fields", expr : { expr : haxe_macro_ExprDef.EArrayDecl(fields), pos : p}, quotes : haxe_macro_QuoteStatus.Unquoted}],td.pos);
		} else {
			throw haxe_Exception.thrown("Invalid type for reification");
		}
	}
	,__class__: haxeparser__$HaxeParser_Reificator
};
var hxargs_Args = function() { };
$hxClasses["hxargs.Args"] = hxargs_Args;
hxargs_Args.__name__ = "hxargs.Args";
var hxparse__$LexEngine_Transition = function(chars) {
	this.chars = chars;
};
$hxClasses["hxparse._LexEngine.Transition"] = hxparse__$LexEngine_Transition;
hxparse__$LexEngine_Transition.__name__ = "hxparse._LexEngine.Transition";
hxparse__$LexEngine_Transition.prototype = {
	chars: null
	,toString: function() {
		return Std.string(this.chars);
	}
	,__class__: hxparse__$LexEngine_Transition
};
var hxparse_LexerTokenSource = function(lexer,ruleset) {
	this.lexer = lexer;
	this.ruleset = ruleset;
};
$hxClasses["hxparse.LexerTokenSource"] = hxparse_LexerTokenSource;
hxparse_LexerTokenSource.__name__ = "hxparse.LexerTokenSource";
hxparse_LexerTokenSource.prototype = {
	lexer: null
	,ruleset: null
	,token: function() {
		return this.lexer.token(this.ruleset);
	}
	,curPos: function() {
		var _this = this.lexer;
		return new hxparse_Position(_this.source,_this.pos - _this.current.length,_this.pos);
	}
	,__class__: hxparse_LexerTokenSource
};
var hxparse_ParserError = function(pos) {
	this.pos = pos;
};
$hxClasses["hxparse.ParserError"] = hxparse_ParserError;
hxparse_ParserError.__name__ = "hxparse.ParserError";
hxparse_ParserError.prototype = {
	pos: null
	,toString: function() {
		return "Parser error";
	}
	,__class__: hxparse_ParserError
};
var hxparse_NoMatch = function(pos,token) {
	hxparse_ParserError.call(this,pos);
	this.token = token;
};
$hxClasses["hxparse.NoMatch"] = hxparse_NoMatch;
hxparse_NoMatch.__name__ = "hxparse.NoMatch";
hxparse_NoMatch.__super__ = hxparse_ParserError;
hxparse_NoMatch.prototype = $extend(hxparse_ParserError.prototype,{
	token: null
	,toString: function() {
		return "No match: " + Std.string(this.token);
	}
	,__class__: hxparse_NoMatch
});
var hxparse_Parser = function(stream) {
	this.stream = stream;
};
$hxClasses["hxparse.Parser"] = hxparse_Parser;
hxparse_Parser.__name__ = "hxparse.Parser";
hxparse_Parser.prototype = {
	last: null
	,stream: null
	,token: null
	,peek: function(n) {
		if(this.token == null) {
			this.token = new haxe_ds_GenericCell(this.stream.token(),null);
			--n;
		}
		var tok = this.token;
		while(n > 0) {
			if(tok.next == null) {
				tok.next = new haxe_ds_GenericCell(this.stream.token(),null);
			}
			tok = tok.next;
			--n;
		}
		return tok.elt;
	}
	,junk: function() {
		this.last = this.token.elt;
		this.token = this.token.next;
	}
	,curPos: function() {
		return this.stream.curPos();
	}
	,parseSeparated: function(separatorFunc,f) {
		var acc = [];
		while(true) {
			try {
				acc.push(f());
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
					break;
				} else {
					throw _g;
				}
			}
			if(separatorFunc(this.peek(0))) {
				this.last = this.token.elt;
				this.token = this.token.next;
			} else {
				break;
			}
		}
		return acc;
	}
	,parseOptional: function(f) {
		try {
			return f();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return null;
			} else {
				throw _g;
			}
		}
	}
	,parseRepeat: function(f) {
		var acc = [];
		while(true) try {
			acc.push(f());
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				return acc;
			} else {
				throw _g;
			}
		}
	}
	,parseExpect: function(f) {
		try {
			return f();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxparse_NoMatch)) {
				throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
			} else {
				throw _g;
			}
		}
	}
	,noMatch: function() {
		return new hxparse_NoMatch(this.stream.curPos(),this.peek(0));
	}
	,unexpected: function() {
		throw haxe_Exception.thrown(new hxparse_Unexpected(this.peek(0),this.stream.curPos()));
	}
	,__class__: hxparse_Parser
};
var hxparse_RuleBuilderImpl = function() { };
$hxClasses["hxparse.RuleBuilderImpl"] = hxparse_RuleBuilderImpl;
hxparse_RuleBuilderImpl.__name__ = "hxparse.RuleBuilderImpl";
var hxparse_State = function() {
	this.finalId = -1;
	var this1 = new Array(256);
	this.trans = this1;
};
$hxClasses["hxparse.State"] = hxparse_State;
hxparse_State.__name__ = "hxparse.State";
hxparse_State.prototype = {
	trans: null
	,finalId: null
	,__class__: hxparse_State
};
var hxparse_Unexpected = function(token,pos) {
	hxparse_ParserError.call(this,pos);
	this.token = token;
};
$hxClasses["hxparse.Unexpected"] = hxparse_Unexpected;
hxparse_Unexpected.__name__ = "hxparse.Unexpected";
hxparse_Unexpected.__super__ = hxparse_ParserError;
hxparse_Unexpected.prototype = $extend(hxparse_ParserError.prototype,{
	token: null
	,toString: function() {
		return "Unexpected " + Std.string(this.token);
	}
	,__class__: hxparse_Unexpected
});
var hxparse_UnexpectedChar = function(char,pos) {
	hxparse_ParserError.call(this,pos);
	this.char = char;
};
$hxClasses["hxparse.UnexpectedChar"] = hxparse_UnexpectedChar;
hxparse_UnexpectedChar.__name__ = "hxparse.UnexpectedChar";
hxparse_UnexpectedChar.__super__ = hxparse_ParserError;
hxparse_UnexpectedChar.prototype = $extend(hxparse_ParserError.prototype,{
	char: null
	,toString: function() {
		return "Unexpected " + this.char;
	}
	,__class__: hxparse_UnexpectedChar
});
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
$hxClasses["js.lib._ArrayBuffer.ArrayBufferCompat"] = js_lib__$ArrayBuffer_ArrayBufferCompat;
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = "js.lib._ArrayBuffer.ArrayBufferCompat";
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
var js_node_Fs = require("fs");
var js_node_KeyValue = {};
js_node_KeyValue.get_key = function(this1) {
	return this1[0];
};
js_node_KeyValue.get_value = function(this1) {
	return this1[1];
};
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_node_buffer__$Buffer_Helper = function() { };
$hxClasses["js.node.buffer._Buffer.Helper"] = js_node_buffer__$Buffer_Helper;
js_node_buffer__$Buffer_Helper.__name__ = "js.node.buffer._Buffer.Helper";
js_node_buffer__$Buffer_Helper.bytesOfBuffer = function(b) {
	var o = Object.create(haxe_io_Bytes.prototype);
	o.length = b.byteLength;
	o.b = b;
	b.bufferValue = b;
	b.hxBytes = o;
	b.bytes = b;
	return o;
};
var js_node_stream_WritableNewOptionsAdapter = {};
js_node_stream_WritableNewOptionsAdapter.from = function(options) {
	if(!Object.prototype.hasOwnProperty.call(options,"final")) {
		Object.defineProperty(options,"final",{ get : function() {
			return options.final_;
		}});
	}
	return options;
};
var js_node_url_URLSearchParamsEntry = {};
js_node_url_URLSearchParamsEntry._new = function(name,value) {
	var this1 = [name,value];
	return this1;
};
js_node_url_URLSearchParamsEntry.get_name = function(this1) {
	return this1[0];
};
js_node_url_URLSearchParamsEntry.get_value = function(this1) {
	return this1[1];
};
var sys_FileSystem = function() { };
$hxClasses["sys.FileSystem"] = sys_FileSystem;
sys_FileSystem.__name__ = "sys.FileSystem";
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return false;
	}
};
sys_FileSystem.isDirectory = function(path) {
	try {
		return js_node_Fs.statSync(path).isDirectory();
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var e = haxe_Exception.caught(_g).unwrap();
		if(e.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _g1 ) {
				throw e;
			}
			if(!stat.isDirectory()) {
				throw e;
			}
		}
	}
};
var sys_io_FileInput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
$hxClasses["sys.io.FileInput"] = sys_io_FileInput;
sys_io_FileInput.__name__ = "sys.io.FileInput";
sys_io_FileInput.__super__ = haxe_io_Input;
sys_io_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	fd: null
	,pos: null
	,readByte: function() {
		var buf = js_node_buffer_Buffer.alloc(1);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		if(bytesRead == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		if(bytesRead == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,eof: function() {
		return this.pos >= js_node_Fs.fstatSync(this.fd).size;
	}
	,__class__: sys_io_FileInput
});
var sys_io_FileOutput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
$hxClasses["sys.io.FileOutput"] = sys_io_FileOutput;
sys_io_FileOutput.__name__ = "sys.io.FileOutput";
sys_io_FileOutput.__super__ = haxe_io_Output;
sys_io_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	fd: null
	,pos: null
	,writeByte: function(b) {
		var buf = js_node_buffer_Buffer.alloc(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,__class__: sys_io_FileOutput
});
var sys_io_FileSeek = $hxEnums["sys.io.FileSeek"] = { __ename__ : true, __constructs__ : ["SeekBegin","SeekCur","SeekEnd"]
	,SeekBegin: {_hx_index:0,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekCur: {_hx_index:1,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekEnd: {_hx_index:2,__enum__:"sys.io.FileSeek",toString:$estr}
};
var tokentree_ToTokenTreeDef = {};
tokentree_ToTokenTreeDef._new = function(tok) {
	var this1 = tok;
	return this1;
};
tokentree_ToTokenTreeDef.toTokenTreeDef = function(this1) {
	return this1;
};
tokentree_ToTokenTreeDef.fromTokenDef = function(tok) {
	var tmp;
	switch(tok._hx_index) {
	case 0:
		var k = tok.k;
		tmp = tokentree_TokenTreeDef.Kwd(k);
		break;
	case 1:
		var c = tok.c;
		tmp = tokentree_TokenTreeDef.Const(c);
		break;
	case 2:
		var s = tok.s;
		tmp = tokentree_TokenTreeDef.Sharp(s);
		break;
	case 3:
		var s = tok.s;
		tmp = tokentree_TokenTreeDef.Dollar(s);
		break;
	case 4:
		var op = tok.op;
		tmp = tokentree_TokenTreeDef.Unop(op);
		break;
	case 5:
		var op = tok.op;
		tmp = tokentree_TokenTreeDef.Binop(op);
		break;
	case 6:
		var s = tok.s;
		tmp = tokentree_TokenTreeDef.Comment(s);
		break;
	case 7:
		var s = tok.s;
		tmp = tokentree_TokenTreeDef.CommentLine(s);
		break;
	case 8:
		var s = tok.s;
		tmp = tokentree_TokenTreeDef.IntInterval(s);
		break;
	case 9:
		tmp = tokentree_TokenTreeDef.Semicolon;
		break;
	case 10:
		tmp = tokentree_TokenTreeDef.Dot;
		break;
	case 11:
		tmp = tokentree_TokenTreeDef.DblDot;
		break;
	case 12:
		tmp = tokentree_TokenTreeDef.Arrow;
		break;
	case 13:
		tmp = tokentree_TokenTreeDef.Comma;
		break;
	case 14:
		tmp = tokentree_TokenTreeDef.BkOpen;
		break;
	case 15:
		tmp = tokentree_TokenTreeDef.BkClose;
		break;
	case 16:
		tmp = tokentree_TokenTreeDef.BrOpen;
		break;
	case 17:
		tmp = tokentree_TokenTreeDef.BrClose;
		break;
	case 18:
		tmp = tokentree_TokenTreeDef.POpen;
		break;
	case 19:
		tmp = tokentree_TokenTreeDef.PClose;
		break;
	case 20:
		tmp = tokentree_TokenTreeDef.Question;
		break;
	case 21:
		tmp = tokentree_TokenTreeDef.At;
		break;
	case 22:
		tmp = tokentree_TokenTreeDef.Eof;
		break;
	}
	return tokentree_ToTokenTreeDef._new(tmp);
};
var tokentree_TokenStreamMode = $hxEnums["tokentree.TokenStreamMode"] = { __ename__ : true, __constructs__ : ["Strict","Relaxed"]
	,Strict: {_hx_index:0,__enum__:"tokentree.TokenStreamMode",toString:$estr}
	,Relaxed: {_hx_index:1,__enum__:"tokentree.TokenStreamMode",toString:$estr}
};
var tokentree_TokenStream = function(tokens,bytes) {
	this.tokens = tokens;
	this.bytes = bytes;
	this.sharpIfStack = [];
	this.tempStore = [];
	this.current = 0;
};
$hxClasses["tokentree.TokenStream"] = tokentree_TokenStream;
tokentree_TokenStream.__name__ = "tokentree.TokenStream";
tokentree_TokenStream.prototype = {
	tokens: null
	,current: null
	,bytes: null
	,sharpIfStack: null
	,tempStore: null
	,hasMore: function() {
		return this.current < this.tokens.length;
	}
	,consumeToken: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("auto insert"));
			}
		}
		var token = this.tokens[this.current];
		this.current++;
		var space = "";
		return new tokentree_TokenTree(tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok)),space,token.pos,this.current - 1);
	}
	,consumeConstIdent: function() {
		var _g = this.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
				return this.consumeToken();
			} else {
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					var s = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
					throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
				case 1:
					return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent("autoInsert")));
				}
			}
			break;
		case 4:
			var _g1 = _g.s;
			return this.consumeToken();
		default:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				var s = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
				throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent("autoInsert")));
			}
		}
	}
	,consumeConst: function() {
		var _g = this.token();
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			return this.consumeToken();
		} else {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				var s = "bad token " + Std.string(this.token()) + " != Const(_)";
				throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CString("autoInsert")));
			}
		}
	}
	,consumeTokenDef: function(tokenDef) {
		if(this.matches(tokenDef)) {
			return this.consumeToken();
		}
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			var s = "bad token " + Std.string(this.token()) + " != " + Std.string(tokenDef);
			throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
		case 1:
			return this.createDummyToken(tokenDef);
		}
	}
	,consumeToTempStore: function() {
		this.tempStore.push(this.consumeToken());
	}
	,addToTempStore: function(token) {
		this.tempStore.push(token);
	}
	,applyTempStore: function(parent) {
		while(this.tempStore.length > 0) parent.addChild(this.tempStore.shift());
	}
	,hasTempStore: function() {
		return this.tempStore.length > 0;
	}
	,getTempStore: function() {
		return this.tempStore;
	}
	,clearTempStore: function() {
		this.tempStore = [];
	}
	,error: function(s) {
		throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
	}
	,formatCurrentPos: function() {
		var pos = this.tokens[this.current].pos;
		return new hxparse_Position(pos.file,pos.min,pos.max).format(this.bytes);
	}
	,matches: function(tokenDef) {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		var token = this.tokens[this.current];
		return Type.enumEq(tokenDef,tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok)));
	}
	,isSharp: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		var token = this.tokens[this.current];
		var _g = token.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.s;
			return true;
		} else {
			return false;
		}
	}
	,isTypedParam: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		var index = this.current + 1;
		var token = this.tokens[this.current];
		var _g = token.tok;
		if(_g._hx_index == 5) {
			if(_g.op._hx_index != 9) {
				return false;
			}
		} else {
			return false;
		}
		var depth = 1;
		var brDepth = 0;
		var bkDepth = 0;
		var pDepth = 0;
		while(true) {
			token = this.tokens[index++];
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				var _g1 = _g.c;
				break;
			case 3:
				var _g2 = _g.s;
				break;
			case 5:
				switch(_g.op._hx_index) {
				case 7:
					--depth;
					if(depth <= 0) {
						return true;
					}
					break;
				case 9:
					++depth;
					break;
				default:
					return false;
				}
				break;
			case 10:
				break;
			case 11:
				break;
			case 12:
				break;
			case 13:
				break;
			case 14:
				++bkDepth;
				break;
			case 15:
				if(bkDepth <= 0) {
					return false;
				}
				--bkDepth;
				break;
			case 16:
				++brDepth;
				break;
			case 17:
				if(brDepth <= 0) {
					return false;
				}
				--brDepth;
				break;
			case 18:
				++pDepth;
				break;
			case 19:
				if(pDepth <= 0) {
					return false;
				}
				--pDepth;
				break;
			default:
				return false;
			}
			if(index >= this.tokens.length) {
				return false;
			}
		}
	}
	,token: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return tokentree_TokenTreeDef.CommentLine("auto insert");
			}
		}
		return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok));
	}
	,tokenForMatch: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return tokentree_TokenTreeDef.Root;
		}
		return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok));
	}
	,peekNonCommentToken: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return tokentree_TokenTreeDef.Const(haxe_macro_Constant.CString("auto insert"));
			}
		}
		var index = this.current;
		while(index < this.tokens.length) {
			var token = this.tokens[index++];
			if(haxeparser_Token == null) {
				continue;
			}
			var _g = token.tok;
			switch(_g._hx_index) {
			case 6:
				var _g1 = _g.s;
				break;
			case 7:
				var _g2 = _g.s;
				break;
			default:
				return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok));
			}
		}
		return tokentree_TokenTreeDef.Root;
	}
	,getTokenPos: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return null;
		}
		return this.tokens[this.current].pos;
	}
	,rewind: function() {
		if(this.current <= 0) {
			return;
		}
		this.current--;
	}
	,getStreamIndex: function() {
		return this.current;
	}
	,rewindTo: function(pos) {
		this.current = pos;
	}
	,consumeOpGt: function() {
		var tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		var _g = this.token();
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				var assignTok = this.consumeToken();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGte),tok.space + assignTok.space,{ file : tok.pos.file, min : tok.pos.min, max : assignTok.pos.max},tok.index);
			case 7:
				return this.consumeOpShr(tok);
			default:
				return tok;
			}
		} else {
			return tok;
		}
	}
	,consumeOpShr: function(parent) {
		var tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		var _g = this.token();
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				var assignTok = this.consumeToken();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
			case 7:
				var innerGt = this.consumeToken();
				var _g = this.token();
				if(_g._hx_index == 6) {
					if(_g.op._hx_index == 4) {
						var assignTok = this.consumeToken();
						return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
					}
				}
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpUShr),innerGt.space,{ file : parent.pos.file, min : parent.pos.min, max : innerGt.pos.max},parent.index);
			default:
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
			}
		} else {
			return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
		}
	}
	,consumeOpSub: function(parent) {
		var tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpSub));
		var _g = this.token();
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				var _g = _g1.v;
				break;
			case 1:
				var _g = _g1.f;
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
		} else {
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		var previous = this.current - 2;
		if(previous < 0) {
			throw haxe_Exception.thrown("no more tokens");
		}
		var prevTok = this.tokens[previous];
		var _g = prevTok.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 3:case 4:case 5:case 6:case 7:case 10:case 15:case 29:
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		case 4:
			var _g1 = _g.op;
			break;
		case 5:
			var _g1 = _g.op;
			break;
		case 8:
			var _g1 = _g.s;
			break;
		case 9:case 11:case 13:case 14:case 16:case 18:case 20:
			break;
		case 19:
			if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			var _g = parent.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 3:case 4:case 5:case 6:case 7:case 21:
					break;
				default:
					return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
				}
			} else {
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		default:
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		var _g = this.token();
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				var n = _g1.v;
				var $const = this.consumeConst();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CInt("-" + n)),$const.space,{ file : tok.pos.file, min : tok.pos.min, max : $const.pos.max},tok.index);
			case 1:
				var n = _g1.f;
				var $const = this.consumeConst();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CFloat("-" + n)),$const.space,{ file : tok.pos.file, min : tok.pos.min, max : $const.pos.max},tok.index);
			default:
				throw haxe_Exception.thrown("no more tokens");
			}
		} else {
			throw haxe_Exception.thrown("no more tokens");
		}
	}
	,pushSharpIf: function(token) {
		this.sharpIfStack.push(token);
	}
	,popSharpIf: function() {
		var token = this.sharpIfStack.pop();
		if(token == null) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("dummy token"));
			}
		}
		return token;
	}
	,peekSharpIf: function() {
		if(this.sharpIfStack.length <= 0) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("dummy token"));
			}
		}
		return this.sharpIfStack[this.sharpIfStack.length - 1];
	}
	,createDummyToken: function(tokDef) {
		var pos;
		if(this.current < 0 || this.current >= this.tokens.length) {
			var prevPos = this.tokens[this.tokens.length - 1].pos;
			pos = { min : prevPos.max, max : prevPos.max, file : prevPos.file};
		} else {
			var prevPos = this.tokens[this.current].pos;
			pos = { min : prevPos.min, max : prevPos.min, file : prevPos.file};
		}
		return new tokentree_TokenTree(tokDef,"",pos,-1,true);
	}
	,__class__: tokentree_TokenStream
};
var tokentree_TokenStreamProgress = function(stream) {
	this.stream = stream;
	this.pos = -1;
};
$hxClasses["tokentree.TokenStreamProgress"] = tokentree_TokenStreamProgress;
tokentree_TokenStreamProgress.__name__ = "tokentree.TokenStreamProgress";
tokentree_TokenStreamProgress.prototype = {
	stream: null
	,pos: null
	,streamHasChanged: function() {
		if(this.pos == -1) {
			this.pos = this.stream.getStreamIndex();
			return true;
		}
		var oldPos = this.pos;
		this.pos = this.stream.getStreamIndex();
		return this.pos != oldPos;
	}
	,__class__: tokentree_TokenStreamProgress
};
var tokentree_TokenTree = function(tok,space,pos,index,inserted) {
	if(inserted == null) {
		inserted = false;
	}
	this.tok = tok;
	this.pos = pos;
	this.index = index;
	this.inserted = inserted;
	this.space = space;
	this.tokenTypeCache = { };
};
$hxClasses["tokentree.TokenTree"] = tokentree_TokenTree;
tokentree_TokenTree.__name__ = "tokentree.TokenTree";
tokentree_TokenTree.prototype = {
	tok: null
	,pos: null
	,parent: null
	,previousSibling: null
	,nextSibling: null
	,children: null
	,index: null
	,inserted: null
	,space: null
	,tokenTypeCache: null
	,matches: function(tokenDef) {
		return Type.enumEq(tokenDef,this.tok);
	}
	,isComment: function() {
		var _g = this.tok;
		switch(_g._hx_index) {
		case 7:
			var _g1 = _g.s;
			return true;
		case 8:
			var _g1 = _g.s;
			return true;
		default:
			return false;
		}
	}
	,isCIdent: function() {
		var _g = this.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g = _g1.s;
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	,isCIdentOrCString: function() {
		var _g = this.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 2:
				var _g = _g1.kind;
				var _g = _g1.s;
				return true;
			case 3:
				var _g = _g1.s;
				return true;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	,addChild: function(child) {
		if(child == null) {
			return;
		}
		if(this.children == null) {
			this.children = [];
		}
		if(this.children.length > 0) {
			child.previousSibling = this.children[this.children.length - 1];
			this.children[this.children.length - 1].nextSibling = child;
		}
		this.children.push(child);
		child.parent = this;
	}
	,hasChildren: function() {
		if(this.children == null) {
			return false;
		}
		return this.children.length > 0;
	}
	,getFirstChild: function() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[0];
	}
	,getLastChild: function() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[this.children.length - 1];
	}
	,getPos: function() {
		if(this.children == null || this.children.length <= 0) {
			return this.pos;
		}
		var fullPos = { file : this.pos.file, min : this.pos.min, max : this.pos.max};
		var childPos;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			childPos = child.getPos();
			if(childPos.min < fullPos.min) {
				fullPos.min = childPos.min;
			}
			if(childPos.max > fullPos.max) {
				fullPos.max = childPos.max;
			}
		}
		return fullPos;
	}
	,filter: function(searchFor,mode,maxLevel) {
		if(maxLevel == null) {
			maxLevel = 9999;
		}
		return this.filterCallback(function(token,depth) {
			if(depth > maxLevel) {
				return tokentree_FilterResult.SkipSubtree;
			}
			if(token.matchesAny(searchFor)) {
				if(mode == tokentree_TokenFilterMode.All) {
					return tokentree_FilterResult.FoundGoDeeper;
				}
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	,filterCallback: function(callback) {
		var results = [];
		this.internalFilterCallback(callback,results,0);
		return results;
	}
	,internalFilterCallback: function(callback,results,depth) {
		if(depth == null) {
			depth = 0;
		}
		if(this.tok._hx_index != 0) {
			switch(callback(this,depth)._hx_index) {
			case 0:
				results.push(this);
				return;
			case 1:
				results.push(this);
				break;
			case 2:
				return;
			case 3:
				break;
			}
		}
		if(this.children == null) {
			return;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 3) {
				var _g3 = _g2.s;
				child.internalFilterCallback(callback,results,depth);
			} else {
				child.internalFilterCallback(callback,results,depth + 1);
			}
		}
	}
	,matchesAny: function(searchFor) {
		if(searchFor == null || this.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		var _g = 0;
		while(_g < searchFor.length) {
			var search = searchFor[_g];
			++_g;
			if(Type.enumEq(this.tok,search)) {
				return true;
			}
		}
		return false;
	}
	,printTokenTree: function(prefix) {
		if(prefix == null) {
			prefix = "";
		}
		var buf_b = "";
		var tokString = "" + Std.string(this.tok);
		if(this.inserted) {
			tokString = "*** " + tokString + " ***";
		}
		if(this.tok != tokentree_TokenTreeDef.Root) {
			buf_b += Std.string("" + prefix + tokString + "\t\t\t\t" + Std.string(this.getPos()));
		}
		if(this.children == null) {
			return buf_b;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			buf_b += Std.string("\n" + prefix + child.printTokenTree(prefix + "  "));
		}
		return buf_b;
	}
	,toString: function() {
		return tokentree_TokenTreeDefPrinter.toString(this.tok);
	}
	,__class__: tokentree_TokenTree
};
var tokentree_TokenFilterMode = $hxEnums["tokentree.TokenFilterMode"] = { __ename__ : true, __constructs__ : ["All","First"]
	,All: {_hx_index:0,__enum__:"tokentree.TokenFilterMode",toString:$estr}
	,First: {_hx_index:1,__enum__:"tokentree.TokenFilterMode",toString:$estr}
};
var tokentree_FilterResult = $hxEnums["tokentree.FilterResult"] = { __ename__ : true, __constructs__ : ["FoundSkipSubtree","FoundGoDeeper","SkipSubtree","GoDeeper"]
	,FoundSkipSubtree: {_hx_index:0,__enum__:"tokentree.FilterResult",toString:$estr}
	,FoundGoDeeper: {_hx_index:1,__enum__:"tokentree.FilterResult",toString:$estr}
	,SkipSubtree: {_hx_index:2,__enum__:"tokentree.FilterResult",toString:$estr}
	,GoDeeper: {_hx_index:3,__enum__:"tokentree.FilterResult",toString:$estr}
};
var tokentree_TokenTreeAccessHelper = {};
tokentree_TokenTreeAccessHelper.get_token = function(this1) {
	return this1;
};
tokentree_TokenTreeAccessHelper.access = function(tok) {
	return tok;
};
tokentree_TokenTreeAccessHelper.parent = function(this1) {
	if(this1 != null) {
		return this1.parent;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.findParent = function(this1,predicate) {
	var parent = tokentree_TokenTreeAccessHelper.parent(this1);
	while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
		if(predicate(parent)) {
			return parent;
		}
		parent = tokentree_TokenTreeAccessHelper.parent(parent);
	}
	return null;
};
tokentree_TokenTreeAccessHelper.previousSibling = function(this1) {
	if(this1 != null) {
		return this1.previousSibling;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.nextSibling = function(this1) {
	if(this1 != null) {
		return this1.nextSibling;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.firstChild = function(this1) {
	if(this1 != null) {
		return this1.getFirstChild();
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.lastChild = function(this1) {
	if(this1 != null) {
		return this1.getLastChild();
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.firstOf = function(this1,token) {
	if(this1 == null || this1.children == null) {
		return null;
	}
	var _g = 0;
	var _g1 = this1.children;
	while(_g < _g1.length) {
		var tok = _g1[_g];
		++_g;
		if(Type.enumEq(tok.tok,token)) {
			return tok;
		}
	}
	return null;
};
tokentree_TokenTreeAccessHelper.lastOf = function(this1,token) {
	if(this1 == null || this1.children == null) {
		return null;
	}
	var found = null;
	var _g = 0;
	var _g1 = this1.children;
	while(_g < _g1.length) {
		var tok = _g1[_g];
		++_g;
		if(Type.enumEq(tok.tok,token)) {
			found = tok;
		}
	}
	return found;
};
tokentree_TokenTreeAccessHelper.child = function(this1,index) {
	if(this1 != null && this1.children != null) {
		return this1.children[index];
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.matches = function(this1,tok) {
	if(this1 != null && Type.enumEq(this1.tok,tok)) {
		return this1;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.isComment = function(this1) {
	if(this1 != null && this1.isComment()) {
		return this1;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.isCIdent = function(this1) {
	if(this1 != null && this1.isCIdent()) {
		return this1;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.or = function(this1,other) {
	if(this1 != null) {
		return this1;
	} else {
		return other;
	}
};
tokentree_TokenTreeAccessHelper.exists = function(this1) {
	return this1 != null;
};
var tokentree_TokenTreeBuilder = function() { };
$hxClasses["tokentree.TokenTreeBuilder"] = tokentree_TokenTreeBuilder;
tokentree_TokenTreeBuilder.__name__ = "tokentree.TokenTreeBuilder";
tokentree_TokenTreeBuilder.buildTokenTree = function(tokens,bytes,entryPoint) {
	if(entryPoint == null) {
		entryPoint = tokentree_TokenTreeEntryPoint.TypeLevel;
	}
	return tokentree_TokenTreeBuilder.buildTokenTreeFromStream(new tokentree_TokenStream(tokens,bytes),entryPoint);
};
tokentree_TokenTreeBuilder.buildTokenTreeFromStream = function(stream,entryPoint) {
	var root = new tokentree_TokenTree(tokentree_TokenTreeDef.Root,"",null,-1);
	switch(entryPoint._hx_index) {
	case 0:
		tokentree_walk_WalkFile.walkFile(stream,root);
		break;
	case 1:
		tokentree_walk_WalkClass.walkClassBody(stream,root);
		break;
	case 2:
		tokentree_walk_WalkStatement.walkStatement(stream,root);
		break;
	case 3:
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,root);
		break;
	}
	if(stream.hasMore()) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stream.token()));
		case 1:
			var progress = new tokentree_TokenStreamProgress(stream);
			while(progress.streamHasChanged()) tokentree_walk_WalkStatement.walkStatement(stream,root);
			if(stream.hasMore()) {
				throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stream.token()));
			}
			break;
		}
	}
	var tempStore = stream.getTempStore();
	switch(tokentree_TokenStream.MODE._hx_index) {
	case 0:
		if(tempStore.length != 0) {
			throw haxe_Exception.thrown("invalid token tree structure - tokens in temp store:" + tempStore.join(", "));
		}
		break;
	case 1:
		var _g = 0;
		while(_g < tempStore.length) {
			var stored = tempStore[_g];
			++_g;
			root.addChild(stored);
		}
		break;
	}
	return root;
};
var tokentree_TokenTreeEntryPoint = $hxEnums["tokentree.TokenTreeEntryPoint"] = { __ename__ : true, __constructs__ : ["TypeLevel","FieldLevel","ExpressionLevel","TypeHintLevel"]
	,TypeLevel: {_hx_index:0,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,FieldLevel: {_hx_index:1,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,ExpressionLevel: {_hx_index:2,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,TypeHintLevel: {_hx_index:3,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
};
var tokentree_TokenTreeDef = $hxEnums["tokentree.TokenTreeDef"] = { __ename__ : true, __constructs__ : ["Root","Kwd","Const","Sharp","Dollar","Unop","Binop","Comment","CommentLine","IntInterval","Semicolon","Dot","DblDot","Arrow","Comma","BkOpen","BkClose","BrOpen","BrClose","POpen","PClose","Question","At","Eof"]
	,Root: {_hx_index:0,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Kwd: ($_=function(k) { return {_hx_index:1,k:k,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["k"],$_)
	,Const: ($_=function(c) { return {_hx_index:2,c:c,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Dollar: ($_=function(s) { return {_hx_index:4,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Unop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Binop: ($_=function(op) { return {_hx_index:6,op:op,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Comment: ($_=function(s) { return {_hx_index:7,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:8,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,IntInterval: ($_=function(s) { return {_hx_index:9,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Semicolon: {_hx_index:10,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Dot: {_hx_index:11,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,DblDot: {_hx_index:12,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Arrow: {_hx_index:13,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Comma: {_hx_index:14,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BkOpen: {_hx_index:15,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BkClose: {_hx_index:16,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BrOpen: {_hx_index:17,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BrClose: {_hx_index:18,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,POpen: {_hx_index:19,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,PClose: {_hx_index:20,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Question: {_hx_index:21,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,At: {_hx_index:22,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Eof: {_hx_index:23,__enum__:"tokentree.TokenTreeDef",toString:$estr}
};
var tokentree_TokenTreeDefPrinter = function() { };
$hxClasses["tokentree.TokenTreeDefPrinter"] = tokentree_TokenTreeDefPrinter;
tokentree_TokenTreeDefPrinter.__name__ = "tokentree.TokenTreeDefPrinter";
tokentree_TokenTreeDefPrinter.toString = function(def) {
	switch(def._hx_index) {
	case 0:
		return "<root>";
	case 1:
		var k = def.k;
		return HxOverrides.substr($hxEnums[k.__enum__].__constructs__[k._hx_index],3,null).toLowerCase();
	case 2:
		var _g = def.c;
		switch(_g._hx_index) {
		case 0:
			var s = _g.v;
			return s;
		case 1:
			var s = _g.f;
			return s;
		case 2:
			var _g1 = _g.kind;
			var s = _g.s;
			return "\"" + s + "\"";
		case 3:
			var s = _g.s;
			return s;
		case 4:
			var opt = _g.opt;
			var r = _g.r;
			return "~/" + r + "/" + opt;
		}
		break;
	case 3:
		var s = def.s;
		return "#" + s;
	case 4:
		var s = def.s;
		return "$" + s;
	case 5:
		var op = def.op;
		return new haxe_macro_Printer("").printUnop(op);
	case 6:
		var op = def.op;
		return new haxe_macro_Printer("").printBinop(op);
	case 7:
		var s = def.s;
		return "/*" + s + "*/";
	case 8:
		var s = def.s;
		return "//" + s;
	case 9:
		var s = def.s;
		return "" + s + "...";
	case 10:
		return ";";
	case 11:
		return ".";
	case 12:
		return ":";
	case 13:
		return "->";
	case 14:
		return ",";
	case 15:
		return "[";
	case 16:
		return "]";
	case 17:
		return "{";
	case 18:
		return "}";
	case 19:
		return "(";
	case 20:
		return ")";
	case 21:
		return "?";
	case 22:
		return "@";
	case 23:
		return "<eof>";
	}
};
var tokentree_utils_TokenTreeCheckUtils = function() { };
$hxClasses["tokentree.utils.TokenTreeCheckUtils"] = tokentree_utils_TokenTreeCheckUtils;
tokentree_utils_TokenTreeCheckUtils.__name__ = "tokentree.utils.TokenTreeCheckUtils";
tokentree_utils_TokenTreeCheckUtils.isImportMult = function(token) {
	var _g = token.tok;
	switch(_g._hx_index) {
	case 6:
		if(_g.op._hx_index == 1) {
			return tokentree_utils_TokenTreeCheckUtils.isImport(token.parent);
		} else {
			return false;
		}
		break;
	case 11:
		return tokentree_utils_TokenTreeCheckUtils.isImport(token.parent);
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isImport = function(token) {
	var parent = token;
	while(parent != null) {
		if(parent.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 13:
				return true;
			case 25:
				break;
			case 35:
				return true;
			case 40:
				break;
			default:
				return false;
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
			} else {
				return false;
			}
			break;
		case 6:
			if(_g.op._hx_index != 23) {
				return false;
			}
			break;
		case 11:
			break;
		default:
			return false;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isTypeParameter = function(token) {
	var _g = token.tok;
	if(_g._hx_index == 6) {
		switch(_g.op._hx_index) {
		case 7:
			return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt)) != null;
		case 9:
			return tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt)) != null;
		default:
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isOpGtTypedefExtension = function(token) {
	var _g = token.tok;
	if(_g._hx_index == 6) {
		if(_g.op._hx_index == 7) {
			return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))))),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef)) != null;
		} else {
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.filterOpSub = function(token) {
	if(token == null) {
		return false;
	}
	var _g = token.tok;
	if(!(_g._hx_index == 6 && _g.op._hx_index == 3)) {
		return false;
	}
	var prev = token.previousSibling;
	if(token.previousSibling == null) {
		prev = token.parent;
	} else {
		prev = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.previousSibling);
		if(prev == null) {
			return false;
		}
	}
	var _g = prev.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 4:
			return true;
		case 5:
			return true;
		case 6:
			return true;
		case 10:
			return true;
		default:
			return false;
		}
		break;
	case 6:
		if(_g.op._hx_index == 23) {
			return true;
		} else {
			return true;
		}
		break;
	case 12:
		return true;
	case 13:
		return true;
	case 14:
		return true;
	case 15:
		return true;
	case 16:
		return false;
	case 17:
		return true;
	case 18:
		return true;
	case 19:
		return true;
	case 20:
		var pOpen = prev.parent;
		var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(pOpen);
		switch(type._hx_index) {
		case 0:
			return true;
		case 1:
			return true;
		case 2:
			return false;
		case 3:
			return true;
		case 4:
			return true;
		case 5:
			return true;
		case 6:
			return true;
		case 7:
			return false;
		case 8:
			return true;
		case 9:
			return false;
		}
		break;
	case 21:
		return true;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isUnaryLeftSided = function(tok) {
	var child = tok.getFirstChild();
	if(child == null) {
		return false;
	}
	var _g = child.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 23:
			return true;
		case 40:
			return true;
		default:
			return false;
		}
		break;
	case 2:
		var _g1 = _g.c;
		return true;
	case 19:
		return true;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isTernary = function(token) {
	if(token == null) {
		return false;
	}
	if(token.tok._hx_index == 12) {
		return tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent);
	}
	if(token.tok._hx_index != 21) {
		return false;
	}
	if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot) == null) {
		return false;
	}
	if(token.parent == null) {
		return false;
	}
	var _g = token.parent.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:case 2:
			return false;
		case 41:
			return false;
		default:
			return true;
		}
		break;
	case 3:
		var _g1 = _g.s;
		return false;
	case 6:
		var _g1 = _g.op;
		return true;
	case 14:
		return false;
	case 19:
		var prev = token.previousSibling;
		if(prev == null) {
			return false;
		}
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prev);
		if(lastToken == null) {
			return false;
		}
		switch(lastToken.tok._hx_index) {
		case 10:
			return false;
		case 14:
			return false;
		default:
			return true;
		}
		break;
	default:
		return true;
	}
};
tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract = function(type) {
	var _g = type.tok;
	if(_g._hx_index == 1) {
		if(_g.k._hx_index == 39) {
			var name = tokentree_TokenTreeAccessHelper.firstChild(type);
			if(name == null || name.children == null || name.children.length <= 0) {
				return false;
			}
			if(tokentree_TokenTreeAccessHelper.firstOf(name,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
				return true;
			}
			var _g = 0;
			var _g1 = name.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				if(child.tok._hx_index != 22) {
					continue;
				}
				var enumTok = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum));
				if(enumTok == null) {
					continue;
				}
				return true;
			}
		}
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isTypeStructure = function(typedefToken) {
	var afterAssign = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(typedefToken)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign)));
	if(tokentree_TokenTreeAccessHelper.matches(afterAssign,tokentree_TokenTreeDef.BrOpen) == null) {
		return tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(afterAssign),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd)) != null;
	} else {
		return true;
	}
};
tokentree_utils_TokenTreeCheckUtils.isTypeEnum = function(enumToken) {
	var _g = enumToken.tok;
	if(!(_g._hx_index == 1 && _g.k._hx_index == 26)) {
		return false;
	}
	if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(enumToken)) {
		return false;
	}
	if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(enumToken),tokentree_TokenTreeDef.DblDot)),tokentree_TokenTreeDef.At) != null) {
		return false;
	}
	return true;
};
tokentree_utils_TokenTreeCheckUtils.isTypeMacroClass = function(classToken) {
	var _g = classToken.tok;
	if(_g._hx_index == 1 && _g.k._hx_index == 1) {
		return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(classToken),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdMacro)) != null;
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isBrOpenAnonTypeOrTypedef = function(token) {
	switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
	case 0:
		return false;
	case 1:
		return true;
	case 2:
		return false;
	case 3:
		return true;
	case 4:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.getName = function(token) {
	if(token == null) {
		return null;
	}
	var _g = token.tok;
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 22) {
			return "new";
		} else {
			return null;
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var ident = _g1.s;
			return ident;
		} else {
			return null;
		}
		break;
	default:
		return null;
	}
};
tokentree_utils_TokenTreeCheckUtils.getNameToken = function(token) {
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(token)) {
		return token;
	}
	var nameToken = tokentree_TokenTreeAccessHelper.firstChild(token);
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
		return nameToken;
	}
	nameToken = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(nameToken,tokentree_TokenTreeDef.Question));
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
		return nameToken;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.isNameToken = function(token) {
	if(token == null) {
		return false;
	}
	var _g = token.tok;
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 22) {
			return true;
		} else {
			return false;
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g = _g1.s;
			return true;
		} else {
			return false;
		}
		break;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.getMetadata = function(declToken) {
	var ident = tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(declToken));
	if(ident == null || !ident.hasChildren()) {
		return [];
	}
	var _this = ident.children;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(_this[i],tokentree_TokenTreeDef.At)),tokentree_TokenTreeDef.DblDot));
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = result;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null) {
			_g.push(v);
		}
	}
	return _g;
};
tokentree_utils_TokenTreeCheckUtils.getDocComment = function(declToken) {
	var access = declToken;
	while(true) {
		access = tokentree_TokenTreeAccessHelper.previousSibling(access);
		if(access == null) {
			return null;
		}
		var _g = access.tok;
		switch(_g._hx_index) {
		case 7:
			var _g1 = _g.s;
			return access;
		case 8:
			var _g2 = _g.s;
			continue;
		default:
			return null;
		}
	}
};
tokentree_utils_TokenTreeCheckUtils.isModifier = function(keyword) {
	if(keyword == null) {
		return false;
	}
	var _g = keyword.tok;
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 17:
			return true;
		case 18:
			return true;
		case 19:
			return true;
		case 25:
			return true;
		case 30:
			return true;
		case 32:
			return true;
		case 34:
			return true;
		case 40:
			return true;
		default:
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.getBrOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_BrOpenType.Unknown;
	}
	if(token.tokenTypeCache.brOpenType != null) {
		return token.tokenTypeCache.brOpenType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineBrOpenType(token);
	token.tokenTypeCache.brOpenType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineBrOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_BrOpenType.Unknown;
	}
	if(token.parent == null || token.parent.tok == tokentree_TokenTreeDef.Root) {
		return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
	}
	var _g = token.parent.tok;
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 10) {
			return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			switch(_g1.s) {
			case "from":case "to":
				return tokentree_utils_BrOpenType.AnonType;
			default:
				return tokentree_utils_BrOpenType.Block;
			}
		} else {
			return tokentree_utils_BrOpenType.Block;
		}
		break;
	case 4:
		var _g1 = _g.s;
		return tokentree_utils_BrOpenType.Block;
	case 6:
		switch(_g.op._hx_index) {
		case 4:
			if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(token.parent)) {
				return tokentree_utils_BrOpenType.TypedefDecl;
			}
			return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
		case 9:
			return tokentree_utils_BrOpenType.AnonType;
		default:
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	case 12:
		if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		var parent = token.parent.parent;
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:
				return tokentree_utils_BrOpenType.ObjectDecl;
			case 16:
				return tokentree_utils_BrOpenType.ObjectDecl;
			default:
				return tokentree_utils_BrOpenType.AnonType;
			}
			break;
		case 2:
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 2:
				var _g = _g1.kind;
				var _g = _g1.s;
				break;
			case 3:
				var _g = _g1.s;
				break;
			default:
				return tokentree_utils_BrOpenType.AnonType;
			}
			break;
		default:
			return tokentree_utils_BrOpenType.AnonType;
		}
		parent = parent.parent;
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return tokentree_utils_BrOpenType.AnonType;
			case 2:
				return tokentree_utils_BrOpenType.AnonType;
			case 41:
				return tokentree_utils_BrOpenType.AnonType;
			default:
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				return tokentree_utils_BrOpenType.AnonType;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 17:
			return tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
		case 19:
			return tokentree_utils_BrOpenType.AnonType;
		case 21:
			return tokentree_utils_BrOpenType.AnonType;
		default:
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	case 15:
		return tokentree_utils_BrOpenType.ObjectDecl;
	case 19:
		var pOpenType = tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent);
		switch(pOpenType._hx_index) {
		case 0:
			return tokentree_utils_BrOpenType.ObjectDecl;
		case 1:
			return tokentree_utils_BrOpenType.AnonType;
		case 2:
			return tokentree_utils_BrOpenType.ObjectDecl;
		case 3:
			return tokentree_utils_BrOpenType.Unknown;
		case 4:
			return tokentree_utils_BrOpenType.Unknown;
		case 5:
			return tokentree_utils_BrOpenType.Unknown;
		case 6:
			return tokentree_utils_BrOpenType.Unknown;
		case 7:
			return tokentree_utils_BrOpenType.Unknown;
		case 8:
			return tokentree_utils_BrOpenType.Unknown;
		case 9:
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	case 21:
		if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	default:
	}
	return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
};
tokentree_utils_TokenTreeCheckUtils.determinBrChildren = function(token) {
	if(token.children == null || token.children.length <= 0) {
		var _g = token.parent.tok;
		if(_g._hx_index == 1) {
			var _g1 = _g.k;
			return tokentree_utils_BrOpenType.Block;
		} else {
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
	}
	if(token.parent != null && token.parent.tok != tokentree_TokenTreeDef.Root) {
		if(token.children.length == 1) {
			var _g = token.parent.tok;
			if(_g._hx_index == 1) {
				var _g1 = _g.k;
				return tokentree_utils_BrOpenType.Block;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
		}
		if(token.children.length == 2 && token.getLastChild().tok._hx_index == 10) {
			var _g = token.parent.tok;
			if(_g._hx_index == 1) {
				var _g1 = _g.k;
				return tokentree_utils_BrOpenType.Block;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
		}
	}
	if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Arrow) != null) {
		return tokentree_utils_BrOpenType.AnonType;
	}
	if(token.nextSibling != null && token.nextSibling.tok._hx_index == 13) {
		return tokentree_utils_BrOpenType.AnonType;
	}
	var onlyComment = true;
	var _g = 0;
	var _g1 = token.children;
	while(_g < _g1.length) {
		var child = _g1[_g];
		++_g;
		var _g2 = child.tok;
		switch(_g2._hx_index) {
		case 2:
			var _g3 = _g2.c;
			switch(_g3._hx_index) {
			case 2:
				var _g4 = _g3.kind;
				var _g5 = _g3.s;
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot) == null) {
					return tokentree_utils_BrOpenType.Block;
				}
				onlyComment = false;
				break;
			case 3:
				var _g6 = _g3.s;
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot) == null) {
					return tokentree_utils_BrOpenType.Block;
				}
				onlyComment = false;
				break;
			default:
				return tokentree_utils_BrOpenType.Block;
			}
			break;
		case 3:
			var _g7 = _g2.s;
			break;
		case 7:
			var _g8 = _g2.s;
			break;
		case 8:
			var _g9 = _g2.s;
			break;
		case 18:
			if(onlyComment) {
				if(token.parent != null && token.parent.tok != tokentree_TokenTreeDef.Root) {
					var _g10 = token.parent.tok;
					if(_g10._hx_index == 1) {
						var _g11 = _g10.k;
						return tokentree_utils_BrOpenType.Block;
					} else {
						return tokentree_utils_BrOpenType.ObjectDecl;
					}
				} else {
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
			}
			return tokentree_utils_BrOpenType.ObjectDecl;
		default:
			return tokentree_utils_BrOpenType.Block;
		}
	}
	return tokentree_utils_BrOpenType.ObjectDecl;
};
tokentree_utils_TokenTreeCheckUtils.getPOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_POpenType.Expression;
	}
	switch(token.tok._hx_index) {
	case 19:
		break;
	case 20:
		return tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent);
	default:
		return tokentree_utils_POpenType.Expression;
	}
	if(token.tokenTypeCache.pOpenType != null) {
		return token.tokenTypeCache.pOpenType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determinePOpenType(token);
	token.tokenTypeCache.pOpenType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determinePOpenType = function(token) {
	var parent = token.parent;
	if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
		return tokentree_utils_POpenType.Expression;
	}
	if(tokentree_utils_TokenTreeCheckUtils.hasAtParent(token)) {
		return tokentree_utils_POpenType.At;
	}
	if(token.hasChildren() && tokentree_utils_TokenTreeCheckUtils.checkPOpenForArrowChildren(token)) {
		return tokentree_utils_POpenType.Parameter;
	}
	_hx_loop1: while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 3:
			switch(_g.s) {
			case "elseif":case "if":
				if(parent.getFirstChild() == token) {
					return tokentree_utils_POpenType.SharpCondition;
				}
				parent = parent.parent;
				break;
			default:
				break _hx_loop1;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				parent = parent.parent;
			} else {
				break _hx_loop1;
			}
			break;
		default:
			break _hx_loop1;
		}
	}
	if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
		return tokentree_utils_POpenType.Expression;
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:
			return tokentree_utils_POpenType.Parameter;
		case 3:
			var firstChild = parent.getFirstChild();
			if(firstChild == null) {
				return tokentree_utils_POpenType.IfCondition;
			}
			if(firstChild.index == token.index) {
				return tokentree_utils_POpenType.IfCondition;
			}
			return tokentree_utils_POpenType.Expression;
		case 5:
			return tokentree_utils_POpenType.WhileCondition;
		case 7:
			return tokentree_utils_POpenType.ForLoop;
		case 14:
			return tokentree_utils_POpenType.SwitchCondition;
		case 21:
			return tokentree_utils_POpenType.Catch;
		case 22:
			return tokentree_utils_POpenType.Parameter;
		default:
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g = _g1.s;
			if(parent.parent == null || parent.parent.tok == tokentree_TokenTreeDef.Root) {
				return tokentree_utils_POpenType.Call;
			}
			var _g = parent.parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					if(parent.previousSibling == null) {
						var pOpen = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.POpen);
						if(pOpen == null) {
							return tokentree_utils_POpenType.Parameter;
						}
						if(pOpen.index == token.index) {
							return tokentree_utils_POpenType.Parameter;
						}
						return tokentree_utils_POpenType.Expression;
					}
					return tokentree_utils_POpenType.Call;
				case 39:
					return tokentree_utils_POpenType.Parameter;
				default:
					return tokentree_utils_POpenType.Call;
				}
				break;
			case 17:
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent.parent)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
					return tokentree_utils_POpenType.Parameter;
				}
				return tokentree_utils_POpenType.Call;
			default:
				return tokentree_utils_POpenType.Call;
			}
		}
		break;
	case 19:
		return tokentree_utils_POpenType.Expression;
	default:
	}
	if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Arrow) != null) {
		return tokentree_utils_POpenType.Parameter;
	}
	return tokentree_utils_POpenType.Expression;
};
tokentree_utils_TokenTreeCheckUtils.checkPOpenForArrowChildren = function(token) {
	var skip = true;
	var _g = 0;
	var _g1 = token.children;
	while(_g < _g1.length) {
		var child = _g1[_g];
		++_g;
		if(child.tok._hx_index == 20) {
			skip = false;
		}
		if(skip) {
			continue;
		}
		if(child.tok._hx_index == 13) {
			return true;
		}
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.hasAtParent = function(token) {
	var parent = token.parent;
	while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			var _g1 = _g.k;
			break;
		case 2:
			var _g2 = _g.c;
			break;
		case 6:
			if(_g.op._hx_index != 23) {
				return false;
			}
			break;
		case 11:
			break;
		case 12:
			break;
		case 22:
			return true;
		default:
			return false;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isInsideTypedef = function(token) {
	if(token == null) {
		return false;
	}
	var parent = token;
	while(parent.parent != null) {
		var _g = parent.tok;
		if(_g._hx_index == 1 && _g.k._hx_index == 31) {
			return true;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isDeprecated = function(declToken) {
	return Lambda.exists(tokentree_utils_TokenTreeCheckUtils.getMetadata(declToken),function(meta) {
		var _g = meta.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				if(_g1.s == "deprecated") {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		} else {
			return false;
		}
	});
};
tokentree_utils_TokenTreeCheckUtils.getArrowType = function(token) {
	if(token == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	if(token.tokenTypeCache.arrowType != null) {
		return token.tokenTypeCache.arrowType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineArrowType(token);
	if(type == null) {
		type = tokentree_utils_ArrowType.ArrowFunction;
	}
	token.tokenTypeCache.arrowType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineArrowType = function(token) {
	if(token == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var child = token.getFirstChild();
	while(child != null) {
		var _g = child.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index != 40) {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
			} else {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				child = child.nextSibling;
				continue;
			} else {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			break;
		case 7:
			var _g3 = _g.s;
			break;
		case 8:
			var _g4 = _g.s;
			break;
		case 10:case 11:case 13:case 21:
			break;
		case 17:
			var brClose = child.getFirstChild();
			if(brClose.tok._hx_index == 18) {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			var brType = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(child);
			if(brType == null) {
				brType = tokentree_utils_BrOpenType.Unknown;
			}
			if(brType != null) {
				switch(brType._hx_index) {
				case 0:
					return tokentree_utils_ArrowType.ArrowFunction;
				case 3:
					break;
				default:
				}
			}
			child = child.nextSibling;
			continue;
		case 19:
			break;
		default:
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		child = child.getFirstChild();
	}
	var parent = token.parent;
	if(parent == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var resultType = tokentree_utils_TokenTreeCheckUtils.checkArrowParent(parent);
	if(resultType != null) {
		return resultType;
	}
	return tokentree_utils_TokenTreeCheckUtils.checkArrowChildren(parent);
};
tokentree_utils_TokenTreeCheckUtils.checkArrowChildren = function(parent) {
	var child = parent.getFirstChild();
	if(child == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var seenArrow = false;
	while(child != null) {
		var _g = child.tok;
		switch(_g._hx_index) {
		case 1:
			var _g1 = _g.k;
			return tokentree_utils_ArrowType.ArrowFunction;
		case 2:
			var _g2 = _g.c;
			if(_g2._hx_index == 3) {
				var _g3 = _g2.s;
			} else {
				return tokentree_utils_ArrowType.NewFunctionType;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				child = child.nextSibling;
				continue;
			} else {
				return tokentree_utils_ArrowType.NewFunctionType;
			}
			break;
		case 7:
			var _g4 = _g.s;
			break;
		case 8:
			var _g5 = _g.s;
			break;
		case 10:case 11:
			break;
		case 12:case 17:
			break;
		case 13:
			seenArrow = true;
			break;
		case 19:
			var result = tokentree_utils_TokenTreeCheckUtils.checkArrowPOpen(child);
			if(result != null) {
				return result;
			}
			child = child.nextSibling;
			continue;
		case 20:
			break;
		case 21:
			break;
		default:
			return tokentree_utils_ArrowType.NewFunctionType;
		}
		child = child.getFirstChild();
	}
	if(seenArrow) {
		return tokentree_utils_ArrowType.OldFunctionType;
	}
	return tokentree_utils_ArrowType.NewFunctionType;
};
tokentree_utils_TokenTreeCheckUtils.checkArrowPOpen = function(token) {
	if(token.children == null || token.children.length <= 1) {
		return null;
	}
	if(token.parent.isCIdent()) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var childArrows = token.filterCallback(function(token,index) {
		if(token.tok._hx_index == 13) {
			return tokentree_FilterResult.FoundSkipSubtree;
		} else {
			return tokentree_FilterResult.GoDeeper;
		}
	});
	if(childArrows.length <= 0) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var childArrows = token.filterCallback(function(token,index) {
		if(token.tok._hx_index == 12) {
			return tokentree_FilterResult.FoundSkipSubtree;
		} else {
			return tokentree_FilterResult.GoDeeper;
		}
	});
	if(childArrows.length > 0) {
		return tokentree_utils_ArrowType.NewFunctionType;
	}
	return tokentree_utils_ArrowType.OldFunctionType;
};
tokentree_utils_TokenTreeCheckUtils.checkArrowParent = function(parent) {
	if(parent == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g = _g1.s;
			if(parent.parent == null || parent.parent.tok == tokentree_TokenTreeDef.Root) {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			var _g = parent.parent.tok;
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 4:
					if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(parent.parent)) {
						return tokentree_utils_ArrowType.OldFunctionType;
					}
					return tokentree_utils_ArrowType.ArrowFunction;
				case 22:
					return tokentree_utils_ArrowType.ArrowFunction;
				default:
				}
				break;
			case 12:
				var type = tokentree_utils_TokenTreeCheckUtils.getColonType(parent.parent);
				switch(type._hx_index) {
				case 1:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 2:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 0:case 3:case 4:case 5:case 6:
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			case 13:
				return tokentree_utils_ArrowType.OldFunctionType;
			case 19:
				var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent.parent);
				if(type == null) {
					type = tokentree_utils_POpenType.Expression;
				}
				switch(type._hx_index) {
				case 1:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 9:
					return tokentree_utils_ArrowType.OldFunctionType;
				default:
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			default:
			}
		} else {
			return tokentree_utils_ArrowType.OldFunctionType;
		}
		break;
	case 19:
		break;
	default:
		return tokentree_utils_ArrowType.OldFunctionType;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.getColonType = function(token) {
	if(token == null) {
		return tokentree_utils_ColonType.Unknown;
	}
	if(token.tokenTypeCache.colonType != null) {
		return token.tokenTypeCache.colonType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineColonType(token);
	token.tokenTypeCache.colonType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineColonType = function(token) {
	if(token == null) {
		return tokentree_utils_ColonType.Unknown;
	}
	if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
		return tokentree_utils_ColonType.Ternary;
	}
	var parent = token.parent;
	if(parent == null) {
		return tokentree_utils_ColonType.Unknown;
	}
	var _g = parent.tok;
	if(_g._hx_index == 3) {
		var _g1 = _g.s;
		parent = parent.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return tokentree_utils_ColonType.Unknown;
		}
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:
			return tokentree_utils_ColonType.TypeHint;
		case 15:case 16:
			return tokentree_utils_ColonType.SwitchCase;
		case 22:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		case 23:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		default:
		}
		break;
	case 2:
		var _g1 = _g.c;
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
	case 6:
		if(_g.op._hx_index == 9) {
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		}
		break;
	case 17:
		var brClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose);
		if(brClose == null) {
			return tokentree_utils_ColonType.Unknown;
		}
		if(brClose.pos.max <= token.pos.min) {
			return tokentree_utils_ColonType.TypeCheck;
		}
		break;
	case 19:
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(token);
	case 21:
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
	case 22:
		return tokentree_utils_ColonType.At;
	default:
	}
	return tokentree_utils_ColonType.Unknown;
};
tokentree_utils_TokenTreeCheckUtils.findColonParent = function(token) {
	var parent = token;
	while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:case 2:case 41:
				return tokentree_utils_ColonType.TypeHint;
			default:
			}
			break;
		case 17:
			var brType = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
			switch(brType._hx_index) {
			case 0:
				return tokentree_utils_ColonType.Unknown;
			case 1:
				return tokentree_utils_ColonType.TypeHint;
			case 2:
				return tokentree_utils_ColonType.ObjectLiteral;
			case 3:
				return tokentree_utils_ColonType.TypeHint;
			case 4:
				return tokentree_utils_ColonType.Unknown;
			}
			break;
		case 19:
			var pClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
			if(pClose != null && pClose.pos.max <= token.pos.min) {
				return tokentree_utils_ColonType.TypeCheck;
			}
			var pType = tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent);
			switch(pType._hx_index) {
			case 0:
				return tokentree_utils_ColonType.ObjectLiteral;
			case 1:
				return tokentree_utils_ColonType.TypeHint;
			case 2:
				return tokentree_utils_ColonType.Unknown;
			case 3:
				return tokentree_utils_ColonType.TypeCheck;
			case 4:
				return tokentree_utils_ColonType.Unknown;
			case 5:
				return tokentree_utils_ColonType.Unknown;
			case 6:
				return tokentree_utils_ColonType.Unknown;
			case 7:
				return tokentree_utils_ColonType.Unknown;
			case 8:
				return tokentree_utils_ColonType.TypeCheck;
			case 9:
				return tokentree_utils_ColonType.TypeCheck;
			}
			break;
		default:
		}
		parent = parent.parent;
	}
	return tokentree_utils_ColonType.Unknown;
};
tokentree_utils_TokenTreeCheckUtils.getLastToken = function(token) {
	if(token == null) {
		return null;
	}
	if(token.children == null) {
		return token;
	}
	if(token.children.length <= 0) {
		return token;
	}
	var lastChild = token.getLastChild();
	while(lastChild != null) {
		var newLast = lastChild.getLastChild();
		if(newLast == null) {
			return lastChild;
		}
		lastChild = newLast;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.isMetadata = function(token) {
	if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
		return false;
	}
	var parent = token.parent;
	while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) switch(parent.tok._hx_index) {
	case 12:
		parent = parent.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		if(parent.tok._hx_index == 22) {
			return true;
		} else {
			return false;
		}
		break;
	case 22:
		return true;
	default:
		parent = parent.parent;
	}
	return false;
};
var tokentree_utils_BrOpenType = $hxEnums["tokentree.utils.BrOpenType"] = { __ename__ : true, __constructs__ : ["Block","TypedefDecl","ObjectDecl","AnonType","Unknown"]
	,Block: {_hx_index:0,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,TypedefDecl: {_hx_index:1,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,ObjectDecl: {_hx_index:2,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,AnonType: {_hx_index:3,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,Unknown: {_hx_index:4,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
};
var tokentree_utils_POpenType = $hxEnums["tokentree.utils.POpenType"] = { __ename__ : true, __constructs__ : ["At","Parameter","Call","SwitchCondition","WhileCondition","IfCondition","SharpCondition","Catch","ForLoop","Expression"]
	,At: {_hx_index:0,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Parameter: {_hx_index:1,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Call: {_hx_index:2,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,SwitchCondition: {_hx_index:3,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,WhileCondition: {_hx_index:4,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,IfCondition: {_hx_index:5,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,SharpCondition: {_hx_index:6,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Catch: {_hx_index:7,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,ForLoop: {_hx_index:8,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Expression: {_hx_index:9,__enum__:"tokentree.utils.POpenType",toString:$estr}
};
var tokentree_utils_ArrowType = $hxEnums["tokentree.utils.ArrowType"] = { __ename__ : true, __constructs__ : ["ArrowFunction","OldFunctionType","NewFunctionType"]
	,ArrowFunction: {_hx_index:0,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,OldFunctionType: {_hx_index:1,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,NewFunctionType: {_hx_index:2,__enum__:"tokentree.utils.ArrowType",toString:$estr}
};
var tokentree_utils_ColonType = $hxEnums["tokentree.utils.ColonType"] = { __ename__ : true, __constructs__ : ["SwitchCase","TypeHint","TypeCheck","Ternary","ObjectLiteral","At","Unknown"]
	,SwitchCase: {_hx_index:0,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TypeHint: {_hx_index:1,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TypeCheck: {_hx_index:2,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,Ternary: {_hx_index:3,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,ObjectLiteral: {_hx_index:4,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,At: {_hx_index:5,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,Unknown: {_hx_index:6,__enum__:"tokentree.utils.ColonType",toString:$estr}
};
var tokentree_walk_WalkAbstract = function() { };
$hxClasses["tokentree.walk.WalkAbstract"] = tokentree_walk_WalkAbstract;
tokentree_walk_WalkAbstract.__name__ = "tokentree.walk.WalkAbstract";
tokentree_walk_WalkAbstract.walkAbstract = function(stream,parent) {
	var typeTok = stream.consumeToken();
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 1:case 27:
			stream.addToTempStore(typeTok);
			tokentree_walk_WalkType.walkType(stream,parent);
			return;
		default:
		}
	}
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	if(stream.tokenForMatch()._hx_index == 19) {
		tokentree_walk_WalkPOpen.walkPOpen(stream,name);
	}
	var typeParent = name;
	var typeChild;
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "from":case "to":
					var fromToken = stream.consumeToken();
					name.addChild(fromToken);
					tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,fromToken);
					break;
				default:
					typeChild = stream.consumeToken();
					typeParent.addChild(typeChild);
					typeParent = typeChild;
				}
			} else {
				typeChild = stream.consumeToken();
				typeParent.addChild(typeChild);
				typeParent = typeChild;
			}
			break;
		case 7:
			var _g2 = _g.s;
			name.addChild(stream.consumeToken());
			break;
		case 8:
			var _g3 = _g.s;
			name.addChild(stream.consumeToken());
			break;
		case 17:
			break _hx_loop1;
		default:
			typeChild = stream.consumeToken();
			typeParent.addChild(typeChild);
			typeParent = typeChild;
		}
	}
	var block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkAbstract.walkAbstractBody(stream,block);
	block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
};
tokentree_walk_WalkAbstract.walkAbstractBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				stream.consumeToTempStore();
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkAbstract.walkAbstractBody);
			break;
		case 7:
			var _g2 = _g.s;
			parent.addChild(stream.consumeToken());
			break;
		case 8:
			var _g3 = _g.s;
			parent.addChild(stream.consumeToken());
			break;
		case 10:
			parent.addChild(stream.consumeToken());
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.consumeToTempStore();
		}
	}
	stream.applyTempStore(parent);
};
var tokentree_walk_WalkArrayAccess = function() { };
$hxClasses["tokentree.walk.WalkArrayAccess"] = tokentree_walk_WalkArrayAccess;
tokentree_walk_WalkArrayAccess.__name__ = "tokentree.walk.WalkArrayAccess";
tokentree_walk_WalkArrayAccess.walkArrayAccess = function(stream,parent) {
	var bkOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.BkOpen);
	parent.addChild(bkOpen);
	stream.applyTempStore(bkOpen);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,bkOpen);
				break;
			case 5:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkWhile.walkWhile(stream,bkOpen);
				break;
			case 7:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkFor.walkFor(stream,bkOpen);
				break;
			default:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
			}
			break;
		case 6:
			if(_g.op._hx_index == 22) {
				var child = bkOpen.getLastChild();
				if(child == null) {
					child = bkOpen;
				}
				tokentree_walk_WalkStatement.walkStatement(stream,child);
			} else {
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
			}
			break;
		case 14:
			var comma = stream.consumeToken();
			var child1 = bkOpen.getLastChild();
			if(child1 == null) {
				child1 = bkOpen;
			}
			child1.addChild(comma);
			break;
		case 15:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,bkOpen);
			break;
		case 16:
			break _hx_loop1;
		case 17:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkBlock.walkBlock(stream,bkOpen);
			break;
		case 19:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkPOpen.walkPOpen(stream,bkOpen);
			break;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
		}
	}
	bkOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BkClose));
	if(stream.hasMore()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				if(_g1.s == "is") {
					tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
				}
			}
			break;
		case 6:
			var _g1 = _g.op;
			tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
			break;
		case 11:case 15:
			tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
			break;
		default:
		}
	}
};
var tokentree_walk_WalkAt = function() { };
$hxClasses["tokentree.walk.WalkAt"] = tokentree_walk_WalkAt;
tokentree_walk_WalkAt.__name__ = "tokentree.walk.WalkAt";
tokentree_walk_WalkAt.walkAt = function(stream) {
	var atTok = stream.consumeTokenDef(tokentree_TokenTreeDef.At);
	var parent = atTok;
	if(stream.tokenForMatch()._hx_index == 12) {
		var dblDot = stream.consumeToken();
		atTok.addChild(dblDot);
		parent = dblDot;
	}
	tokentree_walk_WalkAt.walkIdent(stream,parent);
	return atTok;
};
tokentree_walk_WalkAt.walkIdent = function(stream,parent) {
	var ident;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		var _g1 = _g.k;
		ident = stream.consumeToken();
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g2 = _g1.s;
			ident = stream.consumeConstIdent();
		} else {
			return;
		}
		break;
	case 6:
		if(_g.op._hx_index == 23) {
			ident = stream.consumeToken();
		} else {
			return;
		}
		break;
	default:
		return;
	}
	parent.addChild(ident);
	switch(stream.token()._hx_index) {
	case 11:
		var child = stream.consumeToken();
		ident.addChild(child);
		tokentree_walk_WalkAt.walkIdent(stream,child);
		break;
	case 19:
		var pOpenPos = stream.getTokenPos();
		if(ident.pos.max == pOpenPos.min) {
			var tempStore = stream.getTempStore();
			stream.clearTempStore();
			tokentree_walk_WalkPOpen.walkPOpen(stream,ident,false);
			var _g = 0;
			while(_g < tempStore.length) {
				var temp = tempStore[_g];
				++_g;
				stream.addToTempStore(temp);
			}
		}
		break;
	default:
	}
};
tokentree_walk_WalkAt.walkAts = function(stream) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) if(stream.token()._hx_index == 22) {
		stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
	}
};
var tokentree_walk_WalkBinopSub = function() { };
$hxClasses["tokentree.walk.WalkBinopSub"] = tokentree_walk_WalkBinopSub;
tokentree_walk_WalkBinopSub.__name__ = "tokentree.walk.WalkBinopSub";
tokentree_walk_WalkBinopSub.walkBinopSub = function(stream,parent) {
	var sub = stream.consumeOpSub(parent);
	parent.addChild(sub);
	var _g = sub.tok;
	if(_g._hx_index == 2) {
		var _g1 = _g.c;
		tokentree_walk_WalkStatement.walkStatementContinue(stream,sub);
	} else {
		tokentree_walk_WalkStatement.walkStatement(stream,sub);
	}
};
var tokentree_walk_WalkBlock = function() { };
$hxClasses["tokentree.walk.WalkBlock"] = tokentree_walk_WalkBlock;
tokentree_walk_WalkBlock.__name__ = "tokentree.walk.WalkBlock";
tokentree_walk_WalkBlock.walkBlock = function(stream,parent) {
	while(stream.tokenForMatch()._hx_index == 22) stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
	if(stream.tokenForMatch()._hx_index == 17) {
		var openTok = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
		parent.addChild(openTok);
		stream.applyTempStore(openTok);
		tokentree_walk_WalkBlock.walkBlockContinue(stream,openTok);
		stream.applyTempStore(openTok);
	} else {
		tokentree_walk_WalkStatement.walkStatement(stream,parent);
	}
};
tokentree_walk_WalkBlock.walkBlockContinue = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:case 16:
				tokentree_walk_WalkSwitch.walkSwitchCases(stream,parent);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 14:
			var child = stream.consumeToken();
			var lastChild = parent.getLastChild();
			if(lastChild == null) {
				parent.addChild(child);
			} else {
				lastChild.addChild(child);
			}
			break;
		case 18:
			break _hx_loop1;
		case 16:case 20:
			var child1 = stream.consumeToken();
			parent.addChild(child1);
			break;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
	tokentree_walk_WalkBlock.walkBlockEnd(stream,parent);
};
tokentree_walk_WalkBlock.walkBlockEnd = function(stream,parent) {
	parent.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	if(stream.hasMore()) {
		var _g = stream.token();
		if(_g._hx_index == 6) {
			if(_g.op._hx_index == 7) {
				return;
			}
		}
		tokentree_walk_WalkBlock.walkAfterBlock(stream,parent);
		if(stream.hasMore()) {
			if(stream.token()._hx_index == 10) {
				var semicolon = stream.consumeToken();
				parent.addChild(semicolon);
			}
		}
	}
};
tokentree_walk_WalkBlock.walkAfterBlock = function(stream,parent) {
	if(!stream.hasMore()) {
		return;
	}
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
		}
		break;
	case 5:
		var _g1 = _g.op;
		if(parent.isCIdentOrCString()) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 6:
		var _g1 = _g.op;
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 7:
		var _g1 = _g.s;
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 5:
				var _g1 = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 6:
				var _g1 = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 11:case 12:case 21:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 8:
		var _g1 = _g.s;
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 5:
				var _g = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 6:
				var _g = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 11:case 12:case 21:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 10:
		return;
	case 11:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 12:
		tokentree_walk_WalkStatement.walkDblDot(stream,parent);
		break;
	case 13:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 19:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 21:
		tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
		break;
	default:
	}
};
var tokentree_walk_WalkClass = function() { };
$hxClasses["tokentree.walk.WalkClass"] = tokentree_walk_WalkClass;
tokentree_walk_WalkClass.__name__ = "tokentree.walk.WalkClass";
tokentree_walk_WalkClass.walkClass = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var name = typeTok;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g2 = _g1.s;
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
			stream.applyTempStore(name);
		}
		break;
	case 4:
		var _g1 = _g.s;
		name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		break;
	default:
	}
	tokentree_walk_WalkClass.walkClassExtends(stream,name);
	var block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkClass.walkClassBody(stream,block);
	block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
};
tokentree_walk_WalkClass.walkClassExtends = function(stream,name) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkExtends.walkExtends(stream,name);
		tokentree_walk_WalkImplements.walkImplements(stream,name);
		if(stream.isSharp()) {
			tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkClass.walkClassExtends);
		}
		tokentree_walk_WalkComment.walkComment(stream,name);
	}
};
tokentree_walk_WalkClass.walkClassBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 39:case 40:case 43:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
				case 1:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
					break;
				}
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkClass.walkClassBody);
			tokentree_walk_WalkClass.walkClassContinueAfterSharp(stream,parent);
			break;
		case 7:
			var _g2 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 8:
			var _g3 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 10:
			parent.addChild(stream.consumeToken());
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
			case 1:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
				break;
			}
		}
	}
	var tempStore = stream.getTempStore();
	if(tempStore.length > 0) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
		case 1:
			stream.applyTempStore(parent);
			break;
		}
	}
};
tokentree_walk_WalkClass.walkClassContinueAfterSharp = function(stream,parent) {
	var brOpen = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.lastOf(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(parent),tokentree_TokenTreeDef.Sharp("if")),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction)))),tokentree_TokenTreeDef.BrOpen);
	if(brOpen == null) {
		return;
	}
	if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(brOpen),tokentree_TokenTreeDef.BrClose) != null) {
		return;
	}
	tokentree_walk_WalkBlock.walkBlockContinue(stream,parent);
};
var tokentree_walk_WalkComment = function() { };
$hxClasses["tokentree.walk.WalkComment"] = tokentree_walk_WalkComment;
tokentree_walk_WalkComment.__name__ = "tokentree.walk.WalkComment";
tokentree_walk_WalkComment.walkComment = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 7:
			var _g1 = _g.s;
			var comment = stream.consumeToken();
			parent.addChild(comment);
			break;
		case 8:
			var _g2 = _g.s;
			var comment1 = stream.consumeToken();
			parent.addChild(comment1);
			break;
		default:
			return;
		}
	}
};
tokentree_walk_WalkComment.tryWalkComment = function(stream,parent,expect) {
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 7:
			var _g1 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 8:
			var _g2 = _g.s;
			comments.push(stream.consumeToken());
			break;
		default:
			if(stream.matches(expect)) {
				var _g3 = 0;
				while(_g3 < comments.length) {
					var comment = comments[_g3];
					++_g3;
					parent.addChild(comment);
				}
				return;
			}
			stream.rewindTo(currentPos);
			return;
		}
	}
};
var tokentree_walk_WalkDoWhile = function() { };
$hxClasses["tokentree.walk.WalkDoWhile"] = tokentree_walk_WalkDoWhile;
tokentree_walk_WalkDoWhile.__name__ = "tokentree.walk.WalkDoWhile";
tokentree_walk_WalkDoWhile.walkDoWhile = function(stream,parent) {
	var doTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo));
	parent.addChild(doTok);
	stream.applyTempStore(doTok);
	tokentree_walk_WalkComment.walkComment(stream,doTok);
	tokentree_walk_WalkBlock.walkBlock(stream,doTok);
	var whileTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
	doTok.addChild(whileTok);
	tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	if(stream.tokenForMatch()._hx_index == 10) {
		whileTok.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkEnum = function() { };
$hxClasses["tokentree.walk.WalkEnum"] = tokentree_walk_WalkEnum;
tokentree_walk_WalkEnum.__name__ = "tokentree.walk.WalkEnum";
tokentree_walk_WalkEnum.walkEnum = function(stream,parent) {
	var typeTok = stream.consumeToken();
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 1 && _g.k._hx_index == 39) {
		stream.addToTempStore(typeTok);
		tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
		return;
	}
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	tokentree_walk_WalkBlock.walkBlock(stream,name);
};
var tokentree_walk_WalkExtends = function() { };
$hxClasses["tokentree.walk.WalkExtends"] = tokentree_walk_WalkExtends;
tokentree_walk_WalkExtends.__name__ = "tokentree.walk.WalkExtends";
tokentree_walk_WalkExtends.walkExtends = function(stream,parent) {
	var _g = stream.tokenForMatch();
	if(!(_g._hx_index == 1 && _g.k._hx_index == 11)) {
		return;
	}
	var parentType = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtends));
	parent.addChild(parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkExtends.walkExtends(stream,parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
};
var tokentree_walk_WalkFieldDef = function() { };
$hxClasses["tokentree.walk.WalkFieldDef"] = tokentree_walk_WalkFieldDef;
tokentree_walk_WalkFieldDef.__name__ = "tokentree.walk.WalkFieldDef";
tokentree_walk_WalkFieldDef.walkFieldDef = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:case 2:case 41:
				var tok = stream.consumeToken();
				parent.addChild(tok);
				parent = tok;
				break;
			default:
				break _hx_loop1;
			}
			break;
		case 7:
			var _g1 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 8:
			var _g2 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			break _hx_loop1;
		}
	}
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	stream.applyTempStore(name);
	if(stream.tokenForMatch()._hx_index == 12) {
		var dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
		name.addChild(dblDot);
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,dblDot);
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 4) {
		tokentree_walk_WalkStatement.walkStatement(stream,name);
	}
	switch(stream.token()._hx_index) {
	case 10:
		name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Semicolon));
		break;
	case 14:
		name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Comma));
		break;
	default:
	}
};
var tokentree_walk_WalkFile = function() { };
$hxClasses["tokentree.walk.WalkFile"] = tokentree_walk_WalkFile;
tokentree_walk_WalkFile.__name__ = "tokentree.walk.WalkFile";
tokentree_walk_WalkFile.walkFile = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 13:case 33:case 35:
				stream.applyTempStore(parent);
				tokentree_walk_WalkPackageImport.walkPackageImport(stream,parent);
				break;
			case 17:case 18:case 19:case 25:case 32:case 34:case 40:case 43:
				stream.consumeToTempStore();
				break;
			case 1:case 26:case 27:case 31:case 39:
				tokentree_walk_WalkType.walkType(stream,parent);
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				tokentree_walk_WalkBlock.walkBlock(stream,parent);
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkFile.walkFile);
			if(!stream.hasMore()) {
				return;
			}
			if(stream.token()._hx_index == 17) {
				tokentree_walk_WalkBlock.walkBlock(stream,parent.children[parent.children.length - 1]);
			}
			break;
		case 7:
			var _g2 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,parent);
			}
			break;
		case 8:
			var _g3 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,parent);
			}
			break;
		case 10:case 14:case 16:case 18:case 20:
			parent.addChild(stream.consumeToken());
			break;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			tokentree_walk_WalkBlock.walkBlock(stream,parent);
		}
	}
	var tempStore = stream.getTempStore();
	var _g = 0;
	while(_g < tempStore.length) {
		var stored = tempStore[_g];
		++_g;
		var _g1 = stored.tok;
		switch(_g1._hx_index) {
		case 1:
			switch(_g1.k._hx_index) {
			case 18:case 19:case 25:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stored));
				case 1:
					parent.addChild(stored);
					break;
				}
				break;
			default:
				parent.addChild(stored);
			}
			break;
		case 22:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stored));
			case 1:
				parent.addChild(stored);
				break;
			}
			break;
		default:
			parent.addChild(stored);
		}
	}
};
var tokentree_walk_WalkFinal = function() { };
$hxClasses["tokentree.walk.WalkFinal"] = tokentree_walk_WalkFinal;
tokentree_walk_WalkFinal.__name__ = "tokentree.walk.WalkFinal";
tokentree_walk_WalkFinal.walkFinal = function(stream,parent) {
	var name = null;
	var finalTok = stream.consumeToken();
	stream.addToTempStore(finalTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return;
			case 1:case 27:
				return;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			default:
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
				break _hx_loop1;
			}
			break;
		case 7:
			var _g3 = _g.s;
			stream.consumeToTempStore();
			break;
		case 8:
			var _g4 = _g.s;
			stream.consumeToTempStore();
			break;
		default:
		}
	}
	parent.addChild(finalTok);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
		if(stream.token()._hx_index == 22) {
			tokentree_walk_WalkAt.walkAts(stream);
		}
		tokentree_walk_WalkComment.walkComment(stream,parent);
		var nameParent = finalTok;
		if(stream.tokenForMatch()._hx_index == 21) {
			nameParent = stream.consumeToken();
			finalTok.addChild(nameParent);
		}
		name = stream.consumeConstIdent();
		nameParent.addChild(name);
		var tempStore = stream.getTempStore();
		var _g = 0;
		while(_g < tempStore.length) {
			var stored = tempStore[_g];
			++_g;
			var _g1 = stored.tok;
			if(_g1._hx_index == 1) {
				if(_g1.k._hx_index != 41) {
					name.addChild(stored);
				}
			} else {
				name.addChild(stored);
			}
		}
		stream.clearTempStore();
		tokentree_walk_WalkComment.walkComment(stream,name);
		if(stream.tokenForMatch()._hx_index == 19) {
			tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 12) {
			var dblDot = stream.consumeToken();
			name.addChild(dblDot);
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
		}
		var _g2 = stream.tokenForMatch();
		if(_g2._hx_index == 6 && _g2.op._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatement(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 14) {
			var comma = stream.consumeToken();
			name.addChild(comma);
			continue;
		}
		break;
	}
	if(stream.tokenForMatch()._hx_index == 10) {
		name.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkFor = function() { };
$hxClasses["tokentree.walk.WalkFor"] = tokentree_walk_WalkFor;
tokentree_walk_WalkFor.__name__ = "tokentree.walk.WalkFor";
tokentree_walk_WalkFor.walkFor = function(stream,parent) {
	var forTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFor));
	parent.addChild(forTok);
	stream.applyTempStore(forTok);
	tokentree_walk_WalkComment.walkComment(stream,forTok);
	tokentree_walk_WalkFor.walkForPOpen(stream,forTok);
	tokentree_walk_WalkComment.walkComment(stream,forTok);
	tokentree_walk_WalkBlock.walkBlock(stream,forTok);
};
tokentree_walk_WalkFor.walkForPOpen = function(stream,parent) {
	var pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
	parent.addChild(pOpen);
	tokentree_walk_WalkComment.walkComment(stream,pOpen);
	var identifier = null;
	var _g = stream.token();
	if(_g._hx_index == 4) {
		var _g1 = _g.s;
		tokentree_walk_WalkStatement.walkStatement(stream,pOpen);
		identifier = pOpen.getLastChild();
	} else {
		identifier = stream.consumeConstIdent();
		pOpen.addChild(identifier);
	}
	tokentree_walk_WalkComment.walkComment(stream,identifier);
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 22) {
		var arrowTok = stream.consumeToken();
		identifier.addChild(arrowTok);
		var _g = stream.token();
		if(_g._hx_index == 4) {
			var _g1 = _g.s;
			tokentree_walk_WalkStatement.walkStatement(stream,arrowTok);
		} else {
			arrowTok.addChild(stream.consumeConstIdent());
		}
	}
	var inTok = null;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 6:
		if(_g.op._hx_index == 23) {
			inTok = stream.consumeToken();
			identifier.addChild(inTok);
			tokentree_walk_WalkComment.walkComment(stream,inTok);
			tokentree_walk_WalkStatement.walkStatement(stream,inTok);
			tokentree_walk_WalkComment.walkComment(stream,pOpen);
			pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
			tokentree_walk_WalkComment.walkComment(stream,parent);
		}
		break;
	case 20:
		pOpen.addChild(stream.consumeToken());
		tokentree_walk_WalkComment.walkComment(stream,parent);
		return;
	default:
	}
};
var tokentree_walk_WalkFunction = function() { };
$hxClasses["tokentree.walk.WalkFunction"] = tokentree_walk_WalkFunction;
tokentree_walk_WalkFunction.__name__ = "tokentree.walk.WalkFunction";
tokentree_walk_WalkFunction.walkFunction = function(stream,parent) {
	var funcTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction));
	parent.addChild(funcTok);
	tokentree_walk_WalkComment.walkComment(stream,funcTok);
	var name = funcTok;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 22) {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		} else {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		}
		break;
	case 6:
		if(_g.op._hx_index == 9) {
			tokentree_walk_WalkLtGt.walkLtGt(stream,funcTok);
			name = funcTok.getLastChild();
		} else {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		}
		break;
	case 19:
		break;
	default:
		name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
	}
	stream.applyTempStore(name);
	tokentree_walk_WalkComment.walkComment(stream,name);
	tokentree_walk_WalkFunction.walkFunctionParameters(stream,name);
	tokentree_walk_WalkComment.walkComment(stream,name);
	var _g = stream.token();
	if(_g._hx_index == 3) {
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkStatement.walkStatement);
		switch(stream.token()._hx_index) {
		case 12:case 17:
			break;
		default:
			return;
		}
	}
	if(stream.tokenForMatch()._hx_index == 12) {
		var dblDot = stream.consumeToken();
		name.addChild(dblDot);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDot);
	}
	tokentree_walk_WalkBlock.walkBlock(stream,name);
};
tokentree_walk_WalkFunction.walkFunctionParameters = function(stream,parent) {
	var pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
	parent.addChild(pOpen);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkComment.walkComment(stream,pOpen);
		if(stream.tokenForMatch()._hx_index == 20) {
			break;
		}
		tokentree_walk_WalkFieldDef.walkFieldDef(stream,pOpen);
	}
	pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
};
var tokentree_walk_WalkIf = function() { };
$hxClasses["tokentree.walk.WalkIf"] = tokentree_walk_WalkIf;
tokentree_walk_WalkIf.__name__ = "tokentree.walk.WalkIf";
tokentree_walk_WalkIf.walkIf = function(stream,parent) {
	var ifTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf));
	parent.addChild(ifTok);
	stream.applyTempStore(ifTok);
	tokentree_walk_WalkStatement.walkStatement(stream,ifTok);
	if(stream.tokenForMatch()._hx_index == 12) {
		return;
	}
	tokentree_walk_WalkBlock.walkBlock(stream,ifTok);
	tokentree_walk_WalkComment.tryWalkComment(stream,ifTok,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 1 && _g.k._hx_index == 4) {
		var elseTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
		ifTok.addChild(elseTok);
		tokentree_walk_WalkBlock.walkBlock(stream,elseTok);
	}
};
var tokentree_walk_WalkImplements = function() { };
$hxClasses["tokentree.walk.WalkImplements"] = tokentree_walk_WalkImplements;
tokentree_walk_WalkImplements.__name__ = "tokentree.walk.WalkImplements";
tokentree_walk_WalkImplements.walkImplements = function(stream,parent) {
	var _g = stream.tokenForMatch();
	if(!(_g._hx_index == 1 && _g.k._hx_index == 12)) {
		return;
	}
	var interfacePart = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdImplements));
	parent.addChild(interfacePart);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,interfacePart);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkImplements.walkImplements(stream,parent);
	tokentree_walk_WalkComment.walkComment(stream,parent);
};
var tokentree_walk_WalkInterface = function() { };
$hxClasses["tokentree.walk.WalkInterface"] = tokentree_walk_WalkInterface;
tokentree_walk_WalkInterface.__name__ = "tokentree.walk.WalkInterface";
tokentree_walk_WalkInterface.walkInterface = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	tokentree_walk_WalkClass.walkClassExtends(stream,name);
	var block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkInterface.walkInterfaceBody(stream,block);
	block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
};
tokentree_walk_WalkInterface.walkInterfaceBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				stream.consumeToTempStore();
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkInterface.walkInterfaceBody);
			break;
		case 7:
			var _g2 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 8:
			var _g3 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 10:
			parent.addChild(stream.consumeToken());
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.consumeToTempStore();
		}
	}
	stream.applyTempStore(parent);
};
var tokentree_walk_WalkLtGt = function() { };
$hxClasses["tokentree.walk.WalkLtGt"] = tokentree_walk_WalkLtGt;
tokentree_walk_WalkLtGt.__name__ = "tokentree.walk.WalkLtGt";
tokentree_walk_WalkLtGt.walkLtGt = function(stream,parent) {
	var ltTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt));
	parent.addChild(ltTok);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 6:
			if(_g.op._hx_index == 7) {
				break _hx_loop1;
			} else {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
			}
			break;
		case 12:
			var dblDot = stream.consumeToken();
			ltTok.addChild(dblDot);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
			break;
		case 14:
			var comma = stream.consumeToken();
			ltTok.addChild(comma);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
			var _g1 = stream.token();
			if(!(_g1._hx_index == 6 && _g1.op._hx_index == 7)) {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
			}
			break;
		case 19:
			tokentree_walk_WalkPOpen.walkPOpen(stream,ltTok);
			break;
		default:
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
		}
	}
	ltTok.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt)));
};
var tokentree_walk_WalkNew = function() { };
$hxClasses["tokentree.walk.WalkNew"] = tokentree_walk_WalkNew;
tokentree_walk_WalkNew.__name__ = "tokentree.walk.WalkNew";
tokentree_walk_WalkNew.walkNew = function(stream,parent) {
	var newTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew));
	parent.addChild(newTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,newTok);
	tokentree_walk_WalkComment.walkComment(stream,name);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 3:
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		break;
	case 19:
		tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		break;
	default:
	}
	tokentree_walk_WalkComment.walkComment(stream,name);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkStatement.walkStatement(stream,name);
			}
		}
		break;
	case 6:
		var _g1 = _g.op;
		tokentree_walk_WalkStatement.walkStatement(stream,name);
		break;
	case 11:case 15:
		tokentree_walk_WalkStatement.walkStatement(stream,name);
		break;
	default:
	}
};
var tokentree_walk_WalkPOpen = function() { };
$hxClasses["tokentree.walk.WalkPOpen"] = tokentree_walk_WalkPOpen;
tokentree_walk_WalkPOpen.__name__ = "tokentree.walk.WalkPOpen";
tokentree_walk_WalkPOpen.walkPOpen = function(stream,parent,walkTrailingComments) {
	if(walkTrailingComments == null) {
		walkTrailingComments = true;
	}
	var pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
	parent.addChild(pOpen);
	tokentree_walk_WalkPOpen.walkPOpenParts(stream,pOpen);
	pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
	if(walkTrailingComments) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
	}
	if(stream.hasMore()) {
		if(stream.token()._hx_index == 13) {
			var arrow = stream.consumeToken();
			pOpen.addChild(arrow);
			tokentree_walk_WalkBlock.walkBlock(stream,arrow);
		}
	}
	return pOpen;
};
tokentree_walk_WalkPOpen.walkPOpenParts = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPOpen.walkPOpenParts);
			break;
		case 14:
			var comma = stream.consumeToken();
			var child = parent.getLastChild();
			if(child == null) {
				child = parent;
			}
			child.addChild(comma);
			break;
		case 15:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
			break;
		case 17:
			tokentree_walk_WalkBlock.walkBlock(stream,parent);
			break;
		case 20:
			break _hx_loop1;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
var tokentree_walk_WalkPackageImport = function() { };
$hxClasses["tokentree.walk.WalkPackageImport"] = tokentree_walk_WalkPackageImport;
tokentree_walk_WalkPackageImport.__name__ = "tokentree.walk.WalkPackageImport";
tokentree_walk_WalkPackageImport.walkPackageImport = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPackageImport.walkPackageImport);
			break;
		case 10:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			return;
		default:
			var newChild1 = stream.consumeToken();
			parent.addChild(newChild1);
			parent = newChild1;
		}
	}
};
var tokentree_walk_WalkQuestion = function() { };
$hxClasses["tokentree.walk.WalkQuestion"] = tokentree_walk_WalkQuestion;
tokentree_walk_WalkQuestion.__name__ = "tokentree.walk.WalkQuestion";
tokentree_walk_WalkQuestion.walkQuestion = function(stream,parent) {
	var ternary = tokentree_walk_WalkQuestion.isTernary(parent);
	var question = stream.consumeTokenDef(tokentree_TokenTreeDef.Question);
	parent.addChild(question);
	tokentree_walk_WalkComment.walkComment(stream,question);
	if(!ternary) {
		tokentree_walk_WalkStatement.walkStatement(stream,question);
		return;
	}
	tokentree_walk_WalkStatement.walkStatement(stream,question);
	tokentree_walk_WalkComment.walkComment(stream,question);
	if(stream.tokenForMatch()._hx_index != 12) {
		return;
	}
	var dblDotTok = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
	question.addChild(dblDotTok);
	tokentree_walk_WalkStatement.walkStatement(stream,dblDotTok);
};
tokentree_walk_WalkQuestion.isTernary = function(parent) {
	var lastChild = parent.getLastChild();
	if(lastChild == null) {
		var _g = parent.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			return true;
		} else {
			lastChild = parent;
		}
	}
	var _g = lastChild.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:
			return true;
		case 22:
			return true;
		case 23:case 28:case 40:
			return true;
		case 29:
			return true;
		case 36:case 37:case 38:
			return true;
		default:
			return false;
		}
		break;
	case 2:
		var _g1 = _g.c;
		return true;
	case 4:
		var _g1 = _g.s;
		return true;
	case 5:
		var _g1 = _g.op;
		return true;
	case 6:
		switch(_g.op._hx_index) {
		case 0:case 3:
			return true;
		default:
			return false;
		}
		break;
	case 12:
		return true;
	case 15:
		return true;
	case 17:
		return true;
	case 19:
		return true;
	case 20:
		return true;
	default:
		return false;
	}
};
var tokentree_walk_WalkSharp = function() { };
$hxClasses["tokentree.walk.WalkSharp"] = tokentree_walk_WalkSharp;
tokentree_walk_WalkSharp.__name__ = "tokentree.walk.WalkSharp";
tokentree_walk_WalkSharp.walkSharp = function(stream,parent,walker) {
	var _g = stream.token();
	if(_g._hx_index == 3) {
		switch(_g.s) {
		case "else":
			tokentree_walk_WalkSharp.walkSharpElse(stream,parent);
			break;
		case "elseif":
			tokentree_walk_WalkSharp.walkSharpElseIf(stream,parent);
			break;
		case "end":
			tokentree_walk_WalkSharp.walkSharpEnd(stream,parent);
			break;
		case "error":
			var errorToken = stream.consumeToken();
			parent.addChild(errorToken);
			var _g = stream.token();
			if(_g._hx_index == 2) {
				var _g1 = _g.c;
				if(_g1._hx_index == 2) {
					var _g = _g1.kind;
					var _g = _g1.s;
					errorToken.addChild(stream.consumeToken());
				}
			}
			break;
		case "if":
			tokentree_walk_WalkSharp.walkSharpIf(stream,parent,walker);
			break;
		default:
			parent.addChild(stream.consumeToken());
		}
	}
};
tokentree_walk_WalkSharp.walkSharpIf = function(stream,parent,walker) {
	var ifToken = stream.consumeToken();
	parent.addChild(ifToken);
	tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
	stream.pushSharpIf(ifToken);
	var newParent = ifToken;
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) try {
		walker(stream,newParent);
		switch(stream.token()._hx_index) {
		case 14:case 18:case 20:
			var newChild = stream.consumeToken();
			newParent.addChild(newChild);
			break;
		default:
		}
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var _g1 = haxe_Exception.caught(_g).unwrap();
		if(((_g1) instanceof tokentree_walk_SharpElseException)) {
			var e = _g1;
			newParent = e.token;
		} else if(((_g1) instanceof tokentree_walk_SharpEndException)) {
			stream.popSharpIf();
			return;
		} else {
			throw _g;
		}
	}
};
tokentree_walk_WalkSharp.walkSharpElse = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var ifToken = stream.consumeToken();
	sharpIfParent.addChild(ifToken);
	stream.applyTempStore(sharpIfParent);
	throw haxe_Exception.thrown(new tokentree_walk_SharpElseException(ifToken));
};
tokentree_walk_WalkSharp.walkSharpElseIf = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var ifToken = stream.consumeToken();
	sharpIfParent.addChild(ifToken);
	stream.applyTempStore(sharpIfParent);
	tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
	throw haxe_Exception.thrown(new tokentree_walk_SharpElseException(ifToken));
};
tokentree_walk_WalkSharp.walkSharpEnd = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var endToken = stream.consumeToken();
	stream.applyTempStore(sharpIfParent);
	sharpIfParent.addChild(endToken);
	throw haxe_Exception.thrown(new tokentree_walk_SharpEndException());
};
tokentree_walk_WalkSharp.walkSharpIfExpr = function(stream,parent) {
	var childToken;
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			var _g1 = _g.k;
			childToken = stream.consumeToken();
			parent.addChild(childToken);
			if(!stream.hasMore()) {
				return;
			}
			if(stream.token()._hx_index != 11) {
				return;
			}
			var pos = stream.getTokenPos();
			if(pos == null) {
				return;
			}
			if(pos.min == childToken.pos.max + 1) {
				continue;
			}
			var dot = stream.consumeToken();
			childToken.addChild(dot);
			tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot);
			return;
		case 2:
			var _g2 = _g.c;
			if(_g2._hx_index == 3) {
				var _g3 = _g2.s;
				childToken = stream.consumeToken();
				parent.addChild(childToken);
				if(!stream.hasMore()) {
					return;
				}
				if(stream.token()._hx_index != 11) {
					return;
				}
				var pos1 = stream.getTokenPos();
				if(pos1 == null) {
					return;
				}
				if(pos1.min == childToken.pos.max + 1) {
					continue;
				}
				var dot1 = stream.consumeToken();
				childToken.addChild(dot1);
				tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot1);
				return;
			} else {
				return;
			}
			break;
		case 5:
			if(_g.op._hx_index == 2) {
				childToken = stream.consumeToken();
				parent.addChild(childToken);
				tokentree_walk_WalkSharp.walkSharpIfExpr(stream,childToken);
				return;
			} else {
				return;
			}
			break;
		case 19:
			tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
			return;
		default:
			return;
		}
	}
};
var tokentree_walk_SharpElseException = function(token) {
	this.token = token;
};
$hxClasses["tokentree.walk.SharpElseException"] = tokentree_walk_SharpElseException;
tokentree_walk_SharpElseException.__name__ = "tokentree.walk.SharpElseException";
tokentree_walk_SharpElseException.prototype = {
	token: null
	,__class__: tokentree_walk_SharpElseException
};
var tokentree_walk_SharpEndException = function() {
};
$hxClasses["tokentree.walk.SharpEndException"] = tokentree_walk_SharpEndException;
tokentree_walk_SharpEndException.__name__ = "tokentree.walk.SharpEndException";
tokentree_walk_SharpEndException.prototype = {
	__class__: tokentree_walk_SharpEndException
};
var tokentree_walk_WalkStatement = function() { };
$hxClasses["tokentree.walk.WalkStatement"] = tokentree_walk_WalkStatement;
tokentree_walk_WalkStatement.__name__ = "tokentree.walk.WalkStatement";
tokentree_walk_WalkStatement.walkStatement = function(stream,parent) {
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	if(stream.tokenForMatch()._hx_index == 10) {
		var semicolon = stream.consumeToken();
		var lastChild;
		var _g = parent.tok;
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 0:case 3:case 14:case 15:
				lastChild = parent.parent.getLastChild();
				break;
			default:
				lastChild = parent.getLastChild();
			}
		} else {
			lastChild = parent.getLastChild();
		}
		if(lastChild == null) {
			lastChild = parent;
		}
		switch(lastChild.tok._hx_index) {
		case 16:case 18:case 20:
			lastChild = parent;
			break;
		default:
		}
		lastChild.addChild(semicolon);
	}
};
tokentree_walk_WalkStatement.walkStatementWithoutSemicolon = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var wantMore = true;
	tokentree_walk_WalkAt.walkAts(stream);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		var _g1 = _g.k;
		if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
			wantMore = true;
		} else {
			return;
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			switch(_g1.s) {
			case "final":
				if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
					wantMore = true;
				} else {
					return;
				}
				break;
			case "is":
				wantMore = true;
				break;
			default:
				wantMore = false;
			}
		} else {
			wantMore = false;
		}
		break;
	case 3:
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		tokentree_walk_WalkStatement.walkStatementContinueAfterSharp(stream,parent);
		return;
	case 4:
		var name = _g.s;
		tokentree_walk_WalkStatement.walkDollarStatement(stream,parent);
		return;
	case 5:
		var _g1 = _g.op;
		if(parent.isCIdentOrCString()) {
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			if(!stream.hasMore()) {
				return;
			}
			var _g1 = stream.token();
			switch(_g1._hx_index) {
			case 2:
				var _g2 = _g1.c;
				if(_g2._hx_index == 3) {
					if(_g2.s == "is") {
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
					}
				}
				break;
			case 6:
				var _g2 = _g1.op;
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
				break;
			case 11:
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
				break;
			default:
			}
			return;
		}
		break;
	case 6:
		switch(_g.op._hx_index) {
		case 3:
			tokentree_walk_WalkBinopSub.walkBinopSub(stream,parent);
			return;
		case 7:
			var gtTok = stream.consumeOpGt();
			parent.addChild(gtTok);
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,gtTok);
			return;
		case 9:
			if(stream.isTypedParam()) {
				tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
				if(stream.tokenForMatch()._hx_index == 13) {
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				}
				return;
			}
			wantMore = true;
			break;
		case 12:
			if(parent.parent != null && parent.parent.tok != tokentree_TokenTreeDef.Root) {
				var _g1 = parent.parent.tok;
				if(_g1._hx_index == 1) {
					if(_g1.k._hx_index == 15) {
						var orTok = stream.consumeToken();
						parent.addChild(orTok);
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent.parent);
						return;
					}
				}
			}
			wantMore = true;
			break;
		default:
			wantMore = true;
		}
		break;
	case 9:
		var _g1 = _g.s;
		wantMore = true;
		break;
	case 10:
		return;
	case 11:
		wantMore = true;
		break;
	case 12:
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 40) {
				tokentree_walk_WalkStatement.walkDblDot(stream,parent);
				return;
			}
			break;
		case 11:
			return;
		default:
		}
		if(parent.tok._hx_index == 11) {
			return;
		}
		if(tokentree_walk_WalkQuestion.isTernary(parent)) {
			tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
			return;
		}
		wantMore = true;
		break;
	case 13:
		wantMore = true;
		break;
	case 14:
		return;
	case 15:
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
		tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
		return;
	case 17:
		tokentree_walk_WalkBlock.walkBlock(stream,parent);
		return;
	case 16:case 18:case 20:
		return;
	case 19:
		tokentree_walk_WalkStatement.walkPOpen(stream,parent);
		return;
	case 21:
		tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
		return;
	default:
		wantMore = false;
	}
	var newChild = stream.consumeToken();
	parent.addChild(newChild);
	stream.applyTempStore(newChild);
	tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild);
	if(wantMore) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
	}
	tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
	tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild);
};
tokentree_walk_WalkStatement.walkTrailingComment = function(stream,parent) {
	if(!stream.hasMore()) {
		return;
	}
	var _g = stream.token();
	if(_g._hx_index == 8) {
		var _g1 = _g.s;
		var currentPos = stream.getStreamIndex();
		var commentTok = stream.consumeToken();
		var _g = stream.tokenForMatch();
		if(!(_g._hx_index == 1 && _g.k._hx_index == 4)) {
			stream.rewindTo(currentPos);
			return;
		}
		parent.addChild(commentTok);
	}
};
tokentree_walk_WalkStatement.walkStatementContinue = function(stream,parent) {
	if(!stream.hasMore()) {
		return;
	}
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
		}
		break;
	case 5:
		var _g1 = _g.op;
		if(parent.isCIdentOrCString()) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 6:
		switch(_g.op._hx_index) {
		case 0:case 3:
			tokentree_walk_WalkStatement.walkOpAdd(stream,parent);
			break;
		case 7:
			var ltParent = parent;
			_hx_loop1: while(true) {
				var _g1 = ltParent.tok;
				switch(_g1._hx_index) {
				case 0:
					break _hx_loop1;
				case 2:
					var _g2 = _g1.c;
					ltParent = ltParent.parent;
					break;
				case 4:
					var _g3 = _g1.s;
					ltParent = ltParent.parent;
					break;
				case 6:
					switch(_g1.op._hx_index) {
					case 7:
						ltParent = ltParent.parent;
						break;
					case 9:
						return;
					default:
						break _hx_loop1;
					}
					break;
				case 11:case 12:case 13:case 14:case 15:case 17:case 19:
					ltParent = ltParent.parent;
					break;
				default:
					break _hx_loop1;
				}
			}
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 14:case 15:
			tokentree_walk_WalkStatement.walkOpBool(stream,parent);
			break;
		default:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 7:
		var _g1 = _g.s;
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 5:
				var _g1 = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 6:
				var _g1 = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 11:case 12:case 21:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 8:
		var _g1 = _g.s;
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 5:
				var _g = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 6:
				var _g = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 11:case 12:case 21:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 10:
		return;
	case 11:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 12:
		tokentree_walk_WalkStatement.walkDblDot(stream,parent);
		break;
	case 13:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 15:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 19:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 21:
		tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
		break;
	default:
	}
};
tokentree_walk_WalkStatement.walkKeyword = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 0:
			tokentree_walk_WalkFunction.walkFunction(stream,parent);
			break;
		case 1:
			tokentree_walk_WalkClass.walkClass(stream,parent);
			break;
		case 2:
			tokentree_walk_WalkVar.walkVar(stream,parent);
			break;
		case 3:
			tokentree_walk_WalkIf.walkIf(stream,parent);
			break;
		case 5:
			var tmp;
			if(parent.tok._hx_index != 17) {
				var _g = parent.parent.tok;
				tmp = _g._hx_index == 1 && _g.k._hx_index == 6;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			tokentree_walk_WalkWhile.walkWhile(stream,parent);
			break;
		case 6:
			tokentree_walk_WalkDoWhile.walkDoWhile(stream,parent);
			break;
		case 7:
			tokentree_walk_WalkFor.walkFor(stream,parent);
			break;
		case 10:case 40:
			return true;
		case 14:
			tokentree_walk_WalkSwitch.walkSwitch(stream,parent);
			break;
		case 15:
			return false;
		case 16:
			if(parent.tok._hx_index == 17) {
				return false;
			}
			return true;
		case 20:
			tokentree_walk_WalkTry.walkTry(stream,parent);
			break;
		case 22:
			if(parent.tok._hx_index == 11) {
				var newChild = stream.consumeToken();
				parent.addChild(newChild);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
			} else {
				tokentree_walk_WalkNew.walkNew(stream,parent);
			}
			break;
		case 23:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
			return false;
		case 29:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
			return false;
		case 36:case 37:case 38:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			var _g = stream.token();
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 14:case 15:
					tokentree_walk_WalkStatement.walkOpBool(stream,newChild);
					break;
				default:
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
				}
				break;
			case 21:
				tokentree_walk_WalkQuestion.walkQuestion(stream,newChild);
				break;
			default:
			}
			return false;
		case 41:
			tokentree_walk_WalkFinal.walkFinal(stream,parent);
			break;
		default:
			return true;
		}
	} else {
		return true;
	}
	return false;
};
tokentree_walk_WalkStatement.walkDblDot = function(stream,parent) {
	var question = tokentree_walk_WalkStatement.findQuestionParent(parent);
	if(question != null) {
		return;
	}
	var dblDotTok = stream.consumeToken();
	parent.addChild(dblDotTok);
	if(parent.isCIdentOrCString() && parent.parent.tok._hx_index == 17) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,dblDotTok);
		return;
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 1 && _g.k._hx_index == 22) {
		tokentree_walk_WalkNew.walkNew(stream,dblDotTok);
		return;
	}
	if(!tokentree_walk_WalkStatement.walkKeyword(stream,dblDotTok)) {
		return;
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDotTok);
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 4) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	}
};
tokentree_walk_WalkStatement.walkPOpen = function(stream,parent) {
	var pOpen = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
	if(parent.tok == tokentree_TokenTreeDef.Root) {
		return;
	}
	if(parent.isCIdent()) {
		tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
	} else {
		var _g = parent.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 3:case 5:case 7:case 14:
				var _g = stream.token();
				switch(_g._hx_index) {
				case 6:
					if(_g.op._hx_index == 3) {
						return;
					}
					break;
				case 11:
					break;
				default:
					return;
				}
				break;
			default:
			}
		}
		tokentree_walk_WalkStatement.walkStatementContinue(stream,pOpen);
	}
};
tokentree_walk_WalkStatement.findQuestionParent = function(token) {
	var parent = token;
	while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 10:
				return parent;
			case 15:
				return parent;
			case 16:
				return parent;
			case 40:
				parent = tokentree_walk_WalkStatement.findQuestionParent(parent.parent);
				if(parent == null) {
					return null;
				}
				var _g1 = parent.tok;
				switch(_g1._hx_index) {
				case 1:
					switch(_g1.k._hx_index) {
					case 15:case 16:
						return parent;
					default:
						return null;
					}
					break;
				case 21:
					return parent;
				default:
					return null;
				}
				break;
			default:
			}
			break;
		case 6:
			var _g2 = _g.op;
			return parent;
		case 14:
			return null;
		case 17:
			if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose) == null) {
				return null;
			}
			break;
		case 19:
			if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose) == null) {
				return null;
			}
			break;
		case 21:
			if(tokentree_walk_WalkQuestion.isTernary(parent)) {
				return parent;
			}
			return null;
		default:
		}
		parent = parent.parent;
	}
	return null;
};
tokentree_walk_WalkStatement.walkStatementContinueAfterSharp = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 15:case 16:
			var lastChild = parent.getLastChild();
			if(lastChild == null) {
				lastChild = parent;
			}
			tokentree_walk_WalkSwitch.walkSwitchCases(stream,lastChild);
			break;
		default:
		}
	}
};
tokentree_walk_WalkStatement.walkOpBool = function(stream,token) {
	var parent = token.parent;
	_hx_loop1: while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				break _hx_loop1;
			case 3:case 5:case 10:case 24:case 28:
				break _hx_loop1;
			case 14:case 15:case 16:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 6:
			var _g1 = _g.op;
			switch(_g1._hx_index) {
			case 4:
				break _hx_loop1;
			case 14:case 15:
				token = parent.parent;
				break _hx_loop1;
			case 20:
				var _g2 = _g1.op;
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 12:
			token = parent;
			break _hx_loop1;
		case 19:
			if(token.tok._hx_index == 19) {
				token = parent;
			}
			break _hx_loop1;
		case 13:case 21:
			break _hx_loop1;
		default:
			token = parent;
			parent = parent.parent;
		}
	}
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
};
tokentree_walk_WalkStatement.walkOpAdd = function(stream,token) {
	var parent = token.parent;
	_hx_loop1: while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				break _hx_loop1;
			case 3:case 5:case 10:case 24:case 28:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 6:
			var _g1 = _g.op;
			switch(_g1._hx_index) {
			case 0:case 3:
				token = parent.parent;
				break _hx_loop1;
			case 1:case 2:
				token = parent;
				parent = parent.parent;
				break;
			case 4:
				break _hx_loop1;
			case 20:
				var _g2 = _g1.op;
				break _hx_loop1;
			default:
				break _hx_loop1;
			}
			break;
		case 9:
			var _g3 = _g.s;
			break _hx_loop1;
		case 12:
			break _hx_loop1;
		case 15:case 17:
			break _hx_loop1;
		case 19:
			var pClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
			if(pClose == null) {
				token = parent;
				break _hx_loop1;
			}
			token = parent;
			parent = parent.parent;
			break;
		case 13:case 21:
			break _hx_loop1;
		default:
			token = parent;
			parent = parent.parent;
		}
	}
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
};
tokentree_walk_WalkStatement.walkDollarStatement = function(stream,parent) {
	var dollarTok = stream.consumeToken();
	parent.addChild(dollarTok);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
			}
		}
		break;
	case 6:
		var _g1 = _g.op;
		tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
		break;
	case 11:case 15:case 17:case 19:
		tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
		break;
	default:
	}
};
var tokentree_walk_WalkSwitch = function() { };
$hxClasses["tokentree.walk.WalkSwitch"] = tokentree_walk_WalkSwitch;
tokentree_walk_WalkSwitch.__name__ = "tokentree.walk.WalkSwitch";
tokentree_walk_WalkSwitch.walkSwitch = function(stream,parent) {
	var switchTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdSwitch));
	parent.addChild(switchTok);
	stream.applyTempStore(switchTok);
	tokentree_walk_WalkComment.walkComment(stream,switchTok);
	tokentree_walk_WalkStatement.walkStatement(stream,switchTok);
	tokentree_walk_WalkComment.walkComment(stream,switchTok);
	var _g = stream.token();
	if(_g._hx_index == 3) {
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
	}
	if(stream.tokenForMatch()._hx_index == 17) {
		var brOpen = stream.consumeToken();
		switchTok.addChild(brOpen);
		tokentree_walk_WalkSwitch.walkSwitchCases(stream,brOpen);
		brOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	}
};
tokentree_walk_WalkSwitch.walkSwitchCases = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:case 16:
				tokentree_walk_WalkSwitch.walkCase(stream,parent);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
			break;
		case 7:
			var _g2 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 8:
			var _g3 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 18:
			break _hx_loop1;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
tokentree_walk_WalkSwitch.walkCase = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var caseTok = stream.consumeToken();
	parent.addChild(caseTok);
	tokentree_walk_WalkSwitch.walkCaseExpr(stream,caseTok);
	var dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
	caseTok.addChild(dblDot);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:case 16:
				return;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
			tokentree_walk_WalkSwitch.relocateSharpTree(parent,dblDot);
			break;
		case 7:
			var _g2 = _g.s;
			var _g3 = stream.peekNonCommentToken();
			if(_g3 != null) {
				if(_g3._hx_index == 1) {
					switch(_g3.k._hx_index) {
					case 15:case 16:
						return;
					default:
					}
				}
			}
			tokentree_walk_WalkComment.walkComment(stream,dblDot);
			break;
		case 8:
			var _g4 = _g.s;
			var _g5 = stream.peekNonCommentToken();
			if(_g5 != null) {
				if(_g5._hx_index == 1) {
					switch(_g5.k._hx_index) {
					case 15:case 16:
						return;
					default:
					}
				}
			}
			tokentree_walk_WalkComment.walkComment(stream,dblDot);
			break;
		case 17:
			tokentree_walk_WalkBlock.walkBlock(stream,dblDot);
			break;
		case 18:
			return;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
		}
	}
};
tokentree_walk_WalkSwitch.relocateSharpTree = function(parent,dblDot) {
	var sharp = parent.getLastChild();
	if(sharp.children.length < 2) {
		return;
	}
	var body = sharp.children[1];
	var _g = body.tok;
	if(_g._hx_index == 1 && _g.k._hx_index == 15) {
		return;
	}
	parent.children.pop();
	dblDot.addChild(sharp);
};
tokentree_walk_WalkSwitch.walkCaseExpr = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 2) {
				var varTok = stream.consumeToken();
				parent.addChild(varTok);
				tokentree_walk_WalkStatement.walkStatement(stream,varTok);
			} else {
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 14:
			var comma = stream.consumeToken();
			var child = parent.getLastChild();
			if(child == null) {
				child = parent;
			}
			child.addChild(comma);
			break;
		case 10:case 12:case 16:case 18:case 20:
			return;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
var tokentree_walk_WalkTry = function() { };
$hxClasses["tokentree.walk.WalkTry"] = tokentree_walk_WalkTry;
tokentree_walk_WalkTry.__name__ = "tokentree.walk.WalkTry";
tokentree_walk_WalkTry.walkTry = function(stream,parent) {
	var tryTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTry));
	parent.addChild(tryTok);
	stream.applyTempStore(tryTok);
	tokentree_walk_WalkBlock.walkBlock(stream,tryTok);
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 21) {
				var _g1 = 0;
				while(_g1 < comments.length) {
					var comment = comments[_g1];
					++_g1;
					tryTok.addChild(comment);
				}
				comments = [];
				tokentree_walk_WalkTry.walkCatch(stream,tryTok);
				currentPos = stream.getStreamIndex();
			} else {
				stream.rewindTo(currentPos);
				return;
			}
			break;
		case 7:
			var _g2 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 8:
			var _g3 = _g.s;
			comments.push(stream.consumeToken());
			break;
		default:
			stream.rewindTo(currentPos);
			return;
		}
	}
};
tokentree_walk_WalkTry.walkCatch = function(stream,parent) {
	var catchTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdCatch));
	parent.addChild(catchTok);
	tokentree_walk_WalkPOpen.walkPOpen(stream,catchTok);
	tokentree_walk_WalkComment.walkComment(stream,catchTok);
	tokentree_walk_WalkBlock.walkBlock(stream,catchTok);
};
var tokentree_walk_WalkType = function() { };
$hxClasses["tokentree.walk.WalkType"] = tokentree_walk_WalkType;
tokentree_walk_WalkType.__name__ = "tokentree.walk.WalkType";
tokentree_walk_WalkType.walkType = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 1:
			tokentree_walk_WalkClass.walkClass(stream,parent);
			break;
		case 26:
			tokentree_walk_WalkEnum.walkEnum(stream,parent);
			break;
		case 27:
			tokentree_walk_WalkInterface.walkInterface(stream,parent);
			break;
		case 31:
			tokentree_walk_WalkTypedef.walkTypedef(stream,parent);
			break;
		case 39:
			tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
			break;
		default:
		}
	}
};
var tokentree_walk_WalkTypeNameDef = function() { };
$hxClasses["tokentree.walk.WalkTypeNameDef"] = tokentree_walk_WalkTypeNameDef;
tokentree_walk_WalkTypeNameDef.__name__ = "tokentree.walk.WalkTypeNameDef";
tokentree_walk_WalkTypeNameDef.walkTypeNameDef = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkAt.walkAts(stream);
	if(stream.tokenForMatch()._hx_index == 21) {
		var questTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Question);
		parent.addChild(questTok);
		parent = questTok;
		tokentree_walk_WalkComment.walkComment(stream,parent);
	}
	var name;
	var bAdd = true;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 22:case 25:case 40:
			name = stream.consumeToken();
			break;
		default:
			name = stream.consumeToken();
		}
		break;
	case 2:
		var _g1 = _g.c;
		name = stream.consumeConst();
		break;
	case 3:
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		if(!stream.hasMore()) {
			return parent.getFirstChild();
		}
		var _g1 = stream.token();
		if(_g1._hx_index == 2) {
			var _g2 = _g1.c;
			name = stream.consumeConst();
		} else {
			return parent.getFirstChild();
		}
		break;
	case 4:
		var _g1 = _g.s;
		name = stream.consumeToken();
		break;
	case 15:
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
		return parent.getFirstChild();
	case 17:
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
		return parent.getFirstChild();
	case 19:
		name = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
		if(stream.tokenForMatch()._hx_index == 21) {
			tokentree_walk_WalkQuestion.walkQuestion(stream,name);
		}
		bAdd = false;
		break;
	default:
		name = stream.consumeToken();
	}
	stream.applyTempStore(name);
	if(bAdd) {
		parent.addChild(name);
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefContinue(stream,name);
	return name;
};
tokentree_walk_WalkTypeNameDef.walkTypeNameDefContinue = function(stream,parent) {
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
	if(stream.tokenForMatch()._hx_index == 11) {
		var dot = stream.consumeToken();
		parent.addChild(dot);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dot);
		return;
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 9) {
		tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		var arrow = stream.consumeToken();
		parent.addChild(arrow);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,arrow);
		return;
	}
	if(stream.tokenForMatch()._hx_index == 15) {
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
};
tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment = function(stream,parent) {
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 6:
			var _g1 = _g.op;
			var _g2 = 0;
			while(_g2 < comments.length) {
				var comment = comments[_g2];
				++_g2;
				parent.addChild(comment);
			}
			return;
		case 7:
			var _g3 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 8:
			var _g4 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 10:case 11:case 12:case 14:case 15:case 17:case 19:
			var _g5 = 0;
			while(_g5 < comments.length) {
				var comment1 = comments[_g5];
				++_g5;
				parent.addChild(comment1);
			}
			return;
		default:
			stream.rewindTo(currentPos);
			return;
		}
	}
};
var tokentree_walk_WalkTypedef = function() { };
$hxClasses["tokentree.walk.WalkTypedef"] = tokentree_walk_WalkTypedef;
tokentree_walk_WalkTypedef.__name__ = "tokentree.walk.WalkTypedef";
tokentree_walk_WalkTypedef.walkTypedef = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 4) {
		var assign = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		name.addChild(assign);
		name = assign;
	}
	tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,name);
};
var tokentree_walk_WalkTypedefBody = function() { };
$hxClasses["tokentree.walk.WalkTypedefBody"] = tokentree_walk_WalkTypedefBody;
tokentree_walk_WalkTypedefBody.__name__ = "tokentree.walk.WalkTypedefBody";
tokentree_walk_WalkTypedefBody.walkTypedefBody = function(stream,parent) {
	if(stream.tokenForMatch()._hx_index == 17) {
		var openTok = stream.consumeToken();
		parent.addChild(openTok);
		tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody(stream,openTok);
		openTok.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	} else {
		tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,parent);
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 11) {
		var and = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd));
		parent.getLastChild().addChild(and);
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		tokentree_walk_WalkStatement.walkStatement(stream,parent);
	}
};
tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody = function(stream,openTok) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,openTok);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,openTok);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,openTok);
				break;
			default:
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,openTok,tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody);
			break;
		case 6:
			if(_g.op._hx_index == 7) {
				tokentree_walk_WalkTypedefBody.walkStructureExtension(stream,openTok);
			} else {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
			break;
		case 7:
			var _g2 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,openTok);
			}
			break;
		case 8:
			var _g3 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,openTok);
			}
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
		}
	}
	var tempStore = stream.getTempStore();
	if(tempStore.length > 0) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
		case 1:
			stream.applyTempStore(openTok);
			break;
		}
	}
};
tokentree_walk_WalkTypedefBody.walkTypedefAlias = function(stream,parent) {
	var newParent;
	if(stream.tokenForMatch()._hx_index == 19) {
		newParent = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
	} else {
		newParent = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		var arrowTok = stream.consumeToken();
		newParent.addChild(arrowTok);
		tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,arrowTok);
	}
	if(stream.tokenForMatch()._hx_index == 10) {
		newParent.addChild(stream.consumeToken());
	}
};
tokentree_walk_WalkTypedefBody.walkStructureExtension = function(stream,parent) {
	var gt = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
	parent.addChild(gt);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	gt.addChild(name);
	if(stream.tokenForMatch()._hx_index == 14) {
		name.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkVar = function() { };
$hxClasses["tokentree.walk.WalkVar"] = tokentree_walk_WalkVar;
tokentree_walk_WalkVar.__name__ = "tokentree.walk.WalkVar";
tokentree_walk_WalkVar.walkVar = function(stream,parent) {
	var name = null;
	var varTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdVar));
	parent.addChild(varTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.tokenForMatch();
		if(_g._hx_index == 1 && _g.k._hx_index == 2) {
			return;
		}
		tokentree_walk_WalkComment.walkComment(stream,parent);
		if(stream.token()._hx_index == 22) {
			tokentree_walk_WalkAt.walkAts(stream);
		}
		tokentree_walk_WalkComment.walkComment(stream,parent);
		var nameParent = varTok;
		if(stream.tokenForMatch()._hx_index == 21) {
			nameParent = stream.consumeToken();
			varTok.addChild(nameParent);
		}
		name = stream.consumeConstIdent();
		nameParent.addChild(name);
		stream.applyTempStore(name);
		tokentree_walk_WalkComment.walkComment(stream,name);
		if(stream.tokenForMatch()._hx_index == 19) {
			tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 12) {
			var dblDot = stream.consumeToken();
			name.addChild(dblDot);
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
		}
		var _g1 = stream.tokenForMatch();
		if(_g1._hx_index == 6 && _g1.op._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatement(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 14) {
			var comma = stream.consumeToken();
			name.addChild(comma);
			continue;
		}
		break;
	}
	if(stream.tokenForMatch()._hx_index == 10) {
		name.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkWhile = function() { };
$hxClasses["tokentree.walk.WalkWhile"] = tokentree_walk_WalkWhile;
tokentree_walk_WalkWhile.__name__ = "tokentree.walk.WalkWhile";
tokentree_walk_WalkWhile.walkWhile = function(stream,parent) {
	var whileTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
	parent.addChild(whileTok);
	stream.applyTempStore(whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	tokentree_walk_WalkBlock.walkBlock(stream,whileTok);
};
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = "String";
$hxClasses["Array"] = Array;
Array.__name__ = "Array";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
CompileTimeClassList.__meta__ = { obj : { classLists : [["null,true,checkstyle.checks.Check","checkstyle.checks.block.BlockBreakingConditionalCheck,checkstyle.checks.block.ConditionalCompilationCheck,checkstyle.checks.block.EmptyBlockCheck,checkstyle.checks.block.LeftCurlyCheck,checkstyle.checks.block.NeedBracesCheck,checkstyle.checks.block.RightCurlyCheck,checkstyle.checks.coding.ArrowFunctionCheck,checkstyle.checks.coding.AvoidTernaryOperatorCheck,checkstyle.checks.coding.CodeSimilarityCheck,checkstyle.checks.coding.DefaultComesLastCheck,checkstyle.checks.coding.HiddenFieldCheck,checkstyle.checks.coding.InnerAssignmentCheck,checkstyle.checks.coding.MagicNumberCheck,checkstyle.checks.coding.MultipleVariableDeclarationsCheck,checkstyle.checks.coding.NestedControlFlowCheck,checkstyle.checks.coding.NestedForDepthCheck,checkstyle.checks.coding.NestedIfDepthCheck,checkstyle.checks.coding.NestedTryDepthCheck,checkstyle.checks.coding.NullableParameterCheck,checkstyle.checks.coding.ReturnCountCheck,checkstyle.checks.coding.SimplifyBooleanExpressionCheck,checkstyle.checks.coding.SimplifyBooleanReturnCheck,checkstyle.checks.coding.TraceCheck,checkstyle.checks.coding.UnusedLocalVarCheck,checkstyle.checks.coding.VariableInitialisationCheck,checkstyle.checks.comments.DocCommentStyleCheck,checkstyle.checks.comments.FieldDocCommentCheck,checkstyle.checks.comments.TODOCommentCheck,checkstyle.checks.comments.TypeDocCommentCheck,checkstyle.checks.design.EmptyPackageCheck,checkstyle.checks.design.InterfaceCheck,checkstyle.checks.design.UnnecessaryConstructorCheck,checkstyle.checks.imports.AvoidStarImportCheck,checkstyle.checks.imports.UnusedImportCheck,checkstyle.checks.literal.ArrayLiteralCheck,checkstyle.checks.literal.ERegLiteralCheck,checkstyle.checks.literal.HexadecimalLiteralCheck,checkstyle.checks.literal.MultipleStringLiteralsCheck,checkstyle.checks.literal.StringLiteralCheck,checkstyle.checks.meta.RedundantAccessMetaBase,checkstyle.checks.meta.RedundantAccessMetaCheck,checkstyle.checks.meta.RedundantAllowMetaCheck,checkstyle.checks.metrics.CyclomaticComplexityCheck,checkstyle.checks.modifier.FinalCheck,checkstyle.checks.modifier.ModifierOrderCheck,checkstyle.checks.modifier.PublicAccessorCheck,checkstyle.checks.modifier.RedundantModifierCheck,checkstyle.checks.naming.CatchParameterNameCheck,checkstyle.checks.naming.NameCheckBase,checkstyle.checks.naming.ConstantNameCheck,checkstyle.checks.naming.ListenerNameCheck,checkstyle.checks.naming.LocalVariableNameCheck,checkstyle.checks.naming.MemberNameCheck,checkstyle.checks.naming.MethodNameCheck,checkstyle.checks.naming.ParameterNameCheck,checkstyle.checks.naming.TypeNameCheck,checkstyle.checks.size.FileLengthCheck,checkstyle.checks.size.LineLengthCheck,checkstyle.checks.size.MethodCountCheck,checkstyle.checks.size.MethodLengthCheck,checkstyle.checks.size.ParameterNumberCheck,checkstyle.checks.type.AnonymousCheck,checkstyle.checks.type.AvoidIdentifierCheck,checkstyle.checks.type.DynamicCheck,checkstyle.checks.type.ReturnCheck,checkstyle.checks.type.TypeCheck,checkstyle.checks.type.VarTypeHintCheck,checkstyle.checks.whitespace.ArrayAccessCheck,checkstyle.checks.whitespace.LineCheckBase,checkstyle.checks.whitespace.EmptyLinesCheck,checkstyle.checks.whitespace.ExtendedEmptyLinesCheck,checkstyle.checks.whitespace.IndentationCharacterCheck,checkstyle.checks.whitespace.IndentationCheck,checkstyle.checks.whitespace.WhitespaceCheckBase,checkstyle.checks.whitespace.OperatorWhitespaceCheck,checkstyle.checks.whitespace.WrapCheckBase,checkstyle.checks.whitespace.OperatorWrapCheck,checkstyle.checks.whitespace.SeparatorWhitespaceCheck,checkstyle.checks.whitespace.SeparatorWrapCheck,checkstyle.checks.whitespace.SpacingCheck,checkstyle.checks.whitespace.TabForAligningCheck,checkstyle.checks.whitespace.TrailingWhitespaceCheck,checkstyle.checks.whitespace.WhitespaceAfterCheck,checkstyle.checks.whitespace.WhitespaceAroundCheck"]]}};
checkstyle_Checker.BAD_OFFSET = "Bad offset";
checkstyle_Main.DEFAULT_CONFIG = "checkstyle.json";
checkstyle_Main.DEFAULT_EXCLUDE_CONFIG = "checkstyle-exclude.json";
checkstyle_Main.REPORT_TYPE = "text";
checkstyle_Main.XML_PATH = "check-style-report.xml";
checkstyle_Main.JSON_PATH = "check-style-report.json";
checkstyle_Main.STYLE = "";
checkstyle_Main.SHOW_PROGRESS = false;
checkstyle_Main.EXIT_CODE = false;
checkstyle_Main.NO_STYLE = false;
checkstyle_Main.CODE_CLIMATE_REPORTER = "codeclimate";
checkstyle_Main.SHOW_MISSING_CHECKS = false;
checkstyle_checks_block_BlockBreakingConditionalCheck.__meta__ = { obj : { name : ["BlockBreakingConditional"], desc : ["Checks for block breaking conditionals."]}};
checkstyle_checks_block_ConditionalCompilationCheck.__meta__ = { obj : { name : ["ConditionalCompilation"], desc : ["Checks placement and indentation of conditional compilation flags."]}};
checkstyle_checks_block_EmptyBlockCheck.__meta__ = { obj : { name : ["EmptyBlock"], desc : ["Checks for empty blocks. The policy to verify is specified using the property `option`."]}};
checkstyle_checks_block_LeftCurlyCheck.__meta__ = { obj : { name : ["LeftCurly"], desc : ["Checks for the placement of left curly braces (`{`) for code blocks. The policy to verify is specified using the property `option`."]}};
checkstyle_checks_block_NeedBracesCheck.__meta__ = { obj : { name : ["NeedBraces"], desc : ["Checks for braces on function, if, for and while statements. It has an option to allow single line statements without braces using property `allowSingleLineStatement` like `if (b) return 10;`."]}};
checkstyle_checks_block_RightCurlyCheck.__meta__ = { obj : { name : ["RightCurly"], desc : ["Checks the placement of right curly braces (`}`) for code blocks. The policy to verify is specified using the property `option`."]}};
checkstyle_checks_coding_ArrowFunctionCheck.__meta__ = { obj : { name : ["ArrowFunction"], desc : ["Checks for use of curlies, nested (non-arrow) functions or returns in arrow functions."]}};
checkstyle_checks_coding_AvoidTernaryOperatorCheck.__meta__ = { obj : { name : ["AvoidTernaryOperator","AvoidInlineConditionals"], desc : ["Detects ternary operators. Useful for developers who find ternary operators hard to read and want forbid them."]}};
checkstyle_checks_coding_CodeSimilarityCheck.__meta__ = { obj : { name : ["CodeSimilarity"], desc : ["Checks for identical or similar code."]}};
checkstyle_checks_coding_CodeSimilarityCheck.SIMILAR_HASHES = new haxe_ds_StringMap();
checkstyle_checks_coding_CodeSimilarityCheck.IDENTICAL_HASHES = new haxe_ds_StringMap();
checkstyle_checks_coding_CodeSimilarityCheck.LOCK = new checkstyle_utils_DummyMutex();
checkstyle_checks_coding_DefaultComesLastCheck.__meta__ = { obj : { name : ["DefaultComesLast"], desc : ["Check that the `default` is after all the cases in a `switch` statement. Haxe allows `default` anywhere within the `switch` statement. But it is more readable if it comes after the last `case`."]}};
checkstyle_checks_coding_HiddenFieldCheck.__meta__ = { obj : { name : ["HiddenField"], desc : ["Checks that a local variable or a parameter does not shadow a field that is defined in the same class."]}};
checkstyle_checks_coding_HiddenFieldCheck.MAX_FIELD_LEVEL = 3;
checkstyle_checks_coding_InnerAssignmentCheck.__meta__ = { obj : { name : ["InnerAssignment"], desc : ["Checks for assignments in subexpressions, such as in `if ((a=b) > 0) return;`."]}};
checkstyle_checks_coding_MagicNumberCheck.__meta__ = { obj : { name : ["MagicNumber"], desc : ["Checks that there are no magic numbers. By default, -1, 0, 1, and 2 are not considered to be magic numbers."]}};
checkstyle_checks_coding_MultipleVariableDeclarationsCheck.__meta__ = { obj : { name : ["MultipleVariableDeclarations"], desc : ["Checks that each variable declaration is in its own statement and on its own line."]}};
checkstyle_checks_coding_NestedControlFlowCheck.__meta__ = { obj : { name : ["NestedControlFlow"], desc : ["Checks for maximium nesting depth of control flow expressions (`if`, `for`, `while`, `do/while`, `switch` and `try`)."]}};
checkstyle_checks_coding_NestedForDepthCheck.__meta__ = { obj : { name : ["NestedForDepth"], desc : ["Restricts nested loop blocks to a specified depth (default = 1)."]}};
checkstyle_checks_coding_NestedIfDepthCheck.__meta__ = { obj : { name : ["NestedIfDepth"], desc : ["Restricts nested `if-else` blocks to a specified depth (default = 1)."]}};
checkstyle_checks_coding_NestedTryDepthCheck.__meta__ = { obj : { name : ["NestedTryDepth"], desc : ["Restricts nested `try` blocks to a specified depth (default = 1)."]}};
checkstyle_checks_coding_NullableParameterCheck.__meta__ = { obj : { name : ["NullableParameter"], desc : ["Enforces a style for nullable parameters."]}};
checkstyle_checks_coding_ReturnCountCheck.__meta__ = { obj : { name : ["ReturnCount"], desc : ["Restricts the number of return statements in methods (2 by default). Ignores methods that matches `ignoreFormat` regex property."]}};
checkstyle_checks_coding_SimplifyBooleanExpressionCheck.__meta__ = { obj : { name : ["SimplifyBooleanExpression"], desc : ["Checks for over-complicated boolean expressions. Finds code like `if (b == true), b || true, !false`, etc."]}};
checkstyle_checks_coding_SimplifyBooleanReturnCheck.__meta__ = { obj : { name : ["SimplifyBooleanReturn"], desc : ["Checks for over-complicated boolean return statements."]}};
checkstyle_checks_coding_TraceCheck.__meta__ = { obj : { name : ["Trace"], desc : ["Checks for trace calls in code."]}};
checkstyle_checks_coding_UnusedLocalVarCheck.__meta__ = { obj : { name : ["UnusedLocalVar"], desc : ["Checks for unused local variables."]}};
checkstyle_checks_coding_VariableInitialisationCheck.__meta__ = { obj : { name : ["VariableInitialisation"], desc : ["Checks for instance variables that are initialised at class level."]}};
checkstyle_checks_comments_DocCommentStyleCheck.__meta__ = { obj : { name : ["DocCommentStyle"], desc : ["Checks code documentation style (/**...**/ vs /*...*/)"]}};
checkstyle_checks_comments_FieldDocCommentCheck.__meta__ = { obj : { name : ["FieldDocComment"], desc : ["Checks code documentation on fields"]}};
checkstyle_checks_comments_TODOCommentCheck.__meta__ = { obj : { name : ["TODOComment"], desc : ["A check for TODO/FIXME/HACK/XXX/BUG comments. The format can be customised by changing `format` property."]}};
checkstyle_checks_comments_TypeDocCommentCheck.__meta__ = { obj : { name : ["TypeDocComment"], desc : ["Checks code documentation on type level"]}};
checkstyle_checks_design_EmptyPackageCheck.__meta__ = { obj : { name : ["EmptyPackage"], desc : ["Checks for empty package names."]}};
checkstyle_checks_design_InterfaceCheck.__meta__ = { obj : { name : ["Interface"], desc : ["Checks and enforces interface style. Either to allow properties and methods or just methods. Has an option to `allowMarkerInterfaces`."]}};
checkstyle_checks_design_UnnecessaryConstructorCheck.__meta__ = { obj : { name : ["UnnecessaryConstructor"], desc : ["Checks for unnecessary constructor in classes that contain only static methods or fields."]}};
checkstyle_checks_imports_AvoidStarImportCheck.__meta__ = { obj : { name : ["AvoidStarImport"], desc : ["Checks for import statements that use the * notation and using directives."]}};
checkstyle_checks_imports_UnusedImportCheck.__meta__ = { obj : { name : ["UnusedImport"], desc : ["Checks for unused or duplicate imports."]}};
checkstyle_checks_literal_ArrayLiteralCheck.__meta__ = { obj : { name : ["ArrayLiteral","ArrayInstantiation"], desc : ["Checks if the array is instantiated using [] which is shorter and cleaner, not with new."]}};
checkstyle_checks_literal_ERegLiteralCheck.__meta__ = { obj : { name : ["ERegLiteral","ERegInstantiation"], desc : ["Checks for usage of EReg literals (between ~/ and /) instead of new."]}};
checkstyle_checks_literal_HexadecimalLiteralCheck.__meta__ = { obj : { name : ["HexadecimalLiteral","HexadecimalLiterals"], desc : ["Checks the letter case of hexadecimal literals."]}};
checkstyle_checks_literal_MultipleStringLiteralsCheck.__meta__ = { obj : { name : ["MultipleStringLiterals"], desc : ["Checks for multiple occurrences of the same string literal within a single file. Code duplication makes maintenance more difficult, so it's better to replace the multiple occurrences with a constant."]}};
checkstyle_checks_literal_StringLiteralCheck.__meta__ = { obj : { name : ["StringLiteral"], desc : ["Checks for single or double quote string literals."]}};
checkstyle_checks_meta_RedundantAccessMetaBase.__meta__ = { obj : { ignore : ["Base class for name checks"]}};
checkstyle_checks_meta_RedundantAccessMetaCheck.__meta__ = { obj : { name : ["RedundantAccessMeta"], desc : ["Checks for redundant @:access metadata"]}};
checkstyle_checks_meta_RedundantAllowMetaCheck.__meta__ = { obj : { name : ["RedundantAllowMeta"], desc : ["Checks for redundant @:allow metadata"]}};
checkstyle_checks_metrics_CyclomaticComplexityCheck.__meta__ = { obj : { name : ["CyclomaticComplexity"], desc : ["Checks the complexity of methods using McCabe simplified cyclomatic complexity check. Complexity levels can be customised using `thresholds` property."]}};
checkstyle_checks_metrics_CyclomaticComplexityCheck.DEFAULT_COMPLEXITY_WARNING = 20;
checkstyle_checks_metrics_CyclomaticComplexityCheck.DEFAULT_COMPLEXITY_ERROR = 25;
checkstyle_checks_modifier_FinalCheck.__meta__ = { obj : { name : ["Final","InlineFinal"], desc : ["Checks for places that use var instead of final (Haxe 4+)."]}};
checkstyle_checks_modifier_ModifierOrderCheck.__meta__ = { obj : { name : ["ModifierOrder","AccessOrder"], desc : ["Checks that the order of modifiers conforms to the standards."]}};
checkstyle_checks_modifier_ModifierOrderCheckModifier.PUBLIC_PRIVATE = "PUBLIC_PRIVATE";
checkstyle_checks_modifier_ModifierOrderCheckModifier.INLINE = "INLINE";
checkstyle_checks_modifier_ModifierOrderCheckModifier.STATIC = "STATIC";
checkstyle_checks_modifier_ModifierOrderCheckModifier.OVERRIDE = "OVERRIDE";
checkstyle_checks_modifier_ModifierOrderCheckModifier.MACRO = "MACRO";
checkstyle_checks_modifier_ModifierOrderCheckModifier.DYNAMIC = "DYNAMIC";
checkstyle_checks_modifier_ModifierOrderCheckModifier.EXTERN = "EXTERN";
checkstyle_checks_modifier_ModifierOrderCheckModifier.FINAL = "FINAL";
checkstyle_checks_modifier_ModifierOrderCheckModifier.ABSTRACT = "ABSTRACT";
checkstyle_checks_modifier_ModifierOrderCheckModifier.OVERLOAD = "OVERLOAD";
checkstyle_checks_modifier_PublicAccessorCheck.__meta__ = { obj : { name : ["PublicAccessor"], desc : ["Checks for public accessors."]}};
checkstyle_checks_modifier_RedundantModifierCheck.__meta__ = { obj : { name : ["RedundantModifier","PublicPrivate"], desc : ["Checks for redundant modifiers."]}};
checkstyle_checks_naming_CatchParameterNameCheck.__meta__ = { obj : { name : ["CatchParameterName"], desc : ["Checks that catch parameter names conform to a format specified by the `format` property."]}};
checkstyle_checks_naming_NameCheckBase.__meta__ = { obj : { ignore : ["Base class for name checks"]}};
checkstyle_checks_naming_ConstantNameCheck.__meta__ = { obj : { name : ["ConstantName"], desc : ["Checks that the constants (static / static inline with initialisation) conform to a format specified by the `format` property."]}};
checkstyle_checks_naming_ListenerNameCheck.__meta__ = { obj : { name : ["ListenerName"], desc : ["Checks the naming conventions of event listener functions specified using `listeners` property."]}};
checkstyle_checks_naming_LocalVariableNameCheck.__meta__ = { obj : { name : ["LocalVariableName"], desc : ["Checks that the local variable names conform to a format specified by the `format` property."]}};
checkstyle_checks_naming_MemberNameCheck.__meta__ = { obj : { name : ["MemberName"], desc : ["Checks that instance variable names conform to a format specified by the `format` property."]}};
checkstyle_checks_naming_MethodNameCheck.__meta__ = { obj : { name : ["MethodName"], desc : ["Checks that method names conform to a format specified by the `format` property."]}};
checkstyle_checks_naming_ParameterNameCheck.__meta__ = { obj : { name : ["ParameterName"], desc : ["Checks that parameter names conform to a format specified by the `format` property."]}};
checkstyle_checks_naming_TypeNameCheck.__meta__ = { obj : { name : ["TypeName"], desc : ["Checks that type names conform to a format specified by the `format` property."]}};
checkstyle_checks_size_FileLengthCheck.__meta__ = { obj : { name : ["FileLength"], desc : ["Checks for long source files. If a source file becomes very long it is hard to understand. Therefore long classes should usually be refactored into several individual classes that focus on a specific task."]}};
checkstyle_checks_size_FileLengthCheck.DEFAULT_MAX_LENGTH = 1000;
checkstyle_checks_size_LineLengthCheck.__meta__ = { obj : { name : ["LineLength"], desc : ["Checks for long lines. Long lines are hard to read."]}};
checkstyle_checks_size_LineLengthCheck.DEFAULT_MAX_LENGTH = 160;
checkstyle_checks_size_MethodCountCheck.__meta__ = { obj : { name : ["MethodCount"], desc : ["Checks the number of methods declared in each type. This includes the number of each scope (`private` and `public`) as well as an overall total."]}};
checkstyle_checks_size_MethodCountCheck.DEFAULT_MAX_COUNT = 100;
checkstyle_checks_size_MethodLengthCheck.__meta__ = { obj : { name : ["MethodLength"], desc : ["Checks for long methods. If a method becomes very long it is hard to understand. Therefore long methods should usually be refactored into several individual methods that focus on a specific task."]}};
checkstyle_checks_size_MethodLengthCheck.DEFAULT_MAX_LENGTH = 50;
checkstyle_checks_size_ParameterNumberCheck.__meta__ = { obj : { name : ["ParameterNumber"], desc : ["Checks the number of parameters of a method."]}};
checkstyle_checks_size_ParameterNumberCheck.DEFAULT_MAX_PARAMS = 7;
checkstyle_checks_type_AnonymousCheck.__meta__ = { obj : { name : ["Anonymous"], desc : ["Check to find any anonymous type structures used."]}};
checkstyle_checks_type_AvoidIdentifierCheck.__meta__ = { obj : { name : ["AvoidIdentifier"], desc : ["Checks for identifiers to avoid."]}};
checkstyle_checks_type_DynamicCheck.__meta__ = { obj : { name : ["Dynamic"], desc : ["Checks for use of Dynamic type anywhere in the code."]}};
checkstyle_checks_type_ReturnCheck.__meta__ = { obj : { name : ["Return"], desc : ["Warns if Void is used for return or if return type is not specified when returning."]}};
checkstyle_checks_type_TypeCheck.__meta__ = { obj : { name : ["Type"], desc : ["Checks if type is specified or not for member variables."]}};
checkstyle_checks_type_VarTypeHintCheck.__meta__ = { obj : { name : ["VarTypeHint","EnforceVarTypeHint"], desc : ["Checks type hints of variables."]}};
checkstyle_checks_whitespace_ArrayAccessCheck.__meta__ = { obj : { name : ["ArrayAccess"], desc : ["Checks for spaces before array access or inside array elements. Finds code like `a [0], a[ 0]`, etc."]}};
checkstyle_checks_whitespace_LineCheckBase.__meta__ = { obj : { ignore : ["base class for line based whitespace checks"]}};
checkstyle_checks_whitespace_EmptyLinesCheck.__meta__ = { obj : { name : ["EmptyLines"], desc : ["Checks for consecutive empty lines (default is 1). Also have options to check empty line separators after package, single-line and multi-line comments and class/interface/abstract declarations."]}};
checkstyle_checks_whitespace_ExtendedEmptyLinesCheck.__meta__ = { obj : { name : ["ExtendedEmptyLines"], desc : ["Checks for consecutive empty lines."]}};
checkstyle_checks_whitespace_IndentationCharacterCheck.__meta__ = { obj : { name : ["IndentationCharacter"], desc : ["Checks indentation character (tab/space, default is tab)."]}};
checkstyle_checks_whitespace_IndentationCheck.__meta__ = { obj : { name : ["Indentation"], desc : ["Checks correct indentation"]}};
checkstyle_checks_whitespace_WhitespaceCheckBase.__meta__ = { obj : { ignore : ["base class for OperatorWhitespace and SeparatorWhitespace"]}};
checkstyle_checks_whitespace_OperatorWhitespaceCheck.__meta__ = { obj : { name : ["OperatorWhitespace"], desc : ["Checks that whitespace is present or absent around a operators."]}};
checkstyle_checks_whitespace_WrapCheckBase.__meta__ = { obj : { ignore : ["base class for OperatorWrap and SeparatorWrap"]}};
checkstyle_checks_whitespace_OperatorWrapCheck.__meta__ = { obj : { name : ["OperatorWrap"], desc : ["Checks line wrapping with operators."]}};
checkstyle_checks_whitespace_SeparatorWhitespaceCheck.__meta__ = { obj : { name : ["SeparatorWhitespace"], desc : ["Checks that whitespace is present or absent around a separators."]}};
checkstyle_checks_whitespace_SeparatorWrapCheck.__meta__ = { obj : { name : ["SeparatorWrap"], desc : ["Checks line wrapping with separators."]}};
checkstyle_checks_whitespace_SpacingCheck.__meta__ = { obj : { name : ["Spacing"], desc : ["Spacing check on if, for, while, switch, try statements and around operators."]}};
checkstyle_checks_whitespace_TabForAligningCheck.__meta__ = { obj : { name : ["TabForAligning"], desc : ["Checks if there are any tabs in the middle of a line."]}};
checkstyle_checks_whitespace_TrailingWhitespaceCheck.__meta__ = { obj : { name : ["TrailingWhitespace"], desc : ["Checks if there are any trailing white spaces."]}};
checkstyle_checks_whitespace_WhitespaceAfterCheck.__meta__ = { obj : { name : ["WhitespaceAfter"], desc : ["Checks for whitespace after a token."]}};
checkstyle_checks_whitespace_WhitespaceAroundCheck.__meta__ = { obj : { name : ["WhitespaceAround"], desc : ["Checks that a token is surrounded by whitespace."]}};
checkstyle_config_ExcludeManager.INSTANCE = new checkstyle_config_ExcludeManager();
checkstyle_reporter_CodeClimateReporter.INFO = "info";
checkstyle_reporter_CodeClimateReporter.NORMAL = "normal";
checkstyle_reporter_CodeClimateReporter.CRITICAL = "critical";
checkstyle_reporter_CodeClimateReporter.REMEDIATION_BASE = 50000;
checkstyle_reporter_ReporterManager.INSTANCE = new checkstyle_reporter_ReporterManager();
checkstyle_reporter_ReporterManager.SHOW_PARSE_ERRORS = false;
checkstyle_reporter_XMLReporter.ENTITY_MAP = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["&"] = "&amp;";
	_g.h["<"] = "&lt;";
	_g.h[">"] = "&gt;";
	_g.h["\""] = "&quot;";
	_g.h["'"] = "&#39;";
	_g.h["/"] = "&#x2F;";
	$r = _g;
	return $r;
}(this));
checkstyle_reporter_XMLReporter.ENTITY_RE = new EReg("[&<>\"'/]","g");
hxparse_LexEngine.MAX_CODE = 255;
hxparse_LexEngine.EMPTY = [];
hxparse_LexEngine.ALL_CHARS = [new hxparse__$LexEngine_CharRange(0,255)];
haxeparser_HaxeLexer.keywords = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["abstract"] = haxeparser_Keyword.KwdAbstract;
	_g.h["break"] = haxeparser_Keyword.KwdBreak;
	_g.h["case"] = haxeparser_Keyword.KwdCase;
	_g.h["cast"] = haxeparser_Keyword.KwdCast;
	_g.h["catch"] = haxeparser_Keyword.KwdCatch;
	_g.h["class"] = haxeparser_Keyword.KwdClass;
	_g.h["continue"] = haxeparser_Keyword.KwdContinue;
	_g.h["default"] = haxeparser_Keyword.KwdDefault;
	_g.h["do"] = haxeparser_Keyword.KwdDo;
	_g.h["dynamic"] = haxeparser_Keyword.KwdDynamic;
	_g.h["else"] = haxeparser_Keyword.KwdElse;
	_g.h["enum"] = haxeparser_Keyword.KwdEnum;
	_g.h["extends"] = haxeparser_Keyword.KwdExtends;
	_g.h["extern"] = haxeparser_Keyword.KwdExtern;
	_g.h["false"] = haxeparser_Keyword.KwdFalse;
	_g.h["final"] = haxeparser_Keyword.KwdFinal;
	_g.h["for"] = haxeparser_Keyword.KwdFor;
	_g.h["function"] = haxeparser_Keyword.KwdFunction;
	_g.h["if"] = haxeparser_Keyword.KwdIf;
	_g.h["implements"] = haxeparser_Keyword.KwdImplements;
	_g.h["import"] = haxeparser_Keyword.KwdImport;
	_g.h["inline"] = haxeparser_Keyword.KwdInline;
	_g.h["interface"] = haxeparser_Keyword.KwdInterface;
	_g.h["macro"] = haxeparser_Keyword.KwdMacro;
	_g.h["new"] = haxeparser_Keyword.KwdNew;
	_g.h["null"] = haxeparser_Keyword.KwdNull;
	_g.h["operator"] = haxeparser_Keyword.KwdOperator;
	_g.h["overload"] = haxeparser_Keyword.KwdOverload;
	_g.h["override"] = haxeparser_Keyword.KwdOverride;
	_g.h["package"] = haxeparser_Keyword.KwdPackage;
	_g.h["private"] = haxeparser_Keyword.KwdPrivate;
	_g.h["public"] = haxeparser_Keyword.KwdPublic;
	_g.h["return"] = haxeparser_Keyword.KwdReturn;
	_g.h["static"] = haxeparser_Keyword.KwdStatic;
	_g.h["switch"] = haxeparser_Keyword.KwdSwitch;
	_g.h["this"] = haxeparser_Keyword.KwdThis;
	_g.h["throw"] = haxeparser_Keyword.KwdThrow;
	_g.h["true"] = haxeparser_Keyword.KwdTrue;
	_g.h["try"] = haxeparser_Keyword.KwdTry;
	_g.h["typedef"] = haxeparser_Keyword.KwdTypedef;
	_g.h["untyped"] = haxeparser_Keyword.KwdUntyped;
	_g.h["using"] = haxeparser_Keyword.KwdUsing;
	_g.h["var"] = haxeparser_Keyword.KwdVar;
	_g.h["while"] = haxeparser_Keyword.KwdWhile;
	$r = _g;
	return $r;
}(this));
haxeparser_HaxeLexer.buf = new StringBuf();
haxeparser_HaxeLexer.ident = "_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*";
haxeparser_HaxeLexer.sharp_ident = "[a-z_][a-zA-Z0-9_]*(\\.[a-z_][a-zA-Z0-9_]*)*";
haxeparser_HaxeLexer.idtype = "_*[A-Z][a-zA-Z0-9_]*";
haxeparser_HaxeLexer.integer = "([1-9][0-9]*)|0";
haxeparser_HaxeLexer.tok = hxparse_Lexer.buildRuleset([{ rule : "", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Eof);
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.tok);
}},{ rule : "0x[0-9a-fA-F]+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CInt(lexer.current)));
}},{ rule : "([1-9][0-9]*)|0", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CInt(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "\\.[0-9]+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)([eE][\\+\\-]?[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.[0-9]*[eE][\\+\\-]?[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.\\.\\.)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.IntInterval(HxOverrides.substr(lexer.current,0,-3)));
}},{ rule : "//[^\n\r]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.CommentLine(HxOverrides.substr(lexer.current,2,null)));
}},{ rule : "+\\+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpIncrement));
}},{ rule : "--", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpDecrement));
}},{ rule : "~", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNegBits));
}},{ rule : "%=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMod)));
}},{ rule : "&=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAnd)));
}},{ rule : "|=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpOr)));
}},{ rule : "^=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpXor)));
}},{ rule : "+=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd)));
}},{ rule : "-=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpSub)));
}},{ rule : "*=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult)));
}},{ rule : "/=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpDiv)));
}},{ rule : "<<=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShl)));
}},{ rule : "==", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpEq));
}},{ rule : "!=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpNotEq));
}},{ rule : "<=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLte));
}},{ rule : "&&", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolAnd));
}},{ rule : "|\\|", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolOr));
}},{ rule : "<<", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpShl));
}},{ rule : "->", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Arrow);
}},{ rule : "\\.\\.\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpInterval));
}},{ rule : "=>", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpArrow));
}},{ rule : "!", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNot));
}},{ rule : "<", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt));
}},{ rule : ">", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
}},{ rule : ";", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Semicolon);
}},{ rule : ":", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.DblDot);
}},{ rule : ",", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Comma);
}},{ rule : "\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Dot);
}},{ rule : "%", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMod));
}},{ rule : "&", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAnd));
}},{ rule : "|", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpOr));
}},{ rule : "^", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpXor));
}},{ rule : "+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAdd));
}},{ rule : "*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMult));
}},{ rule : "/", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpDiv));
}},{ rule : "-", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpSub));
}},{ rule : "=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
}},{ rule : "in", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpIn));
}},{ rule : "[", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BkOpen);
}},{ rule : "]", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BkClose);
}},{ rule : "{", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BrOpen);
}},{ rule : "}", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BrClose);
}},{ rule : "\\(", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.POpen);
}},{ rule : "\\)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.PClose);
}},{ rule : "?", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Question);
}},{ rule : "@", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.At);
}},{ rule : "\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	var pmax;
	try {
		pmax = lexer.token(haxeparser_HaxeLexer.string);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)),haxe_macro_StringLiteralKind.DoubleQuotes)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "'", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	var pmax;
	try {
		pmax = lexer.token(haxeparser_HaxeLexer.string2);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)),haxe_macro_StringLiteralKind.SingleQuotes)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "~/", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	var info;
	try {
		info = lexer.token(haxeparser_HaxeLexer.regexp);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedRegExp,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CRegexp(haxeparser_HaxeLexer.buf.b,info.opt)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "/\\*", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	var pmax;
	try {
		pmax = lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Comment(haxeparser_HaxeLexer.buf.b));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "(#)(_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Sharp(HxOverrides.substr(lexer.current,1,null)));
}},{ rule : "$[_a-zA-Z0-9]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Dollar(HxOverrides.substr(lexer.current,1,null)));
}},{ rule : "_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*", func : function(lexer) {
	var kwd = haxeparser_HaxeLexer.keywords.h[lexer.current];
	if(kwd != null) {
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Kwd(kwd));
	} else {
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
	}
}},{ rule : "_*[A-Z][a-zA-Z0-9_]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
}}],"tok");
haxeparser_HaxeLexer.string = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\"";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\"", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "[^\\\\\"]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.string);
}}],"string");
haxeparser_HaxeLexer.string2 = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\'", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "'";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "'", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "($$)|(\\$)|$", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "$";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "${", func : function(lexer) {
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	try {
		lexer.token(haxeparser_HaxeLexer.codeString);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedCode,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "[^$\\\\']+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.string2);
}}],"string2");
haxeparser_HaxeLexer.codeString = hxparse_Lexer.buildRuleset([{ rule : "{|/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "}", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
}},{ rule : "\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "'", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string2);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "/\\*", func : function(lexer) {
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "//[^\n\r]*", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "[^/\"'{}\n\r]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}}],"codeString");
haxeparser_HaxeLexer.comment = hxparse_Lexer.buildRuleset([{ rule : "*/", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "*", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "*";
	return lexer.token(haxeparser_HaxeLexer.comment);
}},{ rule : "[^\\*]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.comment);
}}],"comment");
haxeparser_HaxeLexer.regexp = hxparse_Lexer.buildRuleset([{ rule : "\\\\/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "/";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\r", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\r";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\n", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\n";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\t", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\t";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[\\\\$\\.*+\\^|{}\\[\\]()?\\-0-9]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[wWbBsSdDx]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "/", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.regexp_options);
}},{ rule : "[^\\\\/\r\n]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}}],"regexp");
haxeparser_HaxeLexer.regexp_options = hxparse_Lexer.buildRuleset([{ rule : "[gimsu]*", func : function(lexer) {
	return { pmax : new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax, opt : lexer.current};
}}],"regexp_options");
haxeparser_HaxeLexer.sharp_token = hxparse_Lexer.buildRuleset([{ rule : "[a-z_][a-zA-Z0-9_]*(\\.[a-z_][a-zA-Z0-9_]*)*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.sharp_token);
}},{ rule : "/\\*", func : function(lexer) {
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	return lexer.token(haxeparser_HaxeLexer.sharp_token);
}},{ rule : "[.]*", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.tok);
}}],"sharp_token");
haxeparser_HaxeLexer.generatedRulesets = [haxeparser_HaxeLexer.tok,haxeparser_HaxeLexer.string,haxeparser_HaxeLexer.string2,haxeparser_HaxeLexer.codeString,haxeparser_HaxeLexer.comment,haxeparser_HaxeLexer.regexp,haxeparser_HaxeLexer.regexp_options,haxeparser_HaxeLexer.sharp_token];
haxeparser_HaxeParser.nullPos = { min : 0, max : 0, file : "<null pos>"};
tokentree_TokenStream.NO_MORE_TOKENS = "no more tokens";
tokentree_TokenStream.MODE = tokentree_TokenStreamMode.Strict;
tokentree_TokenTree.MAX_LEVEL = 9999;
checkstyle_Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
